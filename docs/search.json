[
  {
    "objectID": "03-wealth-index-simplified.html",
    "href": "03-wealth-index-simplified.html",
    "title": "5  Wealth indexes",
    "section": "",
    "text": "5.1 Verification that rural wealth centiles can be derived from existing DHS data\nThis section documents the process of reconstructing and analyzing wealth indexes for a forthcoming study focusing on rural populations in Madagascar. Wealth indexes, particularly the wealth index factor scores, are critical for assessing household living standards and analyzing inequalities.\nThe wealth index, provided in DHS, is constructed using principal components analysis on household characteristics such as asset ownership, housing materials, and access to water and sanitation facilities. We want a centile classification specific to rural households.\nWe first check whether the centile classification of households is consistent between the national wealth score (hv271) and the rural-specific wealth score (hv271a). The comparison is done for rural households in the 2021 DHS. Both indices are transformed into centiles, and we examine their agreement through simple proportions, correlation, and a scatterplot.\nCode\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(survey)\n\nhh21 &lt;- read_dta(\"data/raw/dhs/DHS_2021/MDHR81DT/MDHR81FL.DTA\")\n\n# Rural only\nhh21_rur &lt;- hh21 %&gt;%\n  filter(hv025 == 2) %&gt;%\n  transmute(\n    hv001, hv002, hv005,\n    c_hv271  = ntile(hv271,  100),\n    c_hv271a = ntile(hv271a, 100)\n  )\n\n# Centile agreement\nmean(hh21_rur$c_hv271 == hh21_rur$c_hv271a, na.rm = TRUE)\n\n\n[1] 0.9998698\n\n\nCode\ncor.test(hh21_rur$c_hv271, hh21_rur$c_hv271a,\n         method = \"spearman\", use = \"complete.obs\")\n\n\n\n    Spearman's rank correlation rho\n\ndata:  hh21_rur$c_hv271 and hh21_rur$c_hv271a\nS = 47437, p-value &lt; 2.2e-16\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n      rho \n0.9999999 \n\n\nCode\n#  Scatterplot with both axes\nggplot(hh21_rur, aes(x = c_hv271, y = c_hv271a)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(method = \"lm\", se = FALSE, linewidth = 0.3, color = \"blue\") +\n  labs(\n    title = \"Rural households (2021): hv271 vs hv271a centiles\",\n    x = \"Centiles from hv271 (national wealth score)\",\n    y = \"Centiles from hv271a (rural wealth score)\"\n  )\nThe results show near-perfect agreement between the two indices, confirming that the national wealth index can be used directly to reconstruct rural centiles, without loss of consistency. This greatly simplifies the treatment of earlier surveys (MIS 2011, 2013, 2016), where domain-specific wealth scores are not provided.",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wealth indexes</span>"
    ]
  },
  {
    "objectID": "03-wealth-index-simplified.html#construction-of-rural-wealth-centiles-across-dhs-surveys",
    "href": "03-wealth-index-simplified.html#construction-of-rural-wealth-centiles-across-dhs-surveys",
    "title": "5  Wealth indexes",
    "section": "5.2 Construction of rural wealth centiles across DHS surveys",
    "text": "5.2 Construction of rural wealth centiles across DHS surveys\nFor comparability over time, we rely directly on the DHS wealth score (hv271) available in each household dataset. In the 1997 DHS, the wealth index is stored separately and must be merged by household identifier. For subsequent surveys (2008–2021), it is included directly in the household file.\nWe then define a single function that filters rural households and computes both unweighted centiles (using ntile()) and weighted centiles that respect the DHS survey design. Weighted centiles are calculated with the survey package using the household sampling weights (hv005). To avoid problems with ties in the weighted quantile thresholds, we add an infinitesimal offset to ensure strictly increasing cut-points.\n\n\nCode\n# In 1997, the wealth indexes are stored in a separate file\nwi97 &lt;- read_dta(\"data/raw/dhs/DHS_1997/MDWI31DT/MDWI31FL.DTA\") %&gt;%\n  select(whhid, hv271 = wlthindf) %&gt;%\n  mutate(whhid = str_trim(whhid, side = \"left\"))\nhh97 &lt;- read_dta(\"data/raw/dhs/DHS_1997/MDHR31DT/MDHR31FL.DTA\") %&gt;%\n  select(hv001, hv002, hv005, hv025) %&gt;%\n  mutate(whhid = paste0(hv001, \n                        str_pad(as.character(hv002), width = 2, side = \"left\", \n                                pad = \" \")))%&gt;%\n  inner_join(wi97, by = \"whhid\")\n# Load the others\nhh08 &lt;- read_dta(\"data/raw/dhs/DHS_2008/MDHR51DT/MDHR51FL.DTA\") %&gt;%\n  select(hv001, hv002, hv005, hv025, hv271)\nhh11 &lt;- read_dta(\"data/raw/dhs/DHS_2011/MDHR61DT/MDHR61FL.DTA\") %&gt;%\n  select(hv001, hv002, hv005, hv025, hv271)\nhh13 &lt;- read_dta(\"data/raw/dhs/DHS_2013/MDHR6ADT/MDHR6AFL.DTA\") %&gt;%\n  select(hv001, hv002, hv005, hv025, hv271)\nhh16 &lt;- read_dta(\"data/raw/dhs/DHS_2016/MDHR71DT/MDHR71FL.DTA\") %&gt;%\n  select(hv001, hv002, hv005, hv025, hv271)\nhh21 &lt;- read_dta(\"data/raw/dhs/DHS_2021/MDHR81DT/MDHR81FL.DTA\") %&gt;%\n  select(hv001, hv002, hv005, hv025, hv271)\n\n\nrural_centiles &lt;- function(df) {\n  # filter rural only\n  df_rur &lt;- df %&gt;% filter(hv025 == 2)\n\n  # weighted centiles\n  df_rur &lt;- df_rur %&gt;% mutate(.w = hv005 / 1e6)\n  des &lt;- svydesign(ids = ~hv001, weights = ~.w, data = df_rur)\n\n  qs &lt;- svyquantile(~hv271, des,\n                    quantiles = seq(0.01, 1, 0.01),\n                    ci = FALSE, na.rm = TRUE)\n  # Avoid ties for weighted centiles\n  thr &lt;- as.numeric(qs[[1]]) + seq_along(qs[[1]]) * 1e-10\n\n  df_rur %&gt;%\n    mutate(\n      wealth_centile_rural_weighted = \n        cut(hv271, breaks = c(-Inf, thr),\n            labels = 1:100, include.lowest = TRUE, right = TRUE) %&gt;% \n        as.integer(),\n      wealth_centile_rural_simple = ntile(hv271, 100)\n    ) %&gt;%\n    select(-.w)\n}\n\n\nadd_zscore_from_centile &lt;- function(df, centile_col, cluster_col, zscore_col = \"zscore_wealth\") {\n  stats &lt;- df %&gt;%\n    group_by(.data[[cluster_col]]) %&gt;%\n    summarise(m = mean(.data[[centile_col]], na.rm = TRUE),\n              s = sd(.data[[centile_col]],   na.rm = TRUE),\n              .groups = \"drop\")\n  df %&gt;%\n    left_join(stats, by = cluster_col) %&gt;%\n    mutate(!!zscore_col := ifelse(!is.na(s) & s &gt; 0,\n                                  abs(.data[[centile_col]] - m) / s, NA_real_)) %&gt;%\n    select(-m, -s)\n}\n\n# Apply\nhh97_rur &lt;- rural_centiles(hh97) %&gt;%\n  add_zscore_from_centile(\"wealth_centile_rural_weighted\", \"hv001\")\nhh08_rur &lt;- rural_centiles(hh08) %&gt;%\n  add_zscore_from_centile(\"wealth_centile_rural_weighted\", \"hv001\")\nhh11_rur &lt;- rural_centiles(hh11) %&gt;%\n  add_zscore_from_centile(\"wealth_centile_rural_weighted\", \"hv001\")\nhh13_rur &lt;- rural_centiles(hh13) %&gt;%\n  add_zscore_from_centile(\"wealth_centile_rural_weighted\", \"hv001\")\nhh16_rur &lt;- rural_centiles(hh16) %&gt;%\n  add_zscore_from_centile(\"wealth_centile_rural_weighted\", \"hv001\")\nhh21_rur &lt;- rural_centiles(hh21) %&gt;%\n  add_zscore_from_centile(\"wealth_centile_rural_weighted\", \"hv001\")\n\n# Write\nwrite_rds(hh97_rur, \"data/derived/hh_1997_rural_simpler.rds\")\nwrite_rds(hh08_rur, \"data/derived/hh_2008_rural_simpler.rds\")\nwrite_rds(hh21_rur, \"data/derived/hh_2021_rural_simpler.rds\")\nwrite_rds(hh16_rur, \"data/derived/hh_2016_rural_simpler.rds\")\nwrite_rds(hh13_rur, \"data/derived/hh_2013_rural_simpler.rds\")\nwrite_rds(hh11_rur, \"data/derived/hh_2011_rural_simpler.rds\")",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wealth indexes</span>"
    ]
  },
  {
    "objectID": "03-wealth-index-simplified.html#mics-2018-rural-wealth-centiles",
    "href": "03-wealth-index-simplified.html#mics-2018-rural-wealth-centiles",
    "title": "5  Wealth indexes",
    "section": "5.3 MICS 2018: Rural Wealth Centiles",
    "text": "5.3 MICS 2018: Rural Wealth Centiles\nWe extend our analysis by incorporating the 2018 MICS survey for Madagascar, which includes a national wealth score (wscore) and a rural-specific wealth score (wscorer). We first assess the concordance of centile classifications based on these two scores among rural households. Then, we compute unweighted and weighted rural centiles based on the national score to ensure consistency with the DHS-based measures.\n\n\nCode\n# Load MICS 2018 household data\nhh18 &lt;- read_spss(\"data/raw/mics/2018/SPSS datasets/hh.sav\")\n\n# Restrict to rural households and compute centiles from national and rural scores\nhh18_rur &lt;- hh18 %&gt;%\n  filter(HH6 == 2) %&gt;%  # Rural only\n  transmute(\n    HH1, HH2, HH6, HH5Y, stratum, wscorer, wscore,\n    PSU = as.integer(PSU),\n    hhweight)\n\ndes &lt;- svydesign(ids = ~PSU, weights = ~hhweight, data = hh18_rur)\nqs &lt;- svyquantile(~wscorer, des, quantiles = seq(0.01, 1, 0.01),\n                    ci = FALSE, na.rm = TRUE)\nthr &lt;- as.numeric(qs[[1]]) + seq_along(qs[[1]]) * 1e-10\n\n# Add the data\nhh18_rur &lt;- hh18_rur %&gt;%\n    mutate(\n      wealth_centile_rural_weighted = cut(wscore, breaks = c(-Inf, thr),\n                                          labels = 1:100, include.lowest = TRUE, \n                                          right = TRUE),\n      wealth_centile_rural_weighted = as.numeric(wealth_centile_rural_weighted),\n      wealth_centile_rural_simple = ntile(wscore, 100))  %&gt;%\n  add_zscore_from_centile(centile_col = \"wealth_centile_rural_weighted\", \n                          cluster_col = \"PSU\", \n                          zscore_col = \"zscore_wealth\") \n\n# Rename as in the dhs surveyx\n\nhh18_rur &lt;- hh18_rur %&gt;%\n  select(\n    hv001 = PSU, # cluster\n    hv002 = HH1, # household number\n    hv005 = hhweight, # household weight\n    hv025 = HH6, # urban/rural indicator\n    hv271 = wscore, # wealth score\n    wealth_centile_rural_weighted,\n    wealth_centile_rural_simple,\n    zscore_wealth) %&gt;%\n  mutate(hv005 = as.integer(hv005 * 1e6)) # To imitate DHS weights\n\n# Write\nwrite_rds(hh18_rur, \"data/derived/hh_2018_rural_simpler.rds\")\n\n\nThe rural wealth centiles are now computed consistently across survey types and years, using the national wealth index as a starting point, with (wealth_centile_rural_weighted) and without (wealth_centile_rural_simple) survey wheighing.",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wealth indexes</span>"
    ]
  },
  {
    "objectID": "04-variable-consolidation.html",
    "href": "04-variable-consolidation.html",
    "title": "6  Consolidation",
    "section": "",
    "text": "6.1 Objectif\nL’objectif de ce document est de combiner les clusters de 1997, 2008 et 2021 avec leurs caractéristiques géophysiques et leur variable de résultat respectif dans un seul dataframe.",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Consolidation</span>"
    ]
  },
  {
    "objectID": "04-variable-consolidation.html#méthodes",
    "href": "04-variable-consolidation.html#méthodes",
    "title": "6  Consolidation",
    "section": "6.2 Méthodes",
    "text": "6.2 Méthodes\nLes fichiers contenant les données du Household Recode (HR) pour les années 1997, 2008 et 2021, fournis par DHS, sont d’abord chargés. Pour chaque année, on sélectionne que les variables nécessaires pour l’analyse, à savoir les identifiants des ménages (hv001 et hv002) et les wealth index. On fusionne ces données avec les données géophysiques des ménages, permettant ainsi de constituer un seul dataframe consolidé pour chaque année.\n\n\nCode\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(haven)\nlibrary(lubridate)\n\n# Covariates spatio-temporelles + classification de traitement\nspatial_covars_spei &lt;- readRDS(\"data/derived/spatial_covars_spei_staggered.rds\")\nall_covars &lt;- spatial_covars_spei %&gt;%\n  select(DHSYEAR, DHSCLUST, URBAN_RURA, treecover_area, slope, elevation,\n         population_count, traveltime_2000, spei_wc)\n\nall_class &lt;- read.csv(\"data/derived/cluster_treatment_classification_staggered.csv\")\n\n# Helper: fabrique la table finale pour une année donnée\nvars_to_nest &lt;- c(\"treecover_area\", \"slope\", \"elevation\",\n                  \"population_count\", \"traveltime_2000\", \"spei_wc\")\n\nbuild_year &lt;- function(hr_object,\n                       year,\n                       hh_rural_path,\n                       spei_years = (year-2):year) {\n\n  # Charger HR (identifiants + variables chef) et HH_rural (centiles/zscore déjà calculés)\n  hr &lt;- hr_object %&gt;%\n    dplyr::select(hv001, hv002, hv219, hv220)\n  \n  hh_rural &lt;- read_rds(hh_rural_path) # contient hv001/hv002 + wealth_* déjà prêts\n  \n  # Joindre covariates spatiaux + classification de groupes\n  base &lt;- hh_rural %&gt;%\n    left_join(hr, by = c(\"hv001\", \"hv002\")) %&gt;%\n    left_join(\n      all_covars %&gt;% filter(DHSYEAR == year) %&gt;% select(-DHSYEAR),\n      by = c(\"hv001\" = \"DHSCLUST\")\n    ) %&gt;%\n    left_join(\n      all_class %&gt;% filter(DHSYEAR == year) %&gt;% select(-DHSYEAR),\n      by = c(\"hv001\" = \"DHSCLUST\")\n    ) %&gt;%\n    mutate(DHSYEAR = year) %&gt;%\n    relocate(DHSYEAR, .before = everything())\n  \n  # Désimbriquer les covars imbriquées et appliquer la fenêtre temporelle SPEI\n  #    moyenne par (hv001, hv002) pour chaque indicateur_année\n  df_long &lt;- base %&gt;%\n    select(hv001, hv002, any_of(vars_to_nest)) %&gt;%\n    pivot_longer(cols = any_of(vars_to_nest),\n                 names_to = \"indicator\", values_to = \"data\") %&gt;%\n    unnest(data) %&gt;%\n    filter(indicator != \"spei_wc\" | year(datetime) %in% spei_years) %&gt;%\n    mutate(year_indicator = paste0(indicator, \"_\", year(datetime))) %&gt;%\n    select(hv001, hv002, year_indicator, value)\n  \n  df_wide &lt;- df_long %&gt;%\n    pivot_wider(names_from = year_indicator, values_from = value,\n                names_glue = \"{year_indicator}\") %&gt;%\n    group_by(hv001, hv002) %&gt;%\n    summarise(across(everything(), ~ mean(.x, na.rm = TRUE)), .groups = \"drop\")\n  \n  # Table finale (une ligne par ménage hv001/hv002)\n  out &lt;- base %&gt;%\n    select(-any_of(vars_to_nest)) %&gt;%\n    distinct(hv001, hv002, .keep_all = TRUE) %&gt;%\n    left_join(df_wide, by = c(\"hv001\", \"hv002\"))\n  \n  out\n}\n\n# Application\n\nhr_1997_final &lt;- read_dta(\"data/raw/dhs/DHS_1997/MDHR31DT/MDHR31FL.DTA\") %&gt;%\n  build_year(year = 1997,\n             hh_rural_path = \"data/derived/hh_1997_rural_simpler.rds\",\n             spei_years = 1995:1997)\n\nhr_2008_final &lt;- read_dta(\"data/raw/dhs/DHS_2008/MDHR51DT/MDHR51FL.DTA\") %&gt;%\n  build_year(year = 2008,\n             hh_rural_path = \"data/derived/hh_2008_rural_simpler.rds\",\n             spei_years = 2006:2008)\n\nhr_2011_final &lt;- read_dta(\"data/raw/dhs/DHS_2011/MDHR61DT/MDHR61FL.DTA\") %&gt;%\n  build_year(year = 2011,\n             hh_rural_path = \"data/derived/hh_2011_rural_simpler.rds\",\n             spei_years = 2009:2011)\n\nhr_2013_final &lt;- read_dta(\"data/raw/dhs/DHS_2013/MDHR6ADT/MDHR6AFL.DTA\") %&gt;%\n  build_year(year = 2013,\n  hh_rural_path = \"data/derived/hh_2013_rural_simpler.rds\",\n  spei_years = 2011:2013)\n\nhr_2016_final &lt;- read_dta(\"data/raw/dhs/DHS_2016/MDHR71DT/MDHR71FL.DTA\") %&gt;%\n  build_year(year = 2016,\n  hh_rural_path = \"data/derived/hh_2016_rural_simpler.rds\",\n  spei_years = 2014:2016)\n\nhr_2021_final &lt;- read_dta(\"data/raw/dhs/DHS_2021/MDHR81DT/MDHR81FL.DTA\") %&gt;%\n  build_year(year = 2021,\n  hh_rural_path = \"data/derived/hh_2021_rural_simpler.rds\",\n  spei_years = 2019:2021)\n\nhr_2018_final &lt;- read_spss(\"data/raw/mics/2018/SPSS datasets/hh.sav\") %&gt;%\n  select(hv001 = HH1,# cluter number, \n         hv002 = HH2,# household number, \n         hv219 = HHSEX,# sex of hhh: 1: Masculin, 2: féminin\n         hv220 = HHAGE) %&gt;%# age of hhh: \n  build_year(year = 2018,\n             hh_rural_path = \"data/derived/hh_2021_rural_simpler.rds\",\n             spei_years = 2016:2018)\n\n# Consolidation\n\nhr_consolidated &lt;- bind_rows(\n  hr_1997_final,\n  hr_2008_final,\n  hr_2011_final,\n  hr_2013_final,\n  hr_2016_final,\n  hr_2018_final,\n  hr_2021_final\n)\n\nhr_consolidated %&gt;% count(DHSYEAR)\n\n\n# A tibble: 7 × 2\n  DHSYEAR     n\n    &lt;dbl&gt; &lt;int&gt;\n1    1997  5124\n2    2008 13364\n3    2011  6025\n4    2013  6375\n5    2016  9295\n6    2018 15364\n7    2021 15364\n\n\nEnregistrement des résultats\n\n\nCode\n# Sauvegardes millésime\nwrite_rds(hr_1997_final, \"data/derived/hr_1997_final.rds\")\nwrite_rds(hr_2008_final, \"data/derived/hr_2008_final.rds\")\nwrite_rds(hr_2011_final, \"data/derived/hr_2011_final.rds\")\nwrite_rds(hr_2013_final, \"data/derived/hr_2013_final.rds\")\nwrite_rds(hr_2016_final, \"data/derived/hr_2016_final.rds\")\nwrite_rds(hr_2018_final, \"data/derived/hr_2018_final.rds\")\nwrite_rds(hr_2021_final, \"data/derived/hr_2021_final.rds\")\n\n# Sauvegarde consolidée\nwrite_rds(hr_consolidated, \"data/derived/hr_consolidated_1997_2008_2011_2013_2016_2021.rds\")\ncat(\"Données enregistrées\\n\")\n\n\nDonnées enregistrées",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Consolidation</span>"
    ]
  },
  {
    "objectID": "06-matching.html",
    "href": "06-matching.html",
    "title": "8  Matching",
    "section": "",
    "text": "8.1 Objectif\nLe document illustre l’application de la méthode de matching dans l’analyse. L’objectif de cette méthode est d’équilibrer les échantillons, c’est-à-dire de maximiser la comparabilité entre les groupes de traitement et de contrôle en termes de caractéristiques observables (Ho et al. 2007). Nous comparons donc des groupes traités et contrôles en les appariant selon 5 covariables environnementales (taux de couvert forestier en 2000, la pente, l’altitude, la densité de population en 2000 et l’accessibilité en 2000).\nEn effet, si les deux groupes sont très différents avant le traitement, il est difficile de savoir si les différences observées après viennent du traitement ou simplement de ces différences initiales. D’où l’importance du matching, qui permet de neutraliser ces différences. Plus précisement, nous utilisons le genetic matching, une variante des méthodes de matching. Bien qu’ayant le même objectif, cette approche repose sur des algorithmes d’optimisation qui ajustent les facteurs de confusion susceptibles d’influencer à la fois la probabilité de recevoir le traitement et les résultats observés.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "06-matching.html#méthodes",
    "href": "06-matching.html#méthodes",
    "title": "8  Matching",
    "section": "8.2 Méthodes",
    "text": "8.2 Méthodes\nNous réalisons le matching à l’aide de la méthode genetic matching, en utilisant la fonction GenMatch() du package R MatchIt. Cette méthode combine les variables de matching en une seule mesure unique de distance “Mahalanobis distance matching”. Cette distance mesurera la différence entre les unités des groupes appariés pour quantifier la similitude entre les deux groupes d’observations, tout en tenant compte des corrélations entre les covariables et de leurs covariances (Diamond and Sekhon 2013).\nDans un premier temps, nous appliquons la fonction GenMatch() pour identifier la combinaison optimale de poids attribués à chaque covariable, dans le but de maximiser l’équilibre entre le groupe de traitement et de contrôle. Nous obtenons une matrice de poids mais aucune paire n’est encore formée. Dans un second temps, nous utilisons la fonction matchIt(), en intégrant la pondération trouvée auparavant, afin de constituer les paires entre les unités traitées et non traitées.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "06-matching.html#exécution-du-matching-pour-toutes-les-années",
    "href": "06-matching.html#exécution-du-matching-pour-toutes-les-années",
    "title": "8  Matching",
    "section": "8.3 Exécution du matching pour toutes les années",
    "text": "8.3 Exécution du matching pour toutes les années\n\n\nCode\n# Library \nlibrary(tidyverse) #Manipulation et visualisation des données\nlibrary(sf) #Analyse des données spatiales\nlibrary(tmap) #Analyse cartographique\nlibrary(MatchIt) #Matching\nlibrary(ggplot2) #Figure\nlibrary(rbounds)\nlibrary(rgenoud)\nlibrary(Matching)\nlibrary(progressr)\nlibrary(glue)\nmatching_variables &lt;- c(\n  \"treecover_area_2000\",\"slope_2000\",\"elevation_2000\",\n  \"population_count_2000\",\"traveltime_2000_2000\"\n)\n\nprep_matching &lt;- function(df_final) {\n  out &lt;- df_final %&gt;%\n    filter(GROUP %in% c(\"Treatment\",\"Control\")) %&gt;%\n    mutate(treatment = if_else(GROUP == \"Treatment\", 1L, 0L))\n  missing_cols &lt;- setdiff(matching_variables, names(out))\n  if (length(missing_cols) &gt; 0) {\n    message(\"&gt;&gt; Colonnes manquantes: \", paste(missing_cols, collapse=\", \"))\n  }\n  out %&gt;% drop_na(all_of(intersect(matching_variables, names(out))))\n}\n\n# supprimer toute ancienne version pour éviter le masquage\nif (exists(\"run_matching_year\")) rm(run_matching_year)\n\nrun_matching_year &lt;- function(year, overwrite = list(gen=FALSE, match=FALSE)) {\n  cat(\"\\n=== Matching\", year, \"===\\n\")\n  fin_path &lt;- glue(\"data/derived/hr_{year}_final.rds\")\n  if (!file.exists(fin_path)) stop(\"Fichier introuvable: \", fin_path)\n  \n  dat   &lt;- readRDS(fin_path)\n  dat_m &lt;- prep_matching(dat)\n  \n  cat(glue(\"&gt;&gt; N total={nrow(dat)}, après filtre/NA={nrow(dat_m)}; \",\n           \"Traités={sum(dat_m$treatment==1,na.rm=TRUE)}, \",\n           \"Contrôles={sum(dat_m$treatment==0,na.rm=TRUE)}\\n\"))\n  \n  have_all_vars &lt;- all(matching_variables %in% names(dat_m))\n  cat(\"&gt;&gt; Toutes les covars présentes ? \", have_all_vars, \"\\n\")\n  if (nrow(dat_m) &lt; 5 || !have_all_vars) {\n    warning(glue(\"Année {year}: données insuffisantes ou variables manquantes — on saute.\"))\n    return(NULL)\n  }\n  \n  X_match &lt;- dat_m %&gt;%\n    sf::st_drop_geometry() %&gt;%\n    dplyr::select(all_of(matching_variables)) %&gt;%\n    as.data.frame()\n  \n  gen_path         &lt;- glue(\"data/derived/gen_match_model_{year}.rds\")\n  match_path       &lt;- glue(\"data/derived/matching_result_{year}.rds\")\n  matched_out_path &lt;- glue(\"data/derived/data_matched_{year}.rds\")\n  \n  # --- GenMatch ---\n  used_cache_gen &lt;- FALSE\n  t0 &lt;- Sys.time()\n  if (file.exists(gen_path) && !isTRUE(overwrite$gen)) {\n    cat(\"&gt;&gt; GenMatch: cache trouvé -&gt; lecture\\n\")\n    gen_model &lt;- readRDS(gen_path)\n    used_cache_gen &lt;- TRUE\n  } else {\n    cat(\"&gt;&gt; GenMatch: calcul en cours...\\n\")\n    gen_model &lt;- GenMatch(\n      Tr = dat_m$treatment,\n      X  = X_match,\n      BalanceMatrix = X_match,\n      estimand = \"ATT\",\n      M = 1,\n      weights = NULL,\n      pop.size = 1000,\n      max.generations = 100,\n      wait.generations = 4,\n      caliper = .25,\n      print.level = 1,\n      cluster = rep(\"localhost\", 4)\n    )\n    saveRDS(gen_model, gen_path)\n  }\n  t_gen &lt;- as.numeric(difftime(Sys.time(), t0, units=\"mins\"))\n  cat(glue(\"&gt;&gt; GenMatch temps = {round(t_gen,1)} min (cache={used_cache_gen})\\n\"))\n  \n  # --- matchit() ---\n  used_cache_match &lt;- FALSE\n  t1 &lt;- Sys.time()\n  if (file.exists(match_path) && !isTRUE(overwrite$match)) {\n    cat(\"&gt;&gt; matchit: cache trouvé → lecture\\n\")\n    m_out &lt;- readRDS(match_path)\n    used_cache_match &lt;- TRUE\n  } else {\n    cat(\"&gt;&gt; matchit: calcul en cours...\\n\")\n    fml &lt;- as.formula(paste(\"treatment ~\", paste(matching_variables, collapse=\" + \")))\n    m_out &lt;- matchit(\n      formula   = fml,\n      data      = dat_m,\n      method    = \"genetic\",\n      distance  = \"mahalanobis\",\n      gen.match = gen_model\n    )\n    saveRDS(m_out, match_path)\n  }\n  t_match &lt;- as.numeric(difftime(Sys.time(), t1, units=\"mins\"))\n  cat(glue(\"&gt;&gt; matchit temps = {round(t_match,1)} min (cache={used_cache_match})\\n\"))\n  \n  matched &lt;- match.data(m_out, data = sf::st_drop_geometry(dat_m)) %&gt;%\n    dplyr::filter(weights &gt; 0)\n  saveRDS(matched, matched_out_path)\n  cat(glue(\"&gt;&gt; N appariés = {nrow(matched)} (écrit: {matched_out_path})\\n\"))\n}\n\nneed_overwrite &lt;- function(year) {\n  gen_path   &lt;- glue(\"data/derived/gen_match_model_{year}.rds\")\n  match_path &lt;- glue(\"data/derived/matching_result_{year}.rds\")\n  list(gen = !file.exists(gen_path), match = !file.exists(match_path))\n}\n\n# --- Exécution avec progression ---\nyrs &lt;- c(1997, 2008, 2011, 2013, 2016, 2018, 2021)\n\nres_list &lt;- vector(\"list\", length(yrs))\nnames(res_list) &lt;- yrs\n\nfor (i in seq_along(yrs)) {\n  yr &lt;- yrs[i]\n  ow &lt;- need_overwrite(yr) \n  cat(glue(\"\\n&gt;&gt; overwrite {yr}: gen={ow$gen}, match={ow$match}\\n\"))\n  cat(sprintf(\"Start %s\", yr))\n  t_all &lt;- Sys.time()\n  res_list[[i]] &lt;- tryCatch(\n    run_matching_year(yr, overwrite = ow),\n    error = function(e) { warning(glue(\"Year {yr} ERROR: {e$message}\")); NULL }\n  )\n  cat(sprintf(\"Done %s (%.1f min)\",\n            yr, as.numeric(difftime(Sys.time(), t_all, units=\"mins\"))))\n}\n\n\n&gt;&gt; overwrite 1997: gen=FALSE, match=FALSEStart 1997\n=== Matching 1997 ===\n&gt;&gt; N total=5124, après filtre/NA=4470; Traités=965, Contrôles=3505&gt;&gt; Toutes les covars présentes ?  TRUE \n&gt;&gt; GenMatch: cache trouvé -&gt; lecture\n&gt;&gt; GenMatch temps = 0 min (cache=TRUE)&gt;&gt; matchit: cache trouvé → lecture\n&gt;&gt; matchit temps = 0 min (cache=TRUE)&gt;&gt; N appariés = 1930 (écrit: data/derived/data_matched_1997.rds)Done 1997 (0.0 min)&gt;&gt; overwrite 2008: gen=FALSE, match=FALSEStart 2008\n=== Matching 2008 ===\n&gt;&gt; N total=13364, après filtre/NA=11726; Traités=2451, Contrôles=9275&gt;&gt; Toutes les covars présentes ?  TRUE \n&gt;&gt; GenMatch: cache trouvé -&gt; lecture\n&gt;&gt; GenMatch temps = 0 min (cache=TRUE)&gt;&gt; matchit: cache trouvé → lecture\n&gt;&gt; matchit temps = 0 min (cache=TRUE)&gt;&gt; N appariés = 4902 (écrit: data/derived/data_matched_2008.rds)Done 2008 (0.0 min)&gt;&gt; overwrite 2011: gen=FALSE, match=FALSEStart 2011\n=== Matching 2011 ===\n&gt;&gt; N total=6025, après filtre/NA=5151; Traités=930, Contrôles=4221&gt;&gt; Toutes les covars présentes ?  TRUE \n&gt;&gt; GenMatch: cache trouvé -&gt; lecture\n&gt;&gt; GenMatch temps = 0 min (cache=TRUE)&gt;&gt; matchit: cache trouvé → lecture\n&gt;&gt; matchit temps = 0 min (cache=TRUE)&gt;&gt; N appariés = 1860 (écrit: data/derived/data_matched_2011.rds)Done 2011 (0.0 min)&gt;&gt; overwrite 2013: gen=FALSE, match=FALSEStart 2013\n=== Matching 2013 ===\n&gt;&gt; N total=6375, après filtre/NA=5533; Traités=1539, Contrôles=3994&gt;&gt; Toutes les covars présentes ?  TRUE \n&gt;&gt; GenMatch: cache trouvé -&gt; lecture\n&gt;&gt; GenMatch temps = 0 min (cache=TRUE)&gt;&gt; matchit: cache trouvé → lecture\n&gt;&gt; matchit temps = 0 min (cache=TRUE)&gt;&gt; N appariés = 3078 (écrit: data/derived/data_matched_2013.rds)Done 2013 (0.0 min)&gt;&gt; overwrite 2016: gen=FALSE, match=FALSEStart 2016\n=== Matching 2016 ===\n&gt;&gt; N total=9295, après filtre/NA=8456; Traités=1685, Contrôles=6771&gt;&gt; Toutes les covars présentes ?  TRUE \n&gt;&gt; GenMatch: cache trouvé -&gt; lecture\n&gt;&gt; GenMatch temps = 0 min (cache=TRUE)&gt;&gt; matchit: cache trouvé → lecture\n&gt;&gt; matchit temps = 0 min (cache=TRUE)&gt;&gt; N appariés = 3370 (écrit: data/derived/data_matched_2016.rds)Done 2016 (0.0 min)&gt;&gt; overwrite 2018: gen=TRUE, match=TRUEStart 2018\n=== Matching 2018 ===\n&gt;&gt; N total=15364, après filtre/NA=10284; Traités=1846, Contrôles=8438&gt;&gt; Toutes les covars présentes ?  TRUE \n&gt;&gt; GenMatch: calcul en cours...\nInitializing Cluster\n\n\n\n\nSat Oct  4 22:03:03 2025\nDomains:\n 0.000000e+00   &lt;=  X1   &lt;=    1.000000e+03 \n 0.000000e+00   &lt;=  X2   &lt;=    1.000000e+03 \n 0.000000e+00   &lt;=  X3   &lt;=    1.000000e+03 \n 0.000000e+00   &lt;=  X4   &lt;=    1.000000e+03 \n 0.000000e+00   &lt;=  X5   &lt;=    1.000000e+03 \n\nData Type: Floating Point\nOperators (code number, name, population) \n    (1) Cloning...........................  122\n    (2) Uniform Mutation..................  125\n    (3) Boundary Mutation.................  125\n    (4) Non-Uniform Mutation..............  125\n    (5) Polytope Crossover................  125\n    (6) Simple Crossover..................  126\n    (7) Whole Non-Uniform Mutation........  125\n    (8) Heuristic Crossover...............  126\n    (9) Local-Minimum Crossover...........  0\n\nSOFT Maximum Number of Generations: 100\nMaximum Nonchanging Generations: 4\nPopulation size       : 1000\nConvergence Tolerance: 1.000000e-03\n\nNot Using the BFGS Derivative Based Optimizer on the Best Individual Each Generation.\nNot Checking Gradients before Stopping.\nUsing Out of Bounds Individuals.\n\nMaximization Problem.\n\n\nGeneration#     Solution Values (lexical)\n\n      0     0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  3.148592e-12  4.859668e-12  2.648249e-09  1.169826e-08  2.251059e-08  \n\n'wait.generations' limit reached.\nNo significant improvement in 4 generations.\n\nSolution Lexical Fitness Value:\n0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  0.000000e+00  3.148592e-12  4.859668e-12  2.648249e-09  1.169826e-08  2.251059e-08  \n\nParameters at the Solution:\n\n X[ 1] :    9.775562e+02\n X[ 2] :    1.991534e+02\n X[ 3] :    8.928571e+02\n X[ 4] :    3.687361e+02\n X[ 5] :    8.902673e+01\n\nSolution Found Generation 1\nNumber of Generations Run 5\n\nSat Oct  4 22:16:18 2025\nTotal run time : 0 hours 13 minutes and 15 seconds\n&gt;&gt; GenMatch temps = 13.3 min (cache=FALSE)&gt;&gt; matchit: calcul en cours...\n\n\n&gt;&gt; matchit temps = 4.3 min (cache=FALSE)&gt;&gt; N appariés = 3692 (écrit: data/derived/data_matched_2018.rds)Done 2018 (17.6 min)&gt;&gt; overwrite 2021: gen=FALSE, match=FALSEStart 2021\n=== Matching 2021 ===\n&gt;&gt; N total=15364, après filtre/NA=13405; Traités=3392, Contrôles=10013&gt;&gt; Toutes les covars présentes ?  TRUE \n&gt;&gt; GenMatch: cache trouvé -&gt; lecture\n&gt;&gt; GenMatch temps = 0 min (cache=TRUE)&gt;&gt; matchit: cache trouvé → lecture\n&gt;&gt; matchit temps = 0 min (cache=TRUE)&gt;&gt; N appariés = 6784 (écrit: data/derived/data_matched_2021.rds)Done 2021 (0.0 min)\n\n\nCode\nbal_tabs &lt;- purrr::imap(res_list, ~ if (!is.null(.x)) cobalt::bal.tab(.x$m) else NULL)\nsaveRDS(bal_tabs, \"data/derived/matching_balance_tabs_all_years.rds\")",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "06-matching.html#matching-for-1997",
    "href": "06-matching.html#matching-for-1997",
    "title": "8  Matching",
    "section": "8.4 Matching for 1997",
    "text": "8.4 Matching for 1997\n\n\nCode\n# Specifying binary variables in the column GROUP\n\nhr_1997_final        &lt;- read_rds(\"data/derived/hr_1997_final.rds\")\nmatching_result_1997 &lt;- read_rds(\"data/derived/matching_result_1997.rds\")  \ndata_matched_1997    &lt;- read_rds(\"data/derived/data_matched_1997.rds\")  \n\n# -- Rendus inchangés --\nsummary(matching_result_1997)\n\n\n\nCall:\nmatchit(formula = fml, data = dat_m, method = \"genetic\", distance = \"mahalanobis\", \n    gen.match = gen_model)\n\nSummary of Balance for All Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      22989.4875    17064.0984          0.6952     0.7280\nslope_2000                   8.7315        7.7879          0.1823     1.7216\nelevation_2000             419.1710      595.0998         -0.3648     0.7370\npopulation_count_2000       38.3757       70.4098         -0.8863     0.0528\ntraveltime_2000_2000       211.3683      231.2499         -0.1713     0.6616\n                      eCDF Mean eCDF Max\ntreecover_area_2000      0.1794   0.3354\nslope_2000               0.0839   0.2284\nelevation_2000           0.1064   0.2512\npopulation_count_2000    0.0705   0.1522\ntraveltime_2000_2000     0.0459   0.1753\n\nSummary of Balance for Matched Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      22989.4875    22374.5487          0.0722     0.9066\nslope_2000                   8.7315        8.5776          0.0297     1.1722\nelevation_2000             419.1710      381.5225          0.0781     1.2857\npopulation_count_2000       38.3757       51.4299         -0.3612     0.2547\ntraveltime_2000_2000       211.3683      214.4112         -0.0262     1.1365\n                      eCDF Mean eCDF Max Std. Pair Dist.\ntreecover_area_2000      0.0463   0.1451          0.5881\nslope_2000               0.0357   0.1161          0.1267\nelevation_2000           0.0435   0.1368          0.4930\npopulation_count_2000    0.0711   0.2767          1.1522\ntraveltime_2000_2000     0.0322   0.1026          0.2634\n\nSample Sizes:\n          Control Treated\nAll          3505     965\nMatched       965     965\nUnmatched    2540       0\nDiscarded       0       0\n\n\nCode\nplot(matching_result_1997)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# n appariés (si tu veux l’afficher)\nnrow(data_matched_1997)\n\n\n[1] 1930\n\n\nCode\n# Summary of Balance\nsummary(matching_result_1997)\n\n\n\nCall:\nmatchit(formula = fml, data = dat_m, method = \"genetic\", distance = \"mahalanobis\", \n    gen.match = gen_model)\n\nSummary of Balance for All Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      22989.4875    17064.0984          0.6952     0.7280\nslope_2000                   8.7315        7.7879          0.1823     1.7216\nelevation_2000             419.1710      595.0998         -0.3648     0.7370\npopulation_count_2000       38.3757       70.4098         -0.8863     0.0528\ntraveltime_2000_2000       211.3683      231.2499         -0.1713     0.6616\n                      eCDF Mean eCDF Max\ntreecover_area_2000      0.1794   0.3354\nslope_2000               0.0839   0.2284\nelevation_2000           0.1064   0.2512\npopulation_count_2000    0.0705   0.1522\ntraveltime_2000_2000     0.0459   0.1753\n\nSummary of Balance for Matched Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      22989.4875    22374.5487          0.0722     0.9066\nslope_2000                   8.7315        8.5776          0.0297     1.1722\nelevation_2000             419.1710      381.5225          0.0781     1.2857\npopulation_count_2000       38.3757       51.4299         -0.3612     0.2547\ntraveltime_2000_2000       211.3683      214.4112         -0.0262     1.1365\n                      eCDF Mean eCDF Max Std. Pair Dist.\ntreecover_area_2000      0.0463   0.1451          0.5881\nslope_2000               0.0357   0.1161          0.1267\nelevation_2000           0.0435   0.1368          0.4930\npopulation_count_2000    0.0711   0.2767          1.1522\ntraveltime_2000_2000     0.0322   0.1026          0.2634\n\nSample Sizes:\n          Control Treated\nAll          3505     965\nMatched       965     965\nUnmatched    2540       0\nDiscarded       0       0\n\n\nCode\nplot(matching_result_1997)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndata_matched_1997 &lt;- data_matched_1997 %&gt;%\n  filter(weights &gt; 0)\nnrow(data_matched_1997)\n\n\n[1] 1930\n\n\nAvant le matching, nous comptons 3 505 observations pour l’année 1997. Les groupes traités et contrôles diffèrent fortement en moyenne pour certaines covariables. Il y a plus de traités (avec un moyenne de 22875) qui vivent dans des zones avec plus de couverture que des contrôles (avec une moyenne de 16932). Mais ce sont les contrôles qui vivent le plus à une haute altitude (en moyenne 595 m) que les traités (en moyenne 419 m) et dans des zones plus peuplées. Le déséquilibre est particulièrement fort pour la variable population_count_2000.\nAprès le matching, les mêmes variables montrent une forte amélioration avec des moyennes bien plus proches qu’avant le matching. Seule la variable population_count_2000 reste préoccupante. Son ratio de variance est très bas, a une valeur de 0,4968 indiquant une forte hétérogénéité.\nPour maintenir l’équilibre des covariables, nous obtenons alors 1930 observations appariées (965 groupes de traitement et 965 groupes de contrôles).",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "06-matching.html#matching-for-2008",
    "href": "06-matching.html#matching-for-2008",
    "title": "8  Matching",
    "section": "8.5 Matching for 2008",
    "text": "8.5 Matching for 2008\n\n\nCode\nhr_2008_final        &lt;- readRDS(\"data/derived/hr_2008_final.rds\")\nmatching_result_2008 &lt;- readRDS(\"data/derived/matching_result_2008.rds\")\ndata_matched_2008    &lt;- readRDS(\"data/derived/data_matched_2008.rds\")\n\n# Summary of Balance\nsummary(matching_result_2008)\n\n\n\nCall:\nmatchit(formula = fml, data = dat_m, method = \"genetic\", distance = \"mahalanobis\", \n    gen.match = gen_model)\n\nSummary of Balance for All Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      21555.0099    15052.1062          0.7107     0.8255\nslope_2000                   8.3438        7.7443          0.1143     1.6881\nelevation_2000             398.6077      631.6943         -0.5079     0.6963\npopulation_count_2000       36.3171       53.1886         -0.5386     0.1170\ntraveltime_2000_2000       238.0944      218.9418          0.1477     1.1772\n                      eCDF Mean eCDF Max\ntreecover_area_2000      0.1834   0.3288\nslope_2000               0.0851   0.2064\nelevation_2000           0.1279   0.2339\npopulation_count_2000    0.0757   0.1513\ntraveltime_2000_2000     0.0469   0.1489\n\nSummary of Balance for Matched Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      21555.0099    21355.4936          0.0218     0.9258\nslope_2000                   8.3438        8.0084          0.0640     1.1407\nelevation_2000             398.6077      374.4278          0.0527     1.0223\npopulation_count_2000       36.3171       34.3995          0.0612     1.1145\ntraveltime_2000_2000       238.0944      239.7483         -0.0128     1.0164\n                      eCDF Mean eCDF Max Std. Pair Dist.\ntreecover_area_2000      0.0196   0.0885          0.1653\nslope_2000               0.0311   0.0832          0.4061\nelevation_2000           0.0248   0.0853          0.5490\npopulation_count_2000    0.0265   0.0816          0.4186\ntraveltime_2000_2000     0.0168   0.0612          0.1180\n\nSample Sizes:\n          Control Treated\nAll          9275    2451\nMatched      2451    2451\nUnmatched    6824       0\nDiscarded       0       0\n\n\nCode\nplot(matching_result_2008)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndata_matched_2008 &lt;- data_matched_2008 %&gt;%\n  filter(weights &gt; 0)\nnrow(data_matched_2008)\n\n\n[1] 4902\n\n\nCode\nsaveRDS(data_matched_2008,\"data/derived/data_matched_2008.rds\" )\n\n\nAvant le matching pour l’année 2008, nous avons 9 307 groupes de contrôle et 2 419 groupes de traitement sur les 15 364 observations. Nous remarquons que les groupes sont très différents sur la plupart des variables utilisées, surtout sur la variable treecover_area_2000 et population_count_2000. Après le matching, la majorité des variables sont en équilibres sauf pour la variable population_count_2000. Cette variable a une ration de variance très bas indiquant une forte hétérogénéité. Nous obtenons alors 4 838 groupes appariés, avec un total de 13 405 observations.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "06-matching.html#matching-for-2021",
    "href": "06-matching.html#matching-for-2021",
    "title": "8  Matching",
    "section": "8.6 Matching for 2021",
    "text": "8.6 Matching for 2021\n\n\nCode\nhr_2021_final        &lt;- readRDS(\"data/derived/hr_2021_final.rds\")\nmatching_result_2021 &lt;- readRDS(\"data/derived/matching_result_2021.rds\")\ndata_matched_2021    &lt;- readRDS(\"data/derived/data_matched_2021.rds\")\n\n# Summary of Balance\nsummary(matching_result_2021)\n\n\n\nCall:\nmatchit(formula = fml, data = dat_m, method = \"genetic\", distance = \"mahalanobis\", \n    gen.match = gen_model)\n\nSummary of Balance for All Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      22804.3125    14343.0312          0.9530     0.8616\nslope_2000                   8.7864        7.6283          0.2169     1.7891\nelevation_2000             432.9184      639.3136         -0.4324     0.7918\npopulation_count_2000       30.6060       52.3768         -0.6073     0.1129\ntraveltime_2000_2000       262.6296      218.3512          0.2625     2.7822\n                      eCDF Mean eCDF Max\ntreecover_area_2000      0.2354   0.4346\nslope_2000               0.0958   0.2267\nelevation_2000           0.1138   0.2506\npopulation_count_2000    0.0658   0.1666\ntraveltime_2000_2000     0.0637   0.1487\n\nSummary of Balance for Matched Data:\n                      Means Treated Means Control Std. Mean Diff. Var. Ratio\ntreecover_area_2000      22804.3125    19215.4221          0.4042     0.8288\nslope_2000                   8.7864        8.6750          0.0209     1.1328\nelevation_2000             432.9184      426.1131          0.0143     0.9764\npopulation_count_2000       30.6060       30.8912         -0.0080     1.4136\ntraveltime_2000_2000       262.6296      252.4688          0.0602     2.2960\n                      eCDF Mean eCDF Max Std. Pair Dist.\ntreecover_area_2000      0.0933   0.2382          0.8205\nslope_2000               0.0212   0.0811          0.1737\nelevation_2000           0.0190   0.0834          0.1107\npopulation_count_2000    0.0240   0.0799          0.6410\ntraveltime_2000_2000     0.0295   0.0817          0.2684\n\nSample Sizes:\n          Control Treated\nAll         10013    3392\nMatched      3392    3392\nUnmatched    6621       0\nDiscarded       0       0\n\n\nCode\nplot(matching_result_2021)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndata_matched_2021 &lt;- data_matched_2021 %&gt;%\n  filter(weights &gt; 0)\nnrow(data_matched_2021)\n\n\n[1] 6784\n\n\nCode\nsaveRDS(data_matched_2021,\"data/derived/data_matched_2021.rds\" )\n\n\nAvant le matching pour l’année 2021, nous avons 10 074 groupe de traitement et 3 331 groupe de contrôle sur 15 364 observations. L’équilibre des covariables différent pour les deux groupes. Après le matching, on voit une forte réduction du biais de sélection, surtout pour les variables de base comme le treecover_area et elevation. Tandis quer les variables traveltime_2000_2000 et population_count_2000 présentent encore des problèmes de variance résiduels avec une valeur de 1.4583 et 1.9191. Au total, nous obtenons 6 662 groupes appariés (dont 6743 groupes exclus) avec un total de 13 405 observations.\nCi-suit une carte qui représente les localisations des groupes appariées pour les trois années d’études. Chaque point représente les ménages retenus après le matching.\n\n\nCode\n# Fonction pour convertir les variables labelled en facteur \nconvert_labelled &lt;- function(df) {\n  df %&gt;% mutate(across(where(haven::is.labelled), haven::as_factor))\n}\n\n# Chargement des données appariées \ndata_matched_1997 &lt;- readRDS(\"data/derived/data_matched_1997.rds\") |&gt; convert_labelled ()\ndata_matched_2008 &lt;- readRDS(\"data/derived/data_matched_2008.rds\") |&gt; convert_labelled()\ndata_matched_2021 &lt;- readRDS(\"data/derived/data_matched_2021.rds\") |&gt; convert_labelled()\n\n# Fusion des dataframes appariés \ndf_all &lt;- bind_rows(data_matched_1997, data_matched_2008, data_matched_2021)\n\n# Ajout des coordonnées GPS\ngps_1997_initial &lt;- st_read(\"data/raw/dhs/DHS_1997/MDGE32FL/MDGE32FL.shp\")\n\n\nReading layer `MDGE32FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_1997\\MDGE32FL\\MDGE32FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 269 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 6.661338e-16 ymin: -25.28438 xmax: 50.45773 ymax: 0\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2008_initial &lt;- st_read(\"data/raw/dhs/DHS_2008/MDGE53FL/MDGE53FL.shp\") \n\n\nReading layer `MDGE53FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_2008\\MDGE53FL\\MDGE53FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 594 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0 ymin: -25.52226 xmax: 50.29224 ymax: 0\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2021_initial &lt;- st_read(\"data/raw/dhs/DHS_2021/MDGE81FL/MDGE81FL.shp\")\n\n\nReading layer `MDGE81FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_2021\\MDGE81FL\\MDGE81FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 650 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 43.3746 ymin: -25.5548 xmax: 50.36067 ymax: -11.99102\nGeodetic CRS:  WGS 84\n\n\nCode\n# Fusion des données GPS \ngps_data &lt;- bind_rows(\n  gps_1997_initial %&gt;% st_drop_geometry(),\n  gps_2008_initial %&gt;% st_drop_geometry(),\n  gps_2021_initial %&gt;% st_drop_geometry()\n)\n\n\n# Jointure des coordonnées GPS aux données appariées \ndf_all_with_coords &lt;- df_all %&gt;%\n  left_join(gps_data, by = c(\"hv001\" = \"DHSCLUST\", \"DHSYEAR\" = \"DHSYEAR\"), relationship = \"many-to-many\")\n\n# Conversion en objet spatial sf \ndf_all_sf &lt;- st_as_sf(df_all_with_coords, coords = c(\"LONGNUM\", \"LATNUM\"), crs = 4326)\n\n# Set for interactive viewing\ntmap_mode(\"view\")\n\ndf_all_sf |&gt; \n  tm_shape() + \n  tm_dots(fill = \"DHSYEAR\") +\n  tm_facets(by = \"DHSYEAR\") +\n  tm_layout(legend.outside = TRUE)",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "06-matching.html#carte-des-contrôles-et-des-traités-appariés-des-périodes-détude",
    "href": "06-matching.html#carte-des-contrôles-et-des-traités-appariés-des-périodes-détude",
    "title": "8  Matching",
    "section": "8.7 Carte des contrôles et des traités appariés des périodes d’étude",
    "text": "8.7 Carte des contrôles et des traités appariés des périodes d’étude",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "06-matching.html#checking-covariate-balance",
    "href": "06-matching.html#checking-covariate-balance",
    "title": "8  Matching",
    "section": "8.8 Checking covariate balance",
    "text": "8.8 Checking covariate balance\nLes modèles d’appariement reposent sur l’hypothèse que les distributions des covariables sont similaires entre les groupes de traitement et de contrôle, rendant cruciale l’évaluation de l’équilibre des covariables. La validité des estimations dépend directement de la qualité de cet équilibre, d’où l’importance de réaliser des tests pour le mesurer. On effectue donc un test d’équilibre des covariables en deux étapes: un test avant appariement et un test après appariement.\nPour effectuer le test avant l’appariement, on détermine les déséquilibres initiaux à partir du test de Standardized Mean Difference (SMD). Le SMD mesure l’écart entre les moyennes des covariables dans les groupes de traitement et les groupes de contrôle pour comparer l’équilibre relatif des variables mesurées dans des unités différentes:\n\nSi |SMD| &lt; 0.1, il existe un équilibre satisfaisant entre les groupes pour la covariable.\nSi SMD &gt; 0.1, le déséquilibre est significatif (Austin 2009). Pour réajuster l’équilibre, on augmentera l’intervalle des calipers afin d’obtenir un SMD ≤ 0.1.\n\nLe test après appariement sera un test visuel de la qualité du matching en comparant la distribution de chaque covariable à partir d’un plot. La méthode graphique offre une vue d’ensemble de la distribution des covariables. Le graphique facilite ainsi l’identification des déséquilibres à différents niveaux de la distribution. Lorsque les points Q-Q plot se situent près de la diagonale, le quantile des deux distributions sont similaires, signalant ainsi un bon équilibre\n\n8.8.1 Balance test for 1997\n\n8.8.1.1 Balance test before matching\n\n\nCode\nlibrary(halfmoon)\nlibrary(cobalt)\n\n\n\n# Balance before matching\nmatching_1997 &lt;- readRDS(\"data/derived/hr_1997_final.rds\") %&gt;%\n  filter(GROUP %in% c(\"Treatment\", \"Control\")) %&gt;%\n  mutate(treatment = if_else(GROUP == \"Treatment\", 1, 0))\n\nbal_before_1997 &lt;- bal.tab(\n  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,\n  data = matching_1997,\n  estimand = \"ATT\",\n  un = TRUE, # Inclusion des covariables non appariées \n  abs = TRUE\n)\n\nprint(bal_before_1997)\n\n\nBalance Measures\n                         Type Diff.Un\ntreecover_area_2000   Contin.  0.6952\nslope_2000            Contin.  0.1823\nelevation_2000        Contin.  0.3648\npopulation_count_2000 Contin.  0.8863\ntraveltime_2000_2000  Contin.  0.1713\n\nSample sizes\n    Control Treated\nAll    3505     965\n\n\nCode\n# Balance plot before matching\nmatching_before_1997 &lt;- matching_1997 %&gt;%\n  pivot_longer(\n    cols = all_of(matching_variables),\n    names_to = \"variable\",\n    values_to = \"value\"\n  )\n  \n\nggplot(matching_before_1997, aes(x = value, fill = GROUP)) +\n  geom_mirror_histogram(alpha = 0.5) +\n  facet_wrap(~variable, scales = \"free\") +\n  scale_fill_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) +\n  labs(\n    tittle = \"Covariate Distribution before matching (1997)\",\n    x = \"Valeur de la covariable\",\n    y = \"Densité\",\n    fill = \"Group\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nCode\n  ggplot(matching_before_1997, aes(x = value, fill = GROUP)) +\n    geom_density(alpha = 0.5, color = \"black\", linewidth = 0.7, adjust = 0.7) +\n    facet_wrap(~variable, scales = \"free\") +\n    scale_fill_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) +\n    labs(\n      title = \"Covariate distribution before matching (1997)\",\n      x = \"Valeur de la covariable\",\n      y = \"Densité\",\n      fill = \"Group\"\n    ) +\n    theme_minimal()\n\n\n\n\n\n\n\n\n\nD’après le balance measures, aucune variable n’est bien équilibrée entre les deux groupes. Deux variables (treecover_area_2000 et population_count_2000) ont des déséquilibres majeurs (SMD &gt; 0.6).\nLes graphiques ici montrent que la distribution de chaque covariable pour les deux groupes: “Traitement” en violet et “Contrôle” en vert. L’axe des ordonnées représente la densité, avec des valeurs positives pour le groupe de traitement et des valeurs négatives pour le groupe de contrôle. Quant à l’axe des abscisses, il représente la valeur de la covariable.\nLes résultats indiquent des déséquilibres importants entre les deux groupes. Les déséquilibres sont plus frappantes pour population_count_2000 et treecover_area_2000.\n\n\n8.8.1.2 Balance test after matching: Q-Q Plot analysis\n\n\nCode\n# Balance after matching\nbal_after_1997 &lt;- bal.tab(matching_result_1997)\nprint(bal_after_1997)\n\n\nBalance Measures\n                         Type Diff.Adj\ntreecover_area_2000   Contin.   0.0722\nslope_2000            Contin.   0.0297\nelevation_2000        Contin.   0.0781\npopulation_count_2000 Contin.  -0.3612\ntraveltime_2000_2000  Contin.  -0.0262\n\nSample sizes\n          Control Treated\nAll          3505     965\nMatched       965     965\nUnmatched    2540       0\n\n\nCode\n# Création d'un format long\nmatched_data_1997 &lt;- match.data(matching_result_1997)\n\nqq_1997 &lt;- matched_data_1997 %&gt;% \n  pivot_longer(\n    cols = all_of(matching_variables),\nnames_to = \"variable\",\nvalues_to = \"value\"\n)\n\n# Traçage des QQ plots\nggplot(qq_1997, aes(sample = value, color = GROUP)) +\n  stat_qq(distribution = stats::qunif) + \n  facet_wrap(~variable, scales = \"free\") +\n  labs(\n    title = \"QQ plots after matching (1997)\",\n    x = \"Quantiles of control group\",\n    y = \"Quantiles of treated group\",\n    color = \"Groupe\"\n  ) + \n  scale_color_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) + \n  theme_minimal()\n\n\n\n\n\n\n\n\n\nCode\n# Une autre graphe \nqq_plots_list &lt;- list()\nfor (var in matching_variables) {\n  # Extraire les valeurs pour Control et Treatment\n  control_values &lt;- matched_data_1997 %&gt;% filter(GROUP == \"Control\") %&gt;% pull(!!sym(var))\n  treated_values &lt;- matched_data_1997 %&gt;% filter(GROUP == \"Treatment\") %&gt;% pull(!!sym(var))\n\n  # S'assurer que les deux vecteurs ont la même longueur pour les quantiles\n  # On utilise le nombre d'observations du plus petit groupe pour les quantiles\n  n_min &lt;- min(length(control_values), length(treated_values))\n  \n  # Calcul des quantiles\n  quantiles_control &lt;- quantile(control_values, probs = seq(0, 1, length.out = n_min), na.rm = TRUE)\n  quantiles_treated &lt;- quantile(treated_values, probs = seq(0, 1, length.out = n_min), na.rm = TRUE)\n  \n  # Création d'un data frame pour ce QQ plot\n  qq_data_var &lt;- tibble(\n    control_q = quantiles_control,\n    treated_q = quantiles_treated,\n    variable = var\n  )\n  qq_plots_list[[var]] &lt;- qq_data_var\n}\n\nqq_combined_data &lt;- bind_rows(qq_plots_list)\n\n# Traçage des QQ plots (quantiles de Control sur X, quantiles de Treatment sur Y)\nggplot(qq_combined_data, aes(x = control_q, y = treated_q)) +\n  geom_point(color = \"blue\") + # Points pour la comparaison des quantiles\n  geom_abline(intercept = 0, slope = 1, linetype = \"dashed\", color = \"red\") +\n  facet_wrap(~variable, scales = \"free\") +\n  labs(\n    title = \"QQ plots after matching (1997)\",\n    x = \"Quantiles of control group\",\n    y = \"Quantiles of treated group\"\n  ) +\n  theme_minimal() +\n  NULL\n\n\n\n\n\n\n\n\n\nD’après le Quantile-Quantile plots, les points sont proches de la ligne diagonale pour la plupart des variables. Tandis que pour les variables treecover_area_2000 et population_count_2000 présentent des déséquilibres. Pour les quantiles supérieurs de la variable population_count_2000, les points s’écartent clairement de la ligne diagonale. Cet écart signifie que les quantiles du groupe de traitement sont inférieurs à ceux du groupe de contrôle. On voit le même cas pour la variable treecover_area_2000, indiquant que le groupe de traitement a des valeurs de couverture arborée légèrement plus élevées que le groupe de contrôle apparié. Le matching a donc amélioré l’équilibre des covariables, mais n’a pas complètement résolu le déséquilibre pour ces deux variables.\n\n\n\n8.8.2 Balance test for 2008\n\n8.8.2.1 Balance test before matching\n\n\nCode\nlibrary(halfmoon)\nlibrary(cobalt)\n\n\n# Balance before matching\nmatching_2008 &lt;- readRDS(\"data/derived/hr_2008_final.rds\") %&gt;%\n  filter(GROUP %in% c(\"Treatment\", \"Control\")) %&gt;%\n  mutate(treatment = if_else(GROUP == \"Treatment\", 1, 0))\n\nbal_before_2008 &lt;- bal.tab(\n  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,\n  data = matching_2008,\n  estimand = \"ATT\",\n  un = TRUE, # Inclusion des covariables non appariées\n  abs = TRUE\n)\n\nprint(bal_before_2008)\n\n\nBalance Measures\n                         Type Diff.Un\ntreecover_area_2000   Contin.  0.7107\nslope_2000            Contin.  0.1143\nelevation_2000        Contin.  0.5079\npopulation_count_2000 Contin.  0.5386\ntraveltime_2000_2000  Contin.  0.1477\n\nSample sizes\n    Control Treated\nAll    9275    2451\n\n\nCode\n# Balance plot before matching\nmatching_before_2008 &lt;- matching_2008 %&gt;%\n  pivot_longer(\n    cols = all_of(matching_variables),\n    names_to = \"variable\",\n    values_to = \"value\"\n  )\n  \n\nggplot(matching_before_2008, aes(x = value, fill = GROUP)) +\n  geom_mirror_histogram(alpha = 0.5) +\n  facet_wrap(~variable, scales = \"free\") +\n  scale_fill_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) +\n  labs(\n    tittle = \"Covariate Distribution before matching (2008)\",\n    x = \"Valeur de la covariable\",\n    y = \"Densité\",\n    fill = \"Group\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nCode\nggplot(matching_before_2008, aes(x = value, fill = GROUP)) +\n    geom_density(alpha = 0.5, color = \"black\", linewidth = 0.7, adjust = 0.7) +\n    facet_wrap(~variable, scales = \"free\") +\n    scale_fill_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) +\n    labs(\n      title = \"Covariate distribution before matching (2008)\",\n      x = \"Valeur de la covariable\",\n      y = \"Densité\",\n      fill = \"Group\"\n    ) +\n    theme_minimal()\n\n\n\n\n\n\n\n\n\nLes résultats montrent que la valeur de la différence standardisée des moyennes entre les groupes traités et contrôles, calculées avant le matching est supérieur à 0.1, qui indique un déséquilibre significatif . Seule la variable slope_2000 a un équilibre modérée avec une valeur de SMD égale à 0.1337.\n\n\n8.8.2.2 Balance test after matching: Q-Q Plot analysis\n\n\nCode\n# Balance after matching\nbal_after_2008 &lt;- bal.tab(matching_result_2008)\nprint(bal_after_2008)\n\n\nBalance Measures\n                         Type Diff.Adj\ntreecover_area_2000   Contin.   0.0218\nslope_2000            Contin.   0.0640\nelevation_2000        Contin.   0.0527\npopulation_count_2000 Contin.   0.0612\ntraveltime_2000_2000  Contin.  -0.0128\n\nSample sizes\n          Control Treated\nAll          9275    2451\nMatched      2451    2451\nUnmatched    6824       0\n\n\nCode\n# Création d'un format long\nmatched_data_2008 &lt;- match.data(matching_result_2008)\n\nqq_2008 &lt;- matched_data_2008 %&gt;% \n  pivot_longer(\n    cols = all_of(matching_variables),\nnames_to = \"variable\",\nvalues_to = \"value\"\n)\n\n# Traçage des QQ plots\nggplot(qq_2008, aes(sample = value, color = GROUP)) +\n  stat_qq(distribution = stats::qunif) + \n  facet_wrap(~variable, scales = \"free\") +\n  labs(\n    title = \"QQ plots after matching (1997)\",\n    x = \"Quantiles of control group\",\n    y = \"Quantiles of treated group\",\n    color = \"Groupe\"\n  ) + \n  scale_color_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) + \n  theme_minimal()\n\n\n\n\n\n\n\n\n\nCode\n# Une autre graphe \nqq_plots_list &lt;- list()\nfor (var in matching_variables) {\n  # Extraire les valeurs pour Control et Treatment\n  control_values &lt;- matched_data_2008 %&gt;% filter(GROUP == \"Control\") %&gt;% pull(!!sym(var))\n  treated_values &lt;- matched_data_2008 %&gt;% filter(GROUP == \"Treatment\") %&gt;% pull(!!sym(var))\n\n  # S'assurer que les deux vecteurs ont la même longueur pour les quantiles\n  # On utilise le nombre d'observations du plus petit groupe pour les quantiles\n  n_min &lt;- min(length(control_values), length(treated_values))\n  \n  # Calcul des quantiles\n  quantiles_control &lt;- quantile(control_values, probs = seq(0, 1, length.out = n_min), na.rm = TRUE)\n  quantiles_treated &lt;- quantile(treated_values, probs = seq(0, 1, length.out = n_min), na.rm = TRUE)\n  \n  # Création d'un data frame pour ce QQ plot\n  qq_data_var &lt;- tibble(\n    control_q = quantiles_control,\n    treated_q = quantiles_treated,\n    variable = var\n  )\n  qq_plots_list[[var]] &lt;- qq_data_var\n}\n\nqq_combined_data &lt;- bind_rows(qq_plots_list)\n\n# Traçage des QQ plots (quantiles de Control sur X, quantiles de Treatment sur Y)\nggplot(qq_combined_data, aes(x = control_q, y = treated_q)) +\n  geom_point(color = \"blue\") + # Points pour la comparaison des quantiles\n  geom_abline(intercept = 0, slope = 1, linetype = \"dashed\", color = \"red\") +\n  facet_wrap(~variable, scales = \"free\") +\n  labs(\n    title = \"QQ plots after matching (2008)\",\n    x = \"Quantiles of control group\",\n    y = \"Quantiles of treated group\"\n  ) +\n  theme_minimal() +\n  NULL\n\n\n\n\n\n\n\n\n\nSur les graphiques, on peut voir que les points s’écartent légèrement de la ligne diagonale pour les variables elevation_2000 et traveltime_2000 à un certain moment. Ce déséquilibre est accentué pour la variable population_count_2000 pour ces quantiles supérieurs de la variables.\n\n\n\n8.8.3 Balance test for 2021\n\n8.8.3.1 Balance test before matching\n\n\nCode\n# Balance before matching\nmatching_2021 &lt;- readRDS(\"data/derived/hr_2021_final.rds\") %&gt;%\n  filter(GROUP %in% c(\"Treatment\", \"Control\")) %&gt;%\n  mutate(treatment = if_else(GROUP == \"Treatment\", 1, 0))\n\nbal_before_2021 &lt;- bal.tab(\n  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,\n  data = matching_2021,\n  estimand = \"ATT\",\n  un = TRUE, # Inclusion des covariables non appariées \n  abs = TRUE\n)\n\nprint(bal_before_2021)\n\n\nBalance Measures\n                         Type Diff.Un\ntreecover_area_2000   Contin.  0.9530\nslope_2000            Contin.  0.2169\nelevation_2000        Contin.  0.4324\npopulation_count_2000 Contin.  0.6073\ntraveltime_2000_2000  Contin.  0.2625\n\nSample sizes\n    Control Treated\nAll   10013    3392\n\n\nCode\n# Balance plot before matching\nmatching_before_2021 &lt;- matching_2021 %&gt;%\n  pivot_longer(\n    cols = all_of(matching_variables),\n    names_to = \"variable\",\n    values_to = \"value\"\n  )\n  \n\nggplot(matching_before_2021, aes(x = value, fill = GROUP)) +\n  geom_mirror_histogram(alpha = 0.5) +\n  facet_wrap(~variable, scales = \"free\") +\n  scale_fill_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) +\n  labs(\n    tittle = \"Covariate Distribution before matching (2021)\",\n    x = \"Covariate value\",\n    y = \"Density\",\n    fill = \"Group\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nCode\nggplot(matching_before_2021, aes(x = value, fill = GROUP)) +\n    geom_density(alpha = 0.5, color = \"black\", linewidth = 0.7, adjust = 0.7) +\n    facet_wrap(~variable, scales = \"free\") +\n    scale_fill_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) +\n    labs(\n      title = \"Covariate Distribution before matching (2021)\",\n      x = \"Covariate value\",\n      y = \"Density\",\n      fill = \"Group\"\n    ) +\n    theme_minimal()\n\n\n\n\n\n\n\n\n\nLes résultats montrent qu’il y a une différence entre les groupes de traitement et les groupes de contrôle pour chaque covariable avant l’appariement. Trois variables dont treecover_area_2000, elevation, population_count montrent des déséquilibres majeurs, avec un SMD &gt; 0.4. Les deux restants sont juste au-dessus du seuil de 0.25, qui sont eux aussi déséquilibrées.\n\n\n8.8.3.2 Balance test after matching: Q-Q Plot analysis\n\n\nCode\n# Balance after matching\nbal_after_2021 &lt;- bal.tab(matching_result_2021)\nprint(bal_after_2021)\n\n\nBalance Measures\n                         Type Diff.Adj\ntreecover_area_2000   Contin.   0.4042\nslope_2000            Contin.   0.0209\nelevation_2000        Contin.   0.0143\npopulation_count_2000 Contin.  -0.0080\ntraveltime_2000_2000  Contin.   0.0602\n\nSample sizes\n          Control Treated\nAll         10013    3392\nMatched      3392    3392\nUnmatched    6621       0\n\n\nCode\n# Création d'un format long\nmatched_data_2021 &lt;- match.data(matching_result_2021)\n\nqq_2021 &lt;- matched_data_2021 %&gt;% \n  pivot_longer(\n    cols = all_of(matching_variables),\nnames_to = \"variable\",\nvalues_to = \"value\"\n)\n\n# Traçage des QQ plots\nggplot(qq_2021, aes(sample = value, color = GROUP)) +\n  stat_qq(distribution = stats::qunif) + \n  facet_wrap(~variable, scales = \"free\") +\n  labs(\n    title = \"QQ plots after matching (2021)\",\n    x = \"Quantiles of control group\",\n    y = \"Quantiles of treated group\",\n    color = \"Groupe\"\n  ) + \n  scale_color_manual(values = c(\"Control\" = \"green\", \"Treatment\" = \"blue\")) + \n  theme_minimal()\n\n\n\n\n\n\n\n\n\nCode\n# Une autre graphe \nqq_plots_list &lt;- list()\nfor (var in matching_variables) {\n  # Extraire les valeurs pour Control et Treatment\n  control_values &lt;- matched_data_2021 %&gt;% filter(GROUP == \"Control\") %&gt;% pull(!!sym(var))\n  treated_values &lt;- matched_data_2021 %&gt;% filter(GROUP == \"Treatment\") %&gt;% pull(!!sym(var))\n\n  # S'assurer que les deux vecteurs ont la même longueur pour les quantiles\n  # On utilise le nombre d'observations du plus petit groupe pour les quantiles\n  n_min &lt;- min(length(control_values), length(treated_values))\n  \n  # Calcul des quantiles\n  quantiles_control &lt;- quantile(control_values, probs = seq(0, 1, length.out = n_min), na.rm = TRUE)\n  quantiles_treated &lt;- quantile(treated_values, probs = seq(0, 1, length.out = n_min), na.rm = TRUE)\n  \n  # Création d'un data frame pour ce QQ plot\n  qq_data_var &lt;- tibble(\n    control_q = quantiles_control,\n    treated_q = quantiles_treated,\n    variable = var\n  )\n  qq_plots_list[[var]] &lt;- qq_data_var\n}\n\nqq_combined_data &lt;- bind_rows(qq_plots_list)\n\n# Traçage des QQ plots (quantiles de Control sur X, quantiles de Treatment sur Y)\nggplot(qq_combined_data, aes(x = control_q, y = treated_q)) +\n  geom_point(color = \"blue\") + # Points pour la comparaison des quantiles\n  geom_abline(intercept = 0, slope = 1, linetype = \"dashed\", color = \"red\") +\n  facet_wrap(~variable, scales = \"free\") +\n  labs(\n    title = \"QQ plots after matching (2021)\",\n    x = \"Quantiles of control group\",\n    y = \"Quantiles of treated group\"\n  ) +\n  theme_minimal() +\n  NULL\n\n\n\n\n\n\n\n\n\nLes graphiques montrent que les points s’alignent légèrement par rapport à la ligne diagonale pour la plupart des variables. Tandis que pour les quantiles supérieurs de la variable population_count_2000, les points s’écartent clairement de la diagonale. Le groupe de traitement apparié manque toujours d’unités de populations que celles du groupe de contrôle apparié.\nLe matching utilisé aux ménages de l’année 2021 a permi d’atteindre un niveau d’équilibre des covariables très similaire à celui obtenu en 1997, et de même elle fait face aux mêmes défis concernant l’équilibrage de la variable population_count_2000.\n\n\n\n\nAustin, Peter C. 2009. “Balance Diagnostics for Comparing the Distribution of Baseline Covariates Between Treatment Groups in Propensity-Score Matched Samples.” Statistics in Medicine 28 (25): 30833107. https://doi.org/10.1002/sim.3697.\n\n\nDiamond, Alexis, and Jasjeet S. Sekhon. 2013. “Genetic Matching for Estimating Causal Effects: A General Multivariate Matching Method for Achieving Balance in Observational Studies.” Review of Economics and Statistics 95 (3): 932945. https://doi.org/10.1162/REST_a_00318.\n\n\nHo, Daniel E., Kosuke Imai, Gary King, and Elizabeth A. Stuart. 2007. “Matching as Nonparametric Preprocessing for Reducing Model Dependence in Parametric Causal Inference.” Political Analysis 15 (3): 199236. https://doi.org/10.1093/pan/mpl013.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Matching</span>"
    ]
  },
  {
    "objectID": "05-descriptive.html",
    "href": "05-descriptive.html",
    "title": "7  Descriptive statistics",
    "section": "",
    "text": "7.1 Objectif",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Descriptive statistics</span>"
    ]
  },
  {
    "objectID": "05-descriptive.html#statistiques-descriptive-des-aires-protégées",
    "href": "05-descriptive.html#statistiques-descriptive-des-aires-protégées",
    "title": "7  Descriptive statistics",
    "section": "7.2 Statistiques descriptive des aires protégées",
    "text": "7.2 Statistiques descriptive des aires protégées\n\n\nCode\nlibrary(tidyverse) #Manipulation et visualisation des données\nlibrary(writexl) # Pour faire une sortie sous Excel\nlibrary(psych)\nlibrary(knitr)\nlibrary(sf)\n\n# On charge les données\nwdpa_before_2008 &lt;- st_read(\"data/derived/wdpa_before_2008.csv\") \n\n\nReading layer `wdpa_before_2008' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\derived\\wdpa_before_2008.csv' \n  using driver `CSV'\n\n\nCode\nwdpa_from_2008 &lt;- read.csv(\"data/derived/wdpa_from_2008.csv\")\n\n# Fonction utilitaire pour produire les statistiques d'une période\nget_descriptive_stats &lt;- function(data, periode_label) {\n  data &lt;- data %&gt;%\n  mutate(REP_AREA = as.numeric(REP_AREA))\n  \n  stats &lt;- describe(data$REP_AREA)[, c(\"n\", \"mean\", \"sd\", \"median\", \"min\", \"max\")]\n  \n  min_name &lt;- data %&gt;%\n    filter(REP_AREA == min(REP_AREA, na.rm = TRUE)) %&gt;%\n    pull(ORIG_NAME) %&gt;%\n    unique() %&gt;%\n    paste(collapse = \"; \")\n  \n  max_name &lt;- data %&gt;%\n    filter(REP_AREA == max(REP_AREA, na.rm = TRUE)) %&gt;%\n    pull(ORIG_NAME) %&gt;%\n    unique() %&gt;%\n    paste(collapse = \"; \")\n  \n  stats %&gt;%\n    as_tibble() %&gt;%\n    mutate(\n      periode = periode_label,\n      aire_min = min_name,\n      aire_max = max_name\n    )\n}\n\n# Appliquer la fonction aux deux périodes\ndesc_AP_before &lt;- get_descriptive_stats(wdpa_before_2008, \"Before 2008\")\ndesc_AP_from   &lt;- get_descriptive_stats(wdpa_from_2008, \"From 2008\")\n\n\n# Fusion des deux tableaux\ndesc_AP_combined &lt;- rbind(desc_AP_before, desc_AP_from %&gt;%\n  select(periode, n, mean, sd, median, min, aire_min, max, aire_max))\n\n\n# Affichage du tableau \nkable(desc_AP_combined, digits = 2, caption = \"Statistiques descriptives des aires protégées (REP_AREA)\")\n\n\n\nStatistiques descriptives des aires protégées (REP_AREA)\n\n\n\n\n\n\n\n\n\n\n\n\n\nn\nmean\nsd\nmedian\nmin\nmax\nperiode\naire_min\naire_max\n\n\n\n\n34\n3068.49\n13336.03\n253.93\n0.05\n78139.00\nBefore 2008\nParc de Tsarasaotra\nAmbatovaky\n\n\n103\n661.65\n1100.97\n222.88\n0.28\n5688.62\nFrom 2008\nNosy Antsoha\nComplexe des AP Ambohimirahavavy Marivorahona\n\n\n\n\n\nCode\n# Enregistrement du tableau\nwrite_csv(desc_AP_combined, \"data/derived/tableau_descriptive.csv\")\n\n# Fonction pour produire les 10 plus petites aires protégées\nget_top_small_aires &lt;- function(df_input, periode_label, top_n = 10) {\n  df_input %&gt;%\n    mutate(REP_AREA = as.numeric(REP_AREA)) %&gt;%\n    arrange(REP_AREA) %&gt;%\n    slice_head(n = top_n) %&gt;%\n    mutate(\n      rank_number = row_number(),\n      periode = periode_label\n    ) %&gt;% \n    select(rank_number, ORIG_NAME, REP_AREA) \n}\n\n# Appliquer aux deux périodes\ntop10_before_2008 &lt;- get_top_small_aires(wdpa_before_2008, \"Before 2008\")\ntop10_from_2008  &lt;- get_top_small_aires(wdpa_from_2008, \"From 2008\")\n\n# Fusionner les tableaux\ntop10_combined &lt;- bind_rows(top10_before_2008, top10_from_2008)\n\n# Affichage\nkable(top10_combined, digits = 2,\n      caption = \"Statistiques descriptives des aires protégées (REP_AREA) avec top 10 plus petites\")\n\n\n\nStatistiques descriptives des aires protégées (REP_AREA) avec top 10 plus petites\n\n\nrank_number\nORIG_NAME\nREP_AREA\n\n\n\n\n1\nParc de Tsarasaotra\n0.05\n\n\n2\nBetampona\n22.28\n\n\n3\nIvohibe\n34.53\n\n\n4\nBeza Mahafaly\n42.00\n\n\n5\nBora\n48.41\n\n\n6\nManombo\n53.20\n\n\n7\nAmbohitantely\n56.00\n\n\n8\nManingoza\n79.00\n\n\n9\nTorotorofotsy\n97.64\n\n\n10\nBemarivo\n115.70\n\n\n1\nNosy Antsoha\n0.28\n\n\n2\nAndreba\n0.39\n\n\n3\nAmpotaka Ankorabe\n0.97\n\n\n4\nAnkafobe\n1.35\n\n\n5\nNosy Tanihely\n1.80\n\n\n6\nAnalalava\n2.29\n\n\n7\nForêt Naturel de Petriky\n3.00\n\n\n8\nAllées des Baobabs\n3.21\n\n\n9\nMandena\n4.30\n\n\n10\nAnalabe-Betanatanana\n4.35\n\n\n\n\n\nCode\n# Enregistrement du tableau\nwrite_csv(desc_AP_combined, \"data/derived/tableau_descriptive.csv\")",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Descriptive statistics</span>"
    ]
  },
  {
    "objectID": "05-descriptive.html#statistiques-descriptives-du-wealth-index-et-du-z-score-du-wealth-index",
    "href": "05-descriptive.html#statistiques-descriptives-du-wealth-index-et-du-z-score-du-wealth-index",
    "title": "7  Descriptive statistics",
    "section": "7.3 Statistiques descriptives du wealth index et du z-score du wealth index",
    "text": "7.3 Statistiques descriptives du wealth index et du z-score du wealth index\n\n7.3.1 Année 1997\n\n\nCode\n# On charge les données\nhh_1997_rural &lt;- readRDS(\"data/derived/hh_1997_rural_simpler.rds\")\n\n# Sélection des colonnes d'intérêt\nvars &lt;- c(\"wealth_centile_rural_simple\", \"zscore_wealth\")\n\n# Créer le tableau descriptif\ndesc_1997 &lt;- hh_1997_rural %&gt;%\n  summarise(\n    n_centile = sum(!is.na(wealth_centile_rural_simple)),\n    mean_centile = mean(wealth_centile_rural_simple, na.rm = TRUE),\n    sd_centile = sd(wealth_centile_rural_simple, na.rm = TRUE),\n    median_centile = median(wealth_centile_rural_simple, na.rm = TRUE),\n    min_centile = min(wealth_centile_rural_simple, na.rm = TRUE),\n    max_centile = max(wealth_centile_rural_simple, na.rm = TRUE),\n    \n    n_zscore = sum(!is.na(zscore_wealth)),\n    mean_zscore = mean(zscore_wealth, na.rm = TRUE),\n    sd_zscore = sd(zscore_wealth, na.rm = TRUE),\n    median_zscore = median(zscore_wealth, na.rm = TRUE),\n    min_zscore = min(zscore_wealth, na.rm = TRUE),\n    max_zscore = max(zscore_wealth, na.rm = TRUE)\n  ) %&gt;%\n  # Transformer en format long\n  pivot_longer(\n    everything(),\n    names_to = c(\"stat\", \"variable\"),\n    names_sep = \"_\"\n  ) %&gt;%\n  pivot_wider(\n    names_from = stat,\n    values_from = value\n  ) %&gt;%\n  # Renommer les variables\n  mutate(\n    variable = case_when(\n      variable == \"centile\" ~ \"Wealth index en Centile\",\n      variable == \"zscore\" ~ \"Z-score wealth index\",\n      TRUE ~ variable\n    )\n  )\n\n# Affichage du tableau\nkable(desc_1997, digits = 2, caption = \"Statistiques descriptives des variables de richesse rurale (1997)\")\n\n\n\nStatistiques descriptives des variables de richesse rurale (1997)\n\n\nvariable\nn\nmean\nsd\nmedian\nmin\nmax\n\n\n\n\nWealth index en Centile\n5124\n50.32\n28.92\n50.00\n1\n100.00\n\n\nZ-score wealth index\n5124\n0.81\n0.56\n0.74\n0\n4.01\n\n\n\n\n\nCode\n# Export vers Excel\nwrite_xlsx(desc_1997, \"data/derived/descriptive_wealth_rural_1997.xlsx\")\n\n\n\n\n7.3.2 Année 2008\n\n\nCode\n# On charge les données\nhh_2008_rural &lt;- readRDS(\"data/derived/hh_2008_rural_simpler.rds\")\n\n# Créer le tableau descriptif\ndesc_2008 &lt;- hh_2008_rural %&gt;%\n  summarise(\n    n_centile = sum(!is.na(wealth_centile_rural_simple)),\n    mean_centile = mean(wealth_centile_rural_simple, na.rm = TRUE),\n    sd_centile = sd(wealth_centile_rural_simple, na.rm = TRUE),\n    median_centile = median(wealth_centile_rural_simple, na.rm = TRUE),\n    min_centile = min(wealth_centile_rural_simple, na.rm = TRUE),\n    max_centile = max(wealth_centile_rural_simple, na.rm = TRUE),\n    \n    n_zscore = sum(!is.na(zscore_wealth)),\n    mean_zscore = mean(zscore_wealth, na.rm = TRUE),\n    sd_zscore = sd(zscore_wealth, na.rm = TRUE),\n    median_zscore = median(zscore_wealth, na.rm = TRUE),\n    min_zscore = min(zscore_wealth, na.rm = TRUE),\n    max_zscore = max(zscore_wealth, na.rm = TRUE)\n  ) %&gt;%\n  # Transformer en format long\n  pivot_longer(\n    everything(),\n    names_to = c(\"stat\", \"variable\"),\n    names_sep = \"_\"\n  ) %&gt;%\n  pivot_wider(\n    names_from = stat,\n    values_from = value\n  ) %&gt;%\n  # Renommer les variables \n  mutate(\n    variable = case_when(\n      variable == \"centile\" ~ \"Wealth index en Centile\",\n      variable == \"zscore\" ~ \"Z-score wealth index\",\n      TRUE ~ variable\n    )\n  )\n\n# Affichage du tableau\nkable(desc_2008, digits = 2, caption = \"Statistiques descriptives des variables de richesse rurale (2008)\")\n\n\n\nStatistiques descriptives des variables de richesse rurale (2008)\n\n\nvariable\nn\nmean\nsd\nmedian\nmin\nmax\n\n\n\n\nWealth index en Centile\n13364\n50.41\n28.85\n50.00\n1\n100.00\n\n\nZ-score wealth index\n13364\n0.80\n0.57\n0.71\n0\n4.66\n\n\n\n\n\nCode\n# Export vers Excel\nwrite_xlsx(desc_2008, \"data/derived/descriptive_wealth_rural_2008.xlsx\")\n\n\n\n\n7.3.3 Année 2021\n\n\nCode\n# On charge les données\nhh_2021_rural &lt;- readRDS(\"data/derived/hh_2021_rural_simpler.rds\")\n\n# Créer le tableau descriptif\ndesc_2021 &lt;- hh_2021_rural %&gt;%\n  summarise(\n    n_centile = sum(!is.na(wealth_centile_rural_simple)),\n    mean_centile = mean(wealth_centile_rural_simple, na.rm = TRUE),\n    sd_centile = sd(wealth_centile_rural_simple, na.rm = TRUE),\n    median_centile = median(wealth_centile_rural_simple, na.rm = TRUE),\n    min_centile = min(wealth_centile_rural_simple, na.rm = TRUE),\n    max_centile = max(wealth_centile_rural_simple, na.rm = TRUE),\n    \n    n_zscore = sum(!is.na(zscore_wealth)),\n    mean_zscore = mean(zscore_wealth, na.rm = TRUE),\n    sd_zscore = sd(zscore_wealth, na.rm = TRUE),\n    median_zscore = median(zscore_wealth, na.rm = TRUE),\n    min_zscore = min(zscore_wealth, na.rm = TRUE),\n    max_zscore = max(zscore_wealth, na.rm = TRUE)\n  ) %&gt;%\n  # Transformer en format long\n  pivot_longer(\n    everything(),\n    names_to = c(\"stat\", \"variable\"),\n    names_sep = \"_\"\n  ) %&gt;%\n  pivot_wider(\n    names_from = stat,\n    values_from = value\n  ) %&gt;%\n  # Renommer les variables\n  mutate(\n    variable = case_when(\n      variable == \"centile\" ~ \"Wealth index en Centile\",\n      variable == \"zscore\" ~ \"Z-score wealth index\",\n      TRUE ~ variable\n    )\n  )\n\n# Affichage du tableau\nkable(desc_2021, digits = 2, caption = \"Statistiques descriptives des variables de richesse rurale (2021)\")\n\n\n\nStatistiques descriptives des variables de richesse rurale (2021)\n\n\nvariable\nn\nmean\nsd\nmedian\nmin\nmax\n\n\n\n\nWealth index en Centile\n15364\n50.43\n28.85\n50.00\n1\n100.0\n\n\nZ-score wealth index\n15364\n0.80\n0.57\n0.72\n0\n4.4\n\n\n\n\n\nCode\n# Export vers Excel\nwrite_xlsx(desc_2021, \"data/derived/descriptive_wealth_rural_2021.xlsx\")",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Descriptive statistics</span>"
    ]
  },
  {
    "objectID": "05-descriptive.html#statistiques-descriptives-des-variables-utilisées-dans-le-modèle",
    "href": "05-descriptive.html#statistiques-descriptives-des-variables-utilisées-dans-le-modèle",
    "title": "7  Descriptive statistics",
    "section": "7.4 Statistiques descriptives des variables utilisées dans le modèle",
    "text": "7.4 Statistiques descriptives des variables utilisées dans le modèle\n\n\nCode\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(haven)\n\n# Load data \nhr_1997_final &lt;- readRDS(\"data/derived/hr_1997_final.rds\")\n\nhr_2008_final &lt;- readRDS(\"data/derived/hr_2008_final.rds\")\n  \nhr_2021_final &lt;- readRDS(\"data/derived/hr_2021_final.rds\")\n\n# Sélection des colonnes d'intérêt\nvars_ut &lt;- c(\"treecover_area_2000\", \"slope_2000\", \"elevation_2000\", \"population_count_2000\", \"traveltime_2000_2000\", \"spei_wc_1995\", \"spei_wc_1996\", \"spei_wc_1997\", \"spei_wc_2006\", \"spei_wc_2007\", \"spei_wc_2008\",\"spei_wc_2019\", \"spei_wc_2020\", \"spei_wc_2021\" )\n\n# Fonction pour statistiques descriptives robustes\ncalc_descr_stats &lt;- function(df, vars) {\n  vars_exist &lt;- intersect(vars, names(df))       # colonnes existantes\n  df_num &lt;- df %&gt;% select(all_of(vars_exist)) %&gt;% select(where(is.numeric))\n  \n  if (ncol(df_num) == 0) return(NULL)           # si aucune colonne numérique\n  \n  data.frame(\n    Variable = names(df_num),\n    N        = sapply(df_num, function(x) sum(!is.na(x))),\n    Mean     = sapply(df_num, function(x) mean(x, na.rm = TRUE)),\n    SD       = sapply(df_num, function(x) sd(x, na.rm = TRUE)),\n    Min      = sapply(df_num, function(x) min(x, na.rm = TRUE)),\n    Median   = sapply(df_num, function(x) median(x, na.rm = TRUE)),\n    Max      = sapply(df_num, function(x) max(x, na.rm = TRUE))\n  )\n}\n\n# Calculer pour chaque dataframe\ndescr_1997 &lt;- calc_descr_stats(hr_1997_final, vars_ut) %&gt;% mutate(Year = 1997)\ndescr_2008 &lt;- calc_descr_stats(hr_2008_final, vars_ut) %&gt;% mutate(Year = 2008)\ndescr_2021 &lt;- calc_descr_stats(hr_2021_final, vars_ut) %&gt;% mutate(Year = 2021)\n\n# Combiner dans un seul tableau\ndescr_stats_vars &lt;- bind_rows(descr_1997, descr_2008, descr_2021)\n\n# Affichage\ndescr_stats_vars \n\n\n                                        Variable     N          Mean\ntreecover_area_2000...1      treecover_area_2000  5124  1.864042e+04\nslope_2000...2                        slope_2000  5124  8.247142e+00\nelevation_2000...3                elevation_2000  5124  5.588559e+02\npopulation_count_2000...4  population_count_2000  5124  1.061353e+02\ntraveltime_2000_2000...5    traveltime_2000_2000  5124  2.476129e+02\nspei_wc_1995                        spei_wc_1995  5124 -5.549606e-02\nspei_wc_1996                        spei_wc_1996  5124  8.693992e-01\nspei_wc_1997                        spei_wc_1997  5124 -1.914361e-01\ntreecover_area_2000...9      treecover_area_2000 13181  1.673116e+04\nslope_2000...10                       slope_2000 13181  7.942842e+00\nelevation_2000...11               elevation_2000 13181  5.971794e+02\npopulation_count_2000...12 population_count_2000 13181  7.729916e+01\ntraveltime_2000_2000...13   traveltime_2000_2000 13181  2.320937e+02\nspei_wc_2006                        spei_wc_2006 13181  1.815658e-01\nspei_wc_2007                        spei_wc_2007 13181  5.815709e-02\nspei_wc_2008                        spei_wc_2008 13181  1.819427e-01\ntreecover_area_2000...17     treecover_area_2000 15364  1.679105e+04\nslope_2000...18                       slope_2000 15364  8.023112e+00\nelevation_2000...19               elevation_2000 15364  6.023783e+02\npopulation_count_2000...20 population_count_2000 15364  8.868101e+01\ntraveltime_2000_2000...21   traveltime_2000_2000 15364  2.381664e+02\nspei_wc_2019                        spei_wc_2019 15364 -1.856862e-01\nspei_wc_2020                        spei_wc_2020 15364 -8.507443e-02\nspei_wc_2021                        spei_wc_2021 15364 -1.180825e+00\n                                     SD          Min        Median          Max\ntreecover_area_2000...1    1.005805e+04 1342.7713944  1.844703e+04 3.156659e+04\nslope_2000...2             4.498664e+00    1.4451159  8.084897e+00 1.929708e+01\nelevation_2000...3         5.394243e+02    3.0131631  3.147425e+02 1.966773e+03\npopulation_count_2000...4  3.231874e+02    1.7907253  3.309392e+01 2.199750e+03\ntraveltime_2000_2000...5   1.907659e+02   14.1185567  2.048747e+02 1.287918e+03\nspei_wc_1995               4.788649e-01   -1.1852926 -5.526457e-02 1.247613e+00\nspei_wc_1996               6.997820e-01   -0.4456530  1.075215e+00 1.820307e+00\nspei_wc_1997               6.083371e-01   -1.3521902 -1.003526e-01 1.451680e+00\ntreecover_area_2000...9    1.022405e+04  327.7697034  1.568188e+04 3.156618e+04\nslope_2000...10            4.393777e+00    0.9039506  7.590601e+00 2.041394e+01\nelevation_2000...11        5.303743e+02    2.9265126  4.353461e+02 1.835090e+03\npopulation_count_2000...12 2.489257e+02    1.3733021  2.765233e+01 2.650081e+03\ntraveltime_2000_2000...13  1.438855e+02   12.3126615  2.047688e+02 1.311446e+03\nspei_wc_2006               1.572388e-01   -0.2950601  1.948844e-01 5.432084e-01\nspei_wc_2007               4.537234e-01   -2.1977653  1.541938e-01 4.988942e-01\nspei_wc_2008               1.843918e-01   -0.4587450  2.046830e-01 5.013898e-01\ntreecover_area_2000...17   1.014662e+04   84.9716458  1.558359e+04 3.154764e+04\nslope_2000...18            4.433577e+00    0.9947058  7.795004e+00 2.084361e+01\nelevation_2000...19        5.194360e+02    5.6071981  4.601742e+02 2.006922e+03\npopulation_count_2000...20 3.041958e+02    0.4082430  2.415665e+01 2.748209e+03\ntraveltime_2000_2000...21  1.548081e+02   13.8549223  2.121785e+02 1.567831e+03\nspei_wc_2019               2.993217e-01   -1.1856383 -2.378841e-01 6.717159e-01\nspei_wc_2020               3.035246e-01   -0.7862110 -1.135342e-01 7.368029e-01\nspei_wc_2021               4.816858e-01   -1.9114255 -1.257161e+00 4.034658e-02\n                           Year\ntreecover_area_2000...1    1997\nslope_2000...2             1997\nelevation_2000...3         1997\npopulation_count_2000...4  1997\ntraveltime_2000_2000...5   1997\nspei_wc_1995               1997\nspei_wc_1996               1997\nspei_wc_1997               1997\ntreecover_area_2000...9    2008\nslope_2000...10            2008\nelevation_2000...11        2008\npopulation_count_2000...12 2008\ntraveltime_2000_2000...13  2008\nspei_wc_2006               2008\nspei_wc_2007               2008\nspei_wc_2008               2008\ntreecover_area_2000...17   2021\nslope_2000...18            2021\nelevation_2000...19        2021\npopulation_count_2000...20 2021\ntraveltime_2000_2000...21  2021\nspei_wc_2019               2021\nspei_wc_2020               2021\nspei_wc_2021               2021",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Descriptive statistics</span>"
    ]
  },
  {
    "objectID": "05-descriptive.html#statistiques-descriptives-partie-estimation",
    "href": "05-descriptive.html#statistiques-descriptives-partie-estimation",
    "title": "7  Descriptive statistics",
    "section": "7.5 Statistiques descriptives (partie estimation)",
    "text": "7.5 Statistiques descriptives (partie estimation)\n\n\nCode\n# ATTENTION placebo_data_wi n'existe pas : on n'exécute pas ce bloc\n\n# Statistiques descriptives \nevolution_placebo_wi &lt;- placebo_data_wi %&gt;%\n  group_by(DHSYEAR, GROUP) %&gt;%\n  summarise(\n    mean_value = mean(wealth_centile_rural_simple , na.rm = TRUE),\n    sd_value = sd(wealth_centile_rural_simple , na.rm = TRUE),\n    n = n(),\n    se = sd_value / sqrt(n),\n    .groups = \"drop\"\n  )\n\n# Ajout d'un label pour différencier la période pré/ post\nevolution_placebo_wi &lt;- evolution_placebo_wi %&gt;%\n  mutate(period = ifelse(DHSYEAR &lt; 2008, \"Pre-treatment\", \"Post-treatment\"))",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Descriptive statistics</span>"
    ]
  },
  {
    "objectID": "07-estimation_staggered.html",
    "href": "07-estimation_staggered.html",
    "title": "9  Estimation with 2X2 and staggered DiD",
    "section": "",
    "text": "9.1 Objectives\nReminder, we have the following hypothesis:",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estimation with 2X2 and staggered DiD</span>"
    ]
  },
  {
    "objectID": "07-estimation_staggered.html#objectives",
    "href": "07-estimation_staggered.html#objectives",
    "title": "9  Estimation with 2X2 and staggered DiD",
    "section": "",
    "text": "H1-overall effect on livelihoods: PA reduce the living standards of nearby households by restricting access to natural resources, with insufficient compensation or benefits.\nH2-effect on inequalities: PA exacerbate economic inequalities, as better-off or better-connected individuals capture most of the benefits (tourism jobs, development projects).\nH3-heterogeneity: Impacts vary across PA depending on governance, community participation, and management approaches.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estimation with 2X2 and staggered DiD</span>"
    ]
  },
  {
    "objectID": "07-estimation_staggered.html#overall-effect-on-livelihoods",
    "href": "07-estimation_staggered.html#overall-effect-on-livelihoods",
    "title": "9  Estimation with 2X2 and staggered DiD",
    "section": "9.2 Overall effect on livelihoods",
    "text": "9.2 Overall effect on livelihoods\n\n9.2.1 2X2 DiD\nIn our PAP, we stated:\n\n“The difference-in-difference principle is to compare the wealth index of control and treatment households before and after the establishment of PA. Our treatment began in 2011, so we use 2008 DHS data for the pre-treatment and 2021 DHS data for the post-treatment. This method relies on the parallel trends assumption, meaning that, in the absence of treatment, treatment and control groups would have experienced similar changes over time. To verify this assumption, we include two pre-treatment, points (DHS 1997 and DHS 2008 data) and assess trends between these years. […] The difference-in-difference method relies on the assumption of parallel trends. To validate this assumption, we will use as a reference, among the rural households surveyed in 1997, those living in an area located in or within of a PA created between 2008 and 2021 (placebo treatment group) and those matched to them using the method described above (placebo control group). We will graphically represent the evolution of the treatment and control groups in 1997, 2008 and 2021 for visual confirmation. To confirm the validity of the parallel trends assumption, we will conduct a placebo test 1997-2008 outcomes, as well as matching and control variables, while defining the treatment variable for post-2008 PA. If the estimated effect between 1997 and 2008 is null or statistically insignificant, this supports the parallel trends assumption.”\n\n\n\nCode\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(fixest)\nlibrary(didimputation)\nlibrary(broom)\nlibrary(ggplot2)\n\n# Chargement des données\nd97 &lt;- read_rds(\"data/derived/data_matched_1997.rds\") %&gt;%\n  rename(spei_wc_n_2 = spei_wc_1995,\n         spei_wc_n_1 = spei_wc_1996,\n         spei_wc_n   = spei_wc_1997) %&gt;%\n  mutate(hv219 = zap_labels(hv219), # hhh sex (1/2)\n         hv220 = zap_labels(hv220)) # hhh age (num)\n\nd08 &lt;- read_rds(\"data/derived/data_matched_2008.rds\") %&gt;%\n  rename(spei_wc_n_2 = spei_wc_2006,\n         spei_wc_n_1 = spei_wc_2007,\n         spei_wc_n   = spei_wc_2008) %&gt;%\n  mutate(hv219 = zap_labels(hv219),\n         hv220 = zap_labels(hv220))\n\nd11 &lt;- read_rds(\"data/derived/data_matched_2011.rds\") %&gt;%\n  rename(spei_wc_n_2 = spei_wc_2009,\n         spei_wc_n_1 = spei_wc_2010,\n         spei_wc_n   = spei_wc_2011) %&gt;%\n  mutate(hv219 = zap_labels(hv219),\n         hv220 = zap_labels(hv220))\n\nd13 &lt;- read_rds(\"data/derived/data_matched_2013.rds\") %&gt;%\n  rename(spei_wc_n_2 = spei_wc_2011,\n         spei_wc_n_1 = spei_wc_2012,\n         spei_wc_n   = spei_wc_2013) %&gt;%\n  mutate(hv219 = zap_labels(hv219),\n         hv220 = zap_labels(hv220))\n\nd16 &lt;- read_rds(\"data/derived/data_matched_2016.rds\") %&gt;%\n  rename(spei_wc_n_2 = spei_wc_2014,\n         spei_wc_n_1 = spei_wc_2015,\n         spei_wc_n   = spei_wc_2016) %&gt;%\n  mutate(hv219 = zap_labels(hv219),\n         hv220 = zap_labels(hv220))\n\nd18 &lt;- read_rds(\"data/derived/data_matched_2018.rds\") %&gt;%\n  rename(spei_wc_n_2 = spei_wc_2016,\n         spei_wc_n_1 = spei_wc_2017,\n         spei_wc_n   = spei_wc_2018) %&gt;%\n  mutate(hv219 = zap_labels(hv219),\n         hv220 = zap_labels(hv220))\n\nd21 &lt;- read_rds(\"data/derived/data_matched_2021.rds\") %&gt;%\n  rename(spei_wc_n_2 = spei_wc_2019,\n         spei_wc_n_1 = spei_wc_2020,\n         spei_wc_n   = spei_wc_2021) %&gt;%\n  mutate(hv219 = zap_labels(hv219),\n         hv220 = zap_labels(hv220))\n\n# Préparation des données\ndat &lt;- bind_rows(d97, d08, d11, d13, d16, d18, d21) %&gt;%\n  filter(GROUP %in% c(\"Treatment\",\"Control\")) %&gt;%\n  mutate(\n    hv219   = factor(hv219, levels = c(1,2), labels = c(\"Homme\",\"Femme\")), # sexe (cat.)\n    hv220   = as.numeric(hv220),                                           # âge\n    treat   = as.integer(GROUP == \"Treatment\"),\n    w_svy   = hv005 / 1e6,\n    w_all   = w_svy * weights, # poids d'enquête × poids de matching (si 'weights' existe)\n    id      = row_number(),\n    # Map des années de statut -&gt; première année d'observation post (treatment_phase)\n    treatment_phase = case_when(\n      GROUP == \"Control\" ~ 0,\n      STATUS_YR == 2009 ~ 2011,\n      STATUS_YR == 2010 ~ 2011,\n      STATUS_YR == 2012 ~ 2013,\n      STATUS_YR == 2015 ~ 2016,\n      STATUS_YR == 2017 ~ 2018,\n      is.na(STATUS_YR)  ~ 0,\n      TRUE               ~ STATUS_YR\n    )\n  ) %&gt;%\n  mutate(\n    treat_on = as.integer(treatment_phase &gt; 0 & DHSYEAR &gt;= treatment_phase),\n    rel_year = if_else(treatment_phase &gt; 0, DHSYEAR - treatment_phase, Inf),\n    rel_year_binned = case_when(\n      is.infinite(rel_year) ~ Inf,\n      TRUE ~ pmax(pmin(rel_year, 5), -5)\n    )\n  )\n\n# Outcome h\nyvar &lt;- \"wealth_centile_rural_weighted\"\n\n# fixest DID 2×2: placebo 1997–2008, traitement 2008–2021 ------------------\n\n# Placebo 1997–2008\npre &lt;- dat %&gt;%\n  filter(DHSYEAR %in% c(1997, 2008)) %&gt;%\n  mutate(post = as.integer(DHSYEAR == 2008),\n         treat_post = treat * post)\n\nf_pre &lt;- as.formula(paste(\n  yvar, \"~ treat + post + treat_post +\",\n  \"spei_wc_n_2 + spei_wc_n_1 + spei_wc_n + hv219 + hv220\"\n))\n\nm_pre &lt;- feols(f_pre, data = pre, weights = ~ w_all, cluster = ~ hv001)\n\n# Traitement 2008–2021\nmain &lt;- dat %&gt;%\n  filter(DHSYEAR %in% c(2008, 2021)) %&gt;%\n  mutate(post = as.integer(DHSYEAR == 2021),\n         treat_post = treat * post)\n\nf_main &lt;- f_pre  # même formule\n\nm_main &lt;- feols(f_main, data = main, weights = ~ w_all, cluster = ~ hv001)\n\netable(m_pre, m_main, headers = c(\"Placebo 97–08\", \"Traitement 08–21\"))\n\n\n                                        m_pre                        m_main\n                              Placebo 97–08            Traitement 08–21\nDependent Var.: wealth_centile_rural_weighted wealth_centile_rural_weighted\n                                                                           \nConstant                     44.81*** (4.192)              40.35*** (2.955)\ntreat                          -2.834 (4.228)                -1.786 (3.683)\npost                           -3.892 (5.948)              23.45*** (4.422)\ntreat_post                      1.403 (5.613)                -1.724 (4.359)\nspei_wc_n_2                     5.927 (4.004)                -3.202 (3.279)\nspei_wc_n_1                   -0.5034 (2.525)             -8.250*** (2.098)\nspei_wc_n                       1.435 (4.225)              18.36*** (2.370)\nhv219Femme                    -0.5760 (1.040)            -2.853*** (0.7892)\nhv220                      0.1065*** (0.0258)            0.1042*** (0.0186)\n_______________ _____________________________ _____________________________\nS.E.: Clustered                     by: hv001                     by: hv001\nObservations                            6,831                        11,686\nR2                                    0.00806                       0.07923\nAdj. R2                               0.00690                       0.07860\n---\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nCode\n# Extraction compacte des deux effets DID\ndid_row &lt;- function(model, year_post, vc = ~ hv001, term = \"treat_post\"){\n  summary(model, vcov = vc) %&gt;% broom::tidy() %&gt;%\n    filter(term == !!term) %&gt;%\n    transmute(year = year_post, estimate, se = std.error)\n}\ndid_df &lt;- bind_rows(\n  did_row(m_pre, 2008),\n  did_row(m_main, 2021)\n) %&gt;%\n  mutate(period = factor(ifelse(year == 2008, \"1997–2008\", \"2008–2021\"),\n                         levels = c(\"1997–2008\", \"2008–2021\")),\n         lo = estimate - 1.96*se,\n         hi = estimate + 1.96*se)\n\nggplot(did_df, aes(x = period, y = estimate)) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  geom_errorbar(aes(ymin = lo, ymax = hi), width = .2) +\n  geom_point(size = 3) +\n  labs(x = NULL, y = \"Effet DID sur le centile de richesse (pondéré)\",\n       title = \"DID 2×2 avec IC clusterisés (hv001)\")\n\n\n\n\n\n\n\n\n\nLe test placebo donne une estimation avec un coefficient faible (+1.8 centile) et non significatif: pas de différence détectée avant intervention dans les tendances du groupe traitement et du groupe contrôle. L’estimation du traitement préente une plus grande magnitude (-4.1 centiles), mais il reste non significatif. Les ménages vivant près des AP semblent connaître, un niveau de bien-être légèrement inférieur à celui des ménages contrôle, mais l’effet n’est pas significatif. A ce stade, l’analyse ne confirme pas l’hypothèse 1 (que les AP réduice le niveau de vie) : le sens de la relation est négatif, mais on ne peut pas rejeter l’hypothèse nulle. L’intervalle de confiance couvre encore largement 0, ce qui signifie qu’on a une précision insuffisante pour détecter un effet. L’effet est donc soit nul, soit inférieur à notre capacité de détection. Dans le PAP, on avait estimé que l’effet devrait être d’au moins 7.5 centiles pour pouvoir être détecté.\n\n\n9.2.2 Staggered diff-in-diff\nIn our PAP, we stated:\n\n“The MIS data can therefore be mobilized for this study. However, the periods covered by MIS only allow for comparisons beyond a simple “before” and “after” framework, which complicates the analysis and necessitates methods with limited methodological consensus. Since 2020, the state of the art in difference-in-difference methods has been challenged by the recognition that classical two-way fixed effects methods can yield spurious results when the effects of an intervention are heterogeneous and assessed over multiple periods. Since then, a dozen alternative approaches have been developed, but econometricians continue to debate their reliability (Roth et al. 2023). To avoid undermining the credibility of our results, we will initially limit ourselves to two study periods (DHS 2008 and 2021). Only if this approach lacks sufficient statistical power will we consider incorporating additional data. […] Additionally, if we incorporate data from MIS 1997, MIS 2011, and MIS 2013, we could apply an estimator suitable for staggered adoption and multiple study periods accounting for potential heterogeneous treatment effects (Borusyak, Jaravel, and Spiess 2024). This will only be performed if power is insufficient with two periods of data.”\n\nPour l’instant, je n’arrive pas à appliquer l’approche de Borusyak, Jaravel et Spiess avec des données en coupes répétées (pas du panel) avec le package R didimputation. En théorie cette méthode peut s’appliquer à des données “repeated cross sections” et il semblerait qu’un package STATA le fasse. Mais je n’ai pas STATA pour tester. On va donc appliquer la méthode de Gardner, qui en principe est très proche (avec des intervalles de confiance un peu plus large).\nNota bene : Afin de stabiliser les estimations de l’event-study, nous avons appliqué un binning des années relatives au traitement, regroupant toutes les observations au-delà de ±5 années dans des catégories communes. Ce choix est motivé par l’espacement irrégulier des enquêtes disponibles, qui implique que certaines valeurs de temps relatif sont représentées par très peu d’observations et produisent des coefficients instables. Comme le soulignent Borusyak, Jaravel et Spiess (2024, p. 22) : “In practice, it is common to bin distant leads and lags into a single category, both to improve statistical precision and to avoid presenting very noisy and uninformative coefficients.” Cette approche permet ainsi de réduire le bruit aux extrêmes et de se concentrer sur l’interprétation des dynamiques principales autour du traitement.\n\n\nCode\n# did2s (Gardner) : statique + event-study--------------------------------\nlibrary(did2s)\n\n# -- Statique (traitement \"on/off\")\ndid2s_static &lt;- did2s(\n  data        = dat,\n  yname       = yvar,\n  first_stage = ~ spei_wc_n_2 + spei_wc_n_1 + spei_wc_n + hv219 + hv220 | DHSYEAR,\n  second_stage= ~ i(treat_on, ref = FALSE),\n  treatment   = \"treat_on\",\n  cluster_var = \"hv001\",\n  weights     = \"w_all\"\n)\netable(did2s_static, headers = \"did2s statique\")\n\n\n                                 did2s_static\n                               did2s statique\nDependent Var.: wealth_centile_rural_weighted\n                                             \ntreat_on = 1                    2.676 (2.080)\n_______________ _____________________________\nS.E.: Clustered                     by: hv001\nObservations                           22,501\nR2                                    0.00176\nAdj. R2                               0.00176\n---\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nCode\n# -- Event-study (avec binning -5..5, ref = -1 et never-treated)\ndid2s_es &lt;- did2s(\n  data        = dat,\n  yname       = yvar,\n  first_stage = ~ spei_wc_n_2 + spei_wc_n_1 + spei_wc_n + hv219 + hv220 | DHSYEAR,\n  second_stage= ~ i(rel_year_binned, ref = c(-1, Inf)),\n  treatment   = \"treat_on\",\n  cluster_var = \"hv001\",\n  weights     = \"w_all\"\n)\netable(did2s_es, headers = \"did2s event-study (-5..5)\")\n\n\n                                          did2s_es\n                         did2s event-study (-5..5)\nDependent Var.:      wealth_centile_rural_weighted\n                                                  \nrel_year_binned = -5               -0.2003 (1.419)\nrel_year_binned = -3                -2.887 (2.167)\nrel_year_binned = -2               -5.325. (2.915)\nrel_year_binned = 0                 6.808. (3.592)\nrel_year_binned = 2                  2.255 (3.902)\nrel_year_binned = 3                 9.081. (4.780)\nrel_year_binned = 5                 0.2325 (2.816)\n____________________ _____________________________\nS.E.: Clustered                          by: hv001\nObservations                                22,501\nR2                                         0.00608\nAdj. R2                                    0.00581\n---\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nCode\n# Plot ES did2s\nplot_did2s &lt;- broom::tidy(did2s_es, conf.int = TRUE) %&gt;%\n  filter(grepl(\"^rel_year_binned::\", term)) %&gt;%\n  mutate(k = as.numeric(sub(\"^rel_year_binned::\", \"\", term))) %&gt;%\n  arrange(k)\n\nggplot(plot_did2s, aes(k, estimate)) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  geom_point() +\n  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = .2) +\n  labs(x = \"Années relatives au 1er traitement (binnées -5..5)\",\n       y = \"Effet estimé\",\n       title = \"Event-study (did2s)\")\n\n\n\n\n\n\n\n\n\nCode\n# Test joint de pré-tendances (tous les leads k &lt; 0)\n# On construit un motif regex pour k = -5..-1 présents dans le modèle\nleads_present &lt;- plot_did2s$k[plot_did2s$k &lt; 0]\nif(length(leads_present) &gt; 0){\n  keep_regex &lt;- paste0(\"^rel_year_binned::(\", paste(leads_present, collapse=\"|\"), \")$\")\n  print(fixest::wald(did2s_es, keep = keep_regex))\n}\n\n\nWald test, H0: joint nullity of rel_year_binned::-5, rel_year_binned::-3 and rel_year_binned::-2\n stat = 1.75604, p-value = 0.153216, on 3 and 22,494 DoF, VCOV: Corrected Clustered (hv001).$stat\n[1] 1.756044\n\n$p\n[1] 0.1532165\n\n$df1\n[1] 3\n\n$df2\n[1] 22494\n\n$vcov\n[1] \"Corrected Clustered (hv001)\"\n\n\nL’estimation en “statique” donne un coefficient de ~1 centile (0.99), avec une erreur type de 2.1, ce qui indique un résultat non significatif. L’analyse en série temporelle avec binning ±5 ans. Etaye l’hypothèse de tendances parallèle. Les estimations en post semblent apparaître, mais ne semblent pas persister. Cela abonde dans le sens d’un impact faible et non-significatif. De possibles avancées à court-terme (~3 ans après la création de l’AP), mais pas soutenues dans le temps.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estimation with 2X2 and staggered DiD</span>"
    ]
  },
  {
    "objectID": "07-estimation_staggered.html#effect-on-inequalities",
    "href": "07-estimation_staggered.html#effect-on-inequalities",
    "title": "9  Estimation with 2X2 and staggered DiD",
    "section": "9.3 Effect on inequalities",
    "text": "9.3 Effect on inequalities\n\n9.3.1 Staggered DiD\n\n\nCode\nyvar &lt;- \"zscore_wealth\"\n\n# did2s (Gardner) : statique + event-study--------------------------------\n# -- Statique (traitement \"on/off\")\ndid2s_static &lt;- did2s(\n  data        = dat,\n  yname       = yvar,\n  first_stage = ~ spei_wc_n_2 + spei_wc_n_1 + spei_wc_n + hv219 + hv220 | DHSYEAR,\n  second_stage= ~ i(treat_on, ref = FALSE),\n  treatment   = \"treat_on\",\n  cluster_var = \"hv001\",\n  weights     = \"w_all\"\n)\netable(did2s_static, headers = \"did2s statique\")\n\n\n                   did2s_static\n                 did2s statique\nDependent Var.:   zscore_wealth\n                               \ntreat_on = 1    0.0009 (0.0062)\n_______________ _______________\nS.E.: Clustered       by: hv001\nObservations             22,501\nR2                      -4.4e-5\nAdj. R2                 -4.4e-5\n---\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nCode\n# -- Event-study (avec binning -5..5, ref = -1 et never-treated)\ndid2s_es &lt;- did2s(\n  data        = dat,\n  yname       = yvar,\n  first_stage = ~ spei_wc_n_2 + spei_wc_n_1 + spei_wc_n + hv219 + hv220 | DHSYEAR,\n  second_stage= ~ i(rel_year_binned, ref = c(-1, Inf)),\n  treatment   = \"treat_on\",\n  cluster_var = \"hv001\",\n  weights     = \"w_all\"\n)\netable(did2s_es, headers = \"did2s event-study (-5..5)\")\n\n\n                                      did2s_es\n                     did2s event-study (-5..5)\nDependent Var.:                  zscore_wealth\n                                              \nrel_year_binned = -5          0.0086* (0.0039)\nrel_year_binned = -3           0.0009 (0.0060)\nrel_year_binned = -2           0.0271 (0.0174)\nrel_year_binned = 0           -0.0009 (0.0117)\nrel_year_binned = 2            0.0016 (0.0333)\nrel_year_binned = 3           0.0284* (0.0142)\nrel_year_binned = 5            0.0004 (0.0069)\n____________________          ________________\nS.E.: Clustered                      by: hv001\nObservations                            22,501\nR2                                     2.68e-5\nAdj. R2                               -0.00024\n---\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nCode\n# Plot ES did2s\nplot_did2s &lt;- broom::tidy(did2s_es, conf.int = TRUE) %&gt;%\n  filter(grepl(\"^rel_year_binned::\", term)) %&gt;%\n  mutate(k = as.numeric(sub(\"^rel_year_binned::\", \"\", term))) %&gt;%\n  arrange(k)\n\nggplot(plot_did2s, aes(k, estimate)) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  geom_point() +\n  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = .2) +\n  labs(x = \"Années relatives au 1er traitement (binnées -5..5)\",\n       y = \"Effet estimé\",\n       title = \"Event-study (did2s)\")\n\n\n\n\n\n\n\n\n\nCode\n# Test joint de pré-tendances (tous les leads k &lt; 0)\n# On construit un motif regex pour k = -5..-1 présents dans le modèle\nleads_present &lt;- plot_did2s$k[plot_did2s$k &lt; 0]\nif(length(leads_present) &gt; 0){\n  keep_regex &lt;- paste0(\"^rel_year_binned::(\", paste(leads_present, collapse=\"|\"), \")$\")\n  print(fixest::wald(did2s_es, keep = keep_regex))\n}\n\n\nWald test, H0: joint nullity of rel_year_binned::-5, rel_year_binned::-3 and rel_year_binned::-2\n stat = 2.50965, p-value = 0.056847, on 3 and 22,494 DoF, VCOV: Corrected Clustered (hv001).$stat\n[1] 2.509653\n\n$p\n[1] 0.05684675\n\n$df1\n[1] 3\n\n$df2\n[1] 22494\n\n$vcov\n[1] \"Corrected Clustered (hv001)\"\n\n\nRien de très significatif non plus.\n\n\n9.3.2 Quantile treatment effects\n\n\nCode\n# Testing Quantile treatment effects --------------------------------------\nlibrary(qte)\n\n# Avec CiC -------------------\n\n## Traitement 2008 -&gt; 2021\nset.seed(123)\ndat_2per &lt;- dat %&gt;%\n  filter(DHSYEAR %in% c(2008, 2021)) %&gt;%\n  mutate(treat = as.integer(GROUP == \"Treatment\"))\n\ncic_res &lt;- suppressWarnings(CiC(\n  formla = wealth_centile_rural_weighted ~ treat,\n  t = 2021, tmin1 = 2008, tname = \"DHSYEAR\",\n  data = dat_2per,\n  panel = FALSE, # repeated cross-sections\n  se = TRUE, iters = 200, # bootstrap\n  probs = seq(0.05, 0.95, 0.05),\n  xformla = ~ spei_wc_n_2 + spei_wc_n_1 + spei_wc_n + hv219 + hv220\n))\n\nsummary(cic_res)\n\n\n\nQuantile Treatment Effect:\n        \ntau QTE Std. Error\n0.05     -4.58    2.38\n0.1 -10.81    2.72\n0.15    -17.66    3.18\n0.2 -18.95    2.58\n0.25    -20.74    2.30\n0.3 -22.05    2.44\n0.35    -24.68    2.53\n0.4 -25.64    2.54\n0.45    -28.51    2.47\n0.5 -27.95    2.19\n0.55    -28.25    2.12\n0.6 -26.98    1.85\n0.65    -26.00    1.72\n0.7 -23.59    1.65\n0.75    -20.73    1.69\n0.8 -17.73    1.70\n0.85    -15.45    1.68\n0.9 -12.27    1.59\n0.95     -9.65    1.53\n\nAverage Treatment Effect:   -19.51\n     Std. Error:        1.51\n\n\nCode\nggqte(cic_res) + labs(x=\"Quantiles\", y=\"QTET\", title=\"CiC QTET: 2008-2021\")\n\n\n\n\n\n\n\n\n\nCode\n## placebo\n\n## Placebo: 1997 -&gt; 2008\ndat_placebo &lt;- dat %&gt;%\n  filter(DHSYEAR %in% c(1997, 2008)) %&gt;%\n  mutate(treat = as.integer(GROUP == \"Treatment\"))\n\n# (Optional) sanity check:\n# with(dat_placebo, table(DHSYEAR, treat))\n\ncic_pre &lt;-  suppressWarnings(CiC(\n  formla = wealth_centile_rural_simple ~ treat,\n  t = 2008, tmin1 = 1997, tname = \"DHSYEAR\",\n  data = dat_placebo,\n  panel = FALSE, # repeated cross-sections\n  se = TRUE, iters = 100, # bootstrap\n  probs = seq(0.05, 0.95, 0.05),\n  xformla = ~ spei_wc_n_2 + spei_wc_n_1 + spei_wc_n + hv219 + hv220\n))\n\nsummary(cic_pre)\n\n\n\nQuantile Treatment Effect:\n        \ntau QTE Std. Error\n0.05     17.022   3.911\n0.1  15.121   2.447\n0.15     16.945   2.628\n0.2  19.346   3.356\n0.25     18.850   4.139\n0.3  16.292   4.674\n0.35     15.528   4.690\n0.4  13.770   4.456\n0.45     13.616   4.332\n0.5  11.568   4.732\n0.55     10.253   5.283\n0.6   5.472   5.188\n0.65      4.016   5.084\n0.7  -0.087   5.075\n0.75     -5.272   5.334\n0.8  -7.921   6.155\n0.85    -10.318   5.675\n0.9 -11.809   4.909\n0.95    -16.652   8.555\n\nAverage Treatment Effect:   5.91\n     Std. Error:        3.50\n\n\nCode\nggqte(cic_pre) +\n  labs(x = \"Quantiles\", y = \"QTET\",\n       title = \"Placebo CiC QTET: 1997-2008\")\n\n\n\n\n\n\n\n\n\nPour l’estimation principale (2008-2021), l’ATE est fortement négatif et très significatif (-17.9 centiles!). Les effets négatifs se retrouvent sur l’ensemble de la distribution, mais sont particulièrement marqués pour les centiles les plus faibles. Cela conforterait fortement l’hypothèse 2 (les AP renforcent les inégalités), mais c’est surprenant que ce soit à ce point marqué sur l’ensemble de la distribution alors que le DiD sur le wealth centile n’était pas significatif (Hypothèse 1).\nPour le test placebo, la courbe n’est pas exactement plate : différence significative sur les bas revenus (supérieurs chez les traitements) et inférieure sur les bas revenus.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estimation with 2X2 and staggered DiD</span>"
    ]
  },
  {
    "objectID": "09-puissance-test.html",
    "href": "09-puissance-test.html",
    "title": "11  Introduction",
    "section": "",
    "text": "11.1 Chargement des données\nCode\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(lme4)\nlibrary(pwr)\nlibrary(fixest)\n\n# Cluster classification\ncluster_treatment_classification &lt;- read.csv(\"data/derived/cluster_treatment_classification_staggered.csv\")\n\nhr_1997_final &lt;- readRDS(\"data/derived/hr_1997_final.rds\")\nhr_2008_final &lt;- readRDS(\"data/derived/hr_2008_final.rds\")\nhr_2021_final &lt;- readRDS(\"data/derived/hr_2021_final.rds\")",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "09-puissance-test.html#calcul-de-la-puissance-statistique-pour-les-ménages-ruraux",
    "href": "09-puissance-test.html#calcul-de-la-puissance-statistique-pour-les-ménages-ruraux",
    "title": "11  Introduction",
    "section": "11.2 Calcul de la puissance statistique pour les ménages ruraux",
    "text": "11.2 Calcul de la puissance statistique pour les ménages ruraux\n\n\nCode\n# Extraire les clusters traités en 2021\ntreatment_clusters_2021 &lt;- cluster_treatment_classification %&gt;%\n  filter(GROUP == \"Treatment\", DHSYEAR == 2021) %&gt;%\n  pull(DHSCLUST)\n\n\n# Filtrer hr_2021_final pour tenir compte que les observations traitées \nhousehold_treatment_2021 &lt;- hr_2021_final %&gt;%\n  filter(hv001 %in% treatment_clusters_2021)\n\n# Function to compute power calculations\ncompute_power_stats &lt;- function(data, outcome_var) {\n  # Calculate standard deviation for the specified outcome variable\n  sd_outcome_treatment &lt;- sd(data[[outcome_var]], na.rm=TRUE)\n  \n  # Calculate intra-cluster correlation using a mixed-effects model\n  icc_model &lt;- lmer(as.formula(paste(outcome_var, \"~ 1 + (1 | hv001)\")), \n                    data=data, REML=TRUE)\n  \n  # Extract variance components\n  variance_components &lt;- as.data.frame(VarCorr(icc_model)) %&gt;%\n    select(grp, vcov)\n  \n  between_cluster_variance &lt;- variance_components %&gt;%\n    filter(grp == \"hv001\") %&gt;%\n    pull(vcov)\n  \n  within_cluster_variance &lt;- variance_components %&gt;%\n    filter(grp == \"Residual\") %&gt;%\n    pull(vcov)\n  \n  # Calculate ICC\n  icc_value &lt;- between_cluster_variance / \n    (between_cluster_variance + within_cluster_variance)\n  \n  # Parameters for 2021\n  alpha &lt;- 0.05          # Significance level\n  power &lt;- 0.8           # Desired power\n  rho &lt;- icc_value       # Intra-cluster correlation\n  \n  # Sample Sizes\n  treated_2021 &lt;- nrow(data)\n  control_2021 &lt;- nrow(data)\n  clusters_treated_2021 &lt;- length(unique(data$hv001))\n  clusters_control_2021 &lt;- clusters_treated_2021\n  \n  # Design effect calculation\n  design_effect_2021_treated &lt;- \n    1 + (treated_2021 / clusters_treated_2021 - 1) * rho\n  design_effect_2021_control &lt;- \n    1 + (control_2021 / clusters_control_2021 - 1) * rho\n  \n  # Effective sample sizes\n  effective_n_2021_treated &lt;- treated_2021 / design_effect_2021_treated\n  effective_n_2021_control &lt;- control_2021 / design_effect_2021_control\n  \n  # Calculate the minimum detectable effect size\n  result &lt;- pwr.t2n.test(\n    n1=effective_n_2021_treated,\n    n2=effective_n_2021_control,\n    sig.level=alpha,\n    power=power\n  )\n  cohens_d &lt;- result$d \n  \n  # Convert Cohen's d to outcome units\n  mde_in_units &lt;- cohens_d * sd_outcome_treatment\n  \n    # Create a table with the results\n  results_table &lt;- tibble(\n    Métrique=c(\"ICC\", \"Écart type ajusté\", \"d de Cohen\", \n               \"MDE en unité de la variable de résultat\"),\n    Valeur=c(icc_value, sd_outcome_treatment, cohens_d, mde_in_units)\n  )\n  \n  # Display the results using gt\n  gt(results_table) %&gt;%\n    fmt_number(columns=\"Valeur\",\n               decimals=4) %&gt;%\n    cols_label(Métrique=\"Métrique\",\n               Valeur=\"Valeur\") %&gt;%\n    cols_align(align=\"center\",\n               columns=everything())\n}\n\n# Calculate for all treatment households using hv270 \ncompute_power_stats(hr_2021_final, \"wealth_centile_rural_simple\") %&gt;%\n  tab_header(\"Puissance statistique pour une analyse incluant ménages urbains \n             et ruraux\") %&gt;%\n  tab_footnote(\"Variable de résultat = wealth_centile_rural_simple, indice de niveau de vie commun \n               aux milieux urbains et ruraux.\")\n\n\n\n\n\n\n\n\nPuissance statistique pour une analyse incluant ménages urbains et ruraux\n\n\nMétrique\nValeur\n\n\n\n\nICC\n0.5360\n\n\nÉcart type ajusté\n28.8548\n\n\nd de Cohen\n0.1334\n\n\nMDE en unité de la variable de résultat\n3.8504\n\n\n\nVariable de résultat = wealth_centile_rural_simple, indice de niveau de vie commun aux milieux urbains et ruraux.",
    "crumbs": [
      "Data analysis",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "11-references.html",
    "href": "11-references.html",
    "title": "References",
    "section": "",
    "text": "Austin, Peter C. 2009. “Balance Diagnostics for Comparing the\nDistribution of Baseline Covariates Between Treatment Groups in\nPropensity-Score Matched Samples.” Statistics in\nMedicine 28 (25): 30833107. https://doi.org/10.1002/sim.3697.\n\n\nDiamond, Alexis, and Jasjeet S. Sekhon. 2013. “Genetic Matching\nfor Estimating Causal Effects: A General Multivariate Matching Method\nfor Achieving Balance in Observational Studies.” Review of\nEconomics and Statistics 95 (3): 932945. https://doi.org/10.1162/REST_a_00318.\n\n\nDroogers, Peter, and Richard G. Allen. 2002. “Estimating Reference\nEvapotranspiration Under Inaccurate Data Conditions.”\nIrrigation and Drainage Systems 16 (1): 3345. https://doi.org/10.1023/A:1015508322413.\n\n\nGoodman, Steven M., Marie Jeanne Raherilalao, Sébastien Wohlhauser, Jean\nClarck N. Rabenandrasana, Herivololona M. Rakotondratsimba, Fanja\nAndriamialisoa, and Malalarisoa Razafimpahanana. 2018. Les Aires\nProtégées Terrestres de Madagascar: Leur Histoire, Description Et\nBiote. Association Vahatra. https://zoboko.com/publisher/association-vahatra-in-antananarivo.\n\n\nGörgen, Darius A., and Om Prakash Bhandari. 2022. “Efficient\nMonitoring of Global Biodiversity Portfolios,” April. https://doi.org/10.32614/CRAN.package.mapme.biodiversity.\n\n\n———. 2024. “Mapme.biodiversity: Efficient Monitoring of Global\nBiodiversity Portfolios.” https://CRAN.R-project.org/package=mapme.biodiversity.\n\n\nHansen, Matthew C., Peter V. Potapov, Rebecca Moore, Matt Hancher, S. A.\nTurubanova, Alexandra Tyukavina, David Thau, et al. 2013.\n“High-Resolution Global Maps of 21st-Century Forest Cover\nChange.” Science 342 (6160): 850853. http://www.sciencemag.org/content/342/6160/850.short.\n\n\nHo, Daniel E., Kosuke Imai, Gary King, and Elizabeth A. Stuart. 2007.\n“Matching as Nonparametric Preprocessing for Reducing Model\nDependence in Parametric Causal Inference.” Political\nAnalysis 15 (3): 199236. https://doi.org/10.1093/pan/mpl013.\n\n\nNASA JPL. 2020. “NASADEM Merged DEM Global 1 Arc Second\nV001.” https://doi.org/10.5067/MEASURES/NASADEM/NASADEM_HGT.001.\n\n\nUchida, Hirotsugu, and Andrew Nelson. 2011. “Agglomeration Index:\nTowards a New Measure of Urban Concentration.” Urbanization\nand Development: Multidisciplinary Perspectives, January. https://doi.org/10.1093/acprof:oso/9780199590148.003.0003.\n\n\nVicente-Serrano, Sergio M., Santiago Beguería, and Juan I. López-Moreno.\n2010. “A Multiscalar Drought Index Sensitive to Global Warming:\nThe Standardized Precipitation Evapotranspiration Index.”\nJournal of Climate 23 (7): 16961718. https://doi.org/10.1175/2009JCLI2909.1.\n\n\nWorldPop, and CIESIN. 2018. “Global 1km Population.” https://doi.org/10.5258/SOTON/WP00647.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html",
    "href": "01-treatment-assignation.html",
    "title": "2  Treatment assignation",
    "section": "",
    "text": "2.1 Objectifs\nNous classons les clusters d’enquêtes DHS (1997, 2008 et 2021) par rapport à leur distance aux aires protégées et à leur localisation en zone rurale ou urbaine. Le résultat attendu est le suivant :",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#objectifs",
    "href": "01-treatment-assignation.html#objectifs",
    "title": "2  Treatment assignation",
    "section": "",
    "text": "Groupe de traitement: Ménages localisées dans les clusters à moins de 10 km des aires protégées créées à partir de 2008 dans les zones rurales\nGroupe de contrôle: Ménages localisées dans les clusters à plus de 10 km des aires protégées dans les zones rurales\nGroupe à exclure: Ménages localisées dans les clusters à moins de 10 km des aire protégées créées avant 2008 et dans la zone urbaine",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#chargement-des-coordonnées-gps-des-clusters-denquête",
    "href": "01-treatment-assignation.html#chargement-des-coordonnées-gps-des-clusters-denquête",
    "title": "2  Treatment assignation",
    "section": "2.2 Chargement des coordonnées GPS des clusters d’enquête",
    "text": "2.2 Chargement des coordonnées GPS des clusters d’enquête\nAvant de charger les données GPS de 1997, 2008, 2021, nous précisons les coordonnées GPS utilisées. Les coordonnées GPS, comme la plupart des données ouvertes distribuées sur Internet, sont en WGS 84 (codé EPSG : 4326). Nos données sont aussi traitées en 4326. Toutefois, uniquement pour le calcul des surfaces ou des distances, on va utiliser le système de projection officiel de Madagascar, qui est le Laborde (EPSG : 29702). Une fois les données chargées, on fusionne les trois jeux de données en un seul puis visualisés sur une carte.\n\n\nCode\nlibrary(tidyverse) #Manipulation et visualisation des données\nlibrary(haven)\nlibrary(sf) #Analyse des données spatiales\nlibrary(tmap) #Analyse cartographique\nlibrary(gt) #Mise en forme des tableaux \nlibrary(geodata) # Pour avoir le contour de Madagascar\nlibrary(writexl) # Pour faire une sortie sous Excel\nlibrary(units)\nlibrary(leaflet) # Pour faire une cartographie interactive\nlibrary(readxl)\n\n# Systèmes de coordonnées de référence \nstandard_crs &lt;- 4326\nmdg_crs &lt;- 29702 \n\n# Load boundary\ncontour_mada &lt;- gadm(country = \"Madagascar\", level = 0, path = \"data\") %&gt;%\n  st_as_sf() %&gt;%\n  st_set_crs(standard_crs)\n\n# On charge les données\ngps_1997_initial &lt;- st_read(\"data/raw/dhs/DHS_1997/MDGE32FL/MDGE32FL.shp\")\n\n\nReading layer `MDGE32FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_1997\\MDGE32FL\\MDGE32FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 269 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 6.661338e-16 ymin: -25.28438 xmax: 50.45773 ymax: 0\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2008_initial &lt;- st_read(\"data/raw/dhs/DHS_2008/MDGE53FL/MDGE53FL.shp\") \n\n\nReading layer `MDGE53FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_2008\\MDGE53FL\\MDGE53FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 594 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0 ymin: -25.52226 xmax: 50.29224 ymax: 0\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2011_initial &lt;- st_read(\"data/raw/dhs/DHS_2011/MDGE61FL/MDGE61FL.shp\") \n\n\nReading layer `MDGE61FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_2011\\MDGE61FL\\MDGE61FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 267 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0 ymin: -25.55782 xmax: 50.27262 ymax: 0\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2013_initial &lt;- st_read(\"data/raw/dhs/DHS_2013/MDGE6AFL/MDGE6AFL.shp\") \n\n\nReading layer `MDGE6AFL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_2013\\MDGE6AFL\\MDGE6AFL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 274 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 43.55216 ymin: -25.55638 xmax: 50.26784 ymax: -12.13444\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2016_initial &lt;- st_read(\"data/raw/dhs/DHS_2016/MDGE71FL/MDGE71FL.shp\")\n\n\nReading layer `MDGE71FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_2016\\MDGE71FL\\MDGE71FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 358 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 43.64903 ymin: -25.47617 xmax: 50.31325 ymax: -12.27554\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2021_initial &lt;- st_read(\"data/raw/dhs/DHS_2021/MDGE81FL/MDGE81FL.shp\")\n\n\nReading layer `MDGE81FL' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\dhs\\DHS_2021\\MDGE81FL\\MDGE81FL.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 650 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 43.3746 ymin: -25.5548 xmax: 50.36067 ymax: -11.99102\nGeodetic CRS:  WGS 84\n\n\nCode\ngps_2018_initial &lt;- st_read(\"data/raw/mics/2018/GPS Datasets/MadagascarMICS2018GPS.shp\")  %&gt;%\n  select(DHSYEAR = SVYYEARS,\n         DHSCLUST = HH1,\n         URBAN_RURA = HH6,\n         LATNUM = LATITUDE,\n         LONGNUM = LONGITUDE) %&gt;%\n  mutate(URBAN_RURA = case_when(\n    URBAN_RURA == \"Urban\" ~ \"U\",\n    URBAN_RURA == \"Rural\" ~ \"R\",\n    .default = NA_character_\n  ))\n\n\nReading layer `MadagascarMICS2018GPS' from data source \n  `C:\\Users\\fbede\\Documents\\Statistiques\\PA-livelihood-impact-dhs_v2\\data\\raw\\mics\\2018\\GPS Datasets\\MadagascarMICS2018GPS.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 18 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 43.36162 ymin: -25.52768 xmax: 50.27895 ymax: -12.28119\nGeodetic CRS:  WGS 84\n\n\nCode\ntmap_mode(\"plot\")\nclusters_dhs &lt;- bind_rows(gps_1997_initial, gps_2008_initial, gps_2011_initial,\n          gps_2013_initial,  gps_2016_initial, gps_2018_initial, gps_2021_initial)\n  tm_shape(contour_mada) + tm_polygons() +\n  tm_shape(clusters_dhs) + tm_dots() + tm_facets(\"DHSYEAR\")\n\n\n\n\n\nGrappes d’enquêtes DHS par rapport aux AP existantes en 2008\n\n\n\n\nNous obtenons une carte distincte pour chaque année d’enquête. Sur chaque carte figure des points, dans laquelle chaque point représente un cluster d’enquête, correspondant aux coordonnées GPS fournies par DHS.",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#vérification-des-données-gps-des-clusters",
    "href": "01-treatment-assignation.html#vérification-des-données-gps-des-clusters",
    "title": "2  Treatment assignation",
    "section": "2.3 Vérification des données gps des clusters",
    "text": "2.3 Vérification des données gps des clusters\nOn vérifie que les coordonnées GPS sont bien dans le pays.\n\n\nCode\n# Fonction qui vérifie que les coordonnées ne sont pas nulles\ncheck_coordinates &lt;- function(dhs_gps, country_polygon, negate = FALSE) {\n  dhs_gps %&gt;%\n    filter(LONGNUM != 0 | LATNUM != 0)\n}\n\ngps_1997 &lt;- check_coordinates(gps_1997_initial, contour_mada)\ngps_2008 &lt;- check_coordinates(gps_2008_initial, contour_mada)\ngps_2011 &lt;- check_coordinates(gps_2011_initial, contour_mada)\ngps_2013 &lt;- check_coordinates(gps_2013_initial, contour_mada)\ngps_2016 &lt;- check_coordinates(gps_2016_initial, contour_mada)\ngps_2018 &lt;- check_coordinates(gps_2018_initial, contour_mada)\ngps_2021 &lt;- check_coordinates(gps_2021_initial, contour_mada)\n\n\nLes coordonnées GPS de 9 clusters de l’enquête 2008 n’ont pas de coordonnées valides (0,0). Il en manque également un en 1997.",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#chargement-des-données-ap",
    "href": "01-treatment-assignation.html#chargement-des-données-ap",
    "title": "2  Treatment assignation",
    "section": "2.4 Chargement des données AP",
    "text": "2.4 Chargement des données AP\nLes données utilisées sont les données du Système des Aires Protégées à Madgascar (SAPM) obtenues auprès du Service de la Gouvernance des Aires Protégées (SGAP) du Ministère de l’Environnement et de Développement Durable de Madagascar (MEDD). La vérification des dates de création des aires protégées est actuellement en cours. En attendant, nous utilisons la version officielle de 2017, sur laquelle on a corrigé des anomalies topologiques.\nLes données de SAPM sont codées en EPSG 9001, que l’on transforme en 4326 pour uniformiser les coordonnées GPS que nous utilisons. Nous le visualisons par la suite à travers une carte.\n\n\nCode\nlibrary(wdpar)\n\nwdpa &lt;- wdpa_read(\"data/raw/WDPA_WDOECM_Jul2025_Public_MDG.zip\") %&gt;%\n  wdpa_clean() |&gt; \n  filter(STATUS == \"Designated\") %&gt;%\n  mutate(MARINE = recode(MARINE,\n                           \"terrestrial\" = \"Terrestre\",\n                         \"marine\" = \"Marine\",\n                         \"partial\" = \"Mixte\"))\n\n# Load boundary\ncontour_mada &lt;- gadm(country = \"Madagascar\", level = 0, path = \"data\") %&gt;%\n  st_as_sf() %&gt;%\n  st_set_crs(standard_crs)\n\n# Visualisation\ntmap_mode(\"plot\")\n\ntm_shape(contour_mada) + tm_polygons() +\n  tm_shape(wdpa) +\n  tm_polygons(\n    fill = \"MARINE\",\n    fill.scale = tm_scale(\n      values = c(\n        \"Terrestre\" = \"#228B22\",\n        \"Marine\" = \"#1E90FF\",\n        \"Mixte\" = \"gray\"\n      )\n    ),\n    id = \"ORIG_NAME\",\n    popup.vars = c(\"Superficie (ha)\" = \"REP_AREA\")) +\n  tm_shape(contour_mada) +\n  tm_borders(\n    col = \"black\",\n    lwd = 0.5) +\n  tm_scalebar(position = c(\"RIGHT\", \"BOTTOM\")) + \n  tm_layout(legend.outside = TRUE) +\n  tm_title(\"Aires protégées de Madagascar\")\n\n\n\n\n\n\n\n\n\nOn peut aussi générer un format tabulaire pour visualiser les données.\n\n\nCode\n# Tableau complet\nwdpa_tb &lt;- wdpa %&gt;%\n  st_drop_geometry()\n\ndir.create(\"derived\")\n\nwrite_xlsx(wdpa_tb, \"data/derived/WDPA_WDOECM_Jul2025_Public_MDG.xlsx\")\n\nwdpa %&gt;%\n  DT::datatable()\n\n\n\n\n\n\nCode\n# Tableau personnalisé \nwdpa_tb_sel &lt;- wdpa_tb %&gt;%\n  select(WDPAID, ORIG_NAME, DESIG, DESIG_TYPE, IUCN_CAT, MARINE, REP_AREA, STATUS, STATUS_YR, GOV_TYPE, OWN_TYPE, MANG_AUTH, VERIF, GEOMETRY_TYPE, AREA_KM2)\n\nwrite_xlsx(wdpa_tb_sel, \"data/derived/WDPA_selection_MDG.xlsx\")\n\nDT::datatable(wdpa_tb_sel)",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#sélection-des-parties-terrestres-des-ap",
    "href": "01-treatment-assignation.html#sélection-des-parties-terrestres-des-ap",
    "title": "2  Treatment assignation",
    "section": "2.5 Sélection des parties terrestres des AP",
    "text": "2.5 Sélection des parties terrestres des AP\nNous commençons par charger les limites administratives nationales de Madagascar, dont on attribue un système de coordonnées 4326. Ces limites sont ensuite croisées avec les aires protégées de SAPM pour extraire uniquement les zones terrestres situées à l’intérieur du pays. Après la transformation au coordonnées de Laborde (29702), nous calculons la superficie de chaque aire protégée terrestre, et visualiser le tout sur une carte.\nOn garde que les éléments de SAPM qui sont contenu à l’intérieur des aires protégées de Madagascar.\n\n\nCode\n# Intersection des SAPM avec la limite de Madagascar\nwdpa_terrestre &lt;- wdpa %&gt;% \n  st_transform(crs = standard_crs) %&gt;%\n  st_make_valid() %&gt;%\n  st_intersection(contour_mada) %&gt;%\n  st_transform(mdg_crs) %&gt;%\n  mutate(\n    area_m2  = as.numeric(st_area(.)),\n    area_ha  = area_m2 / 1e4,\n    area_km2 = area_m2 / 1e6\n  ) %&gt;%\n  st_transform(standard_crs)\n\ntm_shape(contour_mada) +\n  tm_borders() +\ntm_shape(wdpa_terrestre) +\n  tm_polygons(fill =  \"green\", \n              id = \"ORIG_NAME\",\n              popup.vars = c(\"Superficie terrestre (ha)\" = \"REP_AREA\")) +\n  tm_scalebar(position = c(\"RIGHT\", \"BOTTOM\")) + \n  tmap_options(check_and_fix = TRUE) +\n  tm_title(\"Aires protégées terrestres de Madagascar\") +\n  tm_layout(legend.outside = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nOn a un problème avec les unités pour les surfaces dans la carte.\n\n\nEn examinant la base de donnée, nous avons constaté qu’il manquait la date de création de l’une des aires protégées. Nous allons donc ajouter l’année de création de l’aire protégée Complexe des aires protégées Ambohimirahavavy Marivorahona, créée par le décret 2015-782 du 28 avril 2015 (Goodman et al. 2018).\n\n\nCode\n# Ajout de la date de création du complexe des aires protégées Ambohimirahavavy Marivorahona \n\nwdpa_terrestre_mod &lt;- wdpa_terrestre %&gt;%\n  mutate(STATUS_YR = ifelse(WDPAID == 555697871, 2015, STATUS_YR))\n\n# Sauvegarder le shapefile modifié \nst_write(wdpa_terrestre_mod, \"data/derived/wdpa_terrestre_mod.shp\", delete_layer = TRUE)\n\n\nDeleting layer `wdpa_terrestre_mod' using driver `ESRI Shapefile'\nWriting layer `wdpa_terrestre_mod' to data source \n  `data/derived/wdpa_terrestre_mod.shp' using driver `ESRI Shapefile'\nWriting 137 features with 35 fields and geometry type Unknown (any).",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#création-de-buffer-pour-les-ap-avant-et-après-2008",
    "href": "01-treatment-assignation.html#création-de-buffer-pour-les-ap-avant-et-après-2008",
    "title": "2  Treatment assignation",
    "section": "2.6 Création de buffer pour les AP avant et après 2008",
    "text": "2.6 Création de buffer pour les AP avant et après 2008\nOn travaille toujours avec les portions terrestres des AP.\nPour analyser l’impact des aires protégées selon leur période de création, on spécifie les aires protégées créées avant 2008 et à partir de 2008. On applique ensuite une zone tampon de 10 km autour de chaque groupe d’aires protégées. Chaque groupe a été reprojeté dans le système de projection officiel de Madagascar, qui est le Laborde (EPSG : 29702) pour les calculs de distances. Nous créons ensuite une carte pour visualiser les aires protégées et leurs zones d’influence.\n\n\nCode\n# Buffer de 10 km\nbuffer_dist &lt;- 10000 \n\n# Spécification des aires protégées avant 2008\nwdpa_before_2008 &lt;- wdpa_terrestre_mod %&gt;%\n  filter(STATUS_YR &lt; 2008)\n\n# Spécification des aires protégées après 2008\nwdpa_from_2008 &lt;- wdpa_terrestre_mod %&gt;%\n  filter(STATUS_YR &gt;= 2008)\n\n# Créer des buffers de 10 km autour des AP\nbuffer_10km_before_2008 &lt;- wdpa_before_2008 %&gt;%\n  st_transform(mdg_crs) %&gt;%\n  st_buffer(dist = buffer_dist) %&gt;%\n  st_make_valid() %&gt;%\n  st_union() %&gt;%\n  st_as_sf() %&gt;%\n  st_make_valid() %&gt;%\n  st_transform(standard_crs)\n\nbuffer_10km_from_2008 &lt;- wdpa_from_2008  %&gt;%\n  st_transform(mdg_crs) %&gt;%\n  st_buffer(dist = buffer_dist) %&gt;% \n  st_make_valid() %&gt;%\n  st_union() %&gt;%\n  st_as_sf() %&gt;%\n  st_make_valid() %&gt;%\n  st_transform(standard_crs)\n\n# Visualisation des cartes \ntm_shape(contour_mada) + tm_polygons() +\ntm_shape(wdpa_before_2008) +\ntm_polygons(fill = \"blue\", \n            col =  \"black\", \n            fill_alpha = 0.5) +\ntm_shape(buffer_10km_from_2008) +\ntm_borders(col = \"darkgreen\", lwd = 2, lty = \"dashed\", fill.legend = tm_legend_hide()) +\ntm_shape(buffer_10km_before_2008) +\ntm_borders(col = \"blue\", lwd = 2, lty = \"dashed\", fill.legend = tm_legend_hide()) +\ntm_shape(wdpa_from_2008) +\ntm_polygons(fill = \"darkgreen\", \n            col = \"black\", \n            fill_alpha = 0.5) +\ntm_add_legend(type = \"polygons\", fill = c(\"blue\", \"darkgreen\"), labels = c(\"avant 2008\", \"après 2008\")) +\n  tm_title(\"Aires protégées par période de création\") +\n  tm_layout(\n    legend.outside = TRUE, \n    legend.position = c(\"RIGHT\", \"BOTTOM\"),\n    frame = FALSE,\n    legend.title.size = 1.2,\n    legend.text.size = 0.8\n  ) +\n  tm_compass(type = \"8star\", position = c(\"right\", \"top\")) +\n  tm_scalebar(position = c(\"right\", \"bottom\"))\n\n\n\n\n\nAires protégées du WDPA par période de création\n\n\n\n\nOn agrège les données pour chaque groupe, en calculant le nombre total d’aires protégées et leur superficie totale, que l’on présente sous forme de tableau.\n\n\nCode\n# Definition de la fonction\npivot_year &lt;- 2008\n\nsummary_table &lt;- wdpa_terrestre_mod %&gt;%\n  st_drop_geometry() %&gt;%\n  mutate(Creation_Period = if_else(STATUS_YR &lt; pivot_year,\n                                   paste(\"Avant\", pivot_year),\n                                   paste(\"À partir de\", pivot_year))) %&gt;%\n  group_by(Creation_Period) %&gt;%\n  summarise(\n    Count = n(),\n    Area_km2 = sum(area_km2, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n\n# Formatage du tableau avec gt\ngt_table &lt;- gt(summary_table) %&gt;%\n  tab_header(\n    title = paste(\"Aires protégées par période de création (Année pivot = \", pivot_year, \")\"),\n    subtitle = \"Zones terrestres uniquement\"\n  ) %&gt;%\n  cols_label(\n    Creation_Period = \"Période de Création\",\n    Count = \"Nombre d'AP\",\n    Area_km2 = \"Surface km²\"\n  ) %&gt;%\n  fmt_number(\n    columns = c(Count, Area_km2),\n    decimals = 0\n  )\n\ngt_table\n\n\n\n\n\n\n\n\nAires protégées par période de création (Année pivot = 2008 )\n\n\nZones terrestres uniquement\n\n\nPériode de Création\nNombre d'AP\nSurface km²\n\n\n\n\nAvant 2008\n34\n23,939\n\n\nÀ partir de 2008\n103\n51,252",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#classification-des-clusters",
    "href": "01-treatment-assignation.html#classification-des-clusters",
    "title": "2  Treatment assignation",
    "section": "2.7 Classification des clusters",
    "text": "2.7 Classification des clusters\nLes grappes d’enquête sont classées selon leur proximité aux aires protégées créées avant 2008 et à partir de 2008. A l’aide de la fonction classify_clusters(), nous catégorisons chaque cluster en trois groupes: traitement, contrôle ou exclu, selon leur localisation par rapport aux aires protégées et leur statut urbain ou rural. Cette classification est appliquée aux clusters de 1997, 2008, 2011, 2013, 2016 et 2021. Parmi les clusters considérés comme “traités”, on identifie l’année de création de l’AP, son type et le numéro WDPAID de l’AP en question. Les résultats sont ensuite fusionnés. Nous créons ensuite une carte par année d’étude pour visualiser la localisation des aires protégées et la répartition spatiale des clusters selon leur groupe. On va maintenant identifier, parmi les clusters considérés comme “traités”, l’année de création de l’AP, son type et le numéro WDPAID de l’AP en question.\n\n\nCode\nclassify_clusters_with_pa &lt;- function(cluster_gps,\n                                      buffer_before,   # union of &lt;2008\n                                      wdpa_after,      # polygons &gt;=2008 (no union)\n                                      buffer_dist = 10000,\n                                      label_treat = \"Treatment\",\n                                      label_excl  = \"Excluded\",\n                                      label_ctrl  = \"Control\") {\n\n  # per-PA buffers (keep attrs)\n  wdpa_after_buf &lt;- wdpa_after %&gt;%\n    st_transform(mdg_crs) %&gt;%\n    mutate(geometry = st_buffer(geometry, buffer_dist)) %&gt;%\n    st_transform(standard_crs)\n\n  # flags\n  in_after  &lt;- st_within(cluster_gps, st_union(wdpa_after_buf),  sparse = FALSE)[,1]\n  in_before &lt;- st_within(cluster_gps, buffer_before,            sparse = FALSE)[,1]\n\n  base &lt;- cluster_gps %&gt;%\n    mutate(groupe = case_when(\n      in_after & !in_before & URBAN_RURA == \"R\" ~ label_treat,\n      in_before | URBAN_RURA == \"U\"            ~ label_excl,\n      TRUE                                     ~ label_ctrl\n    ))\n\n  # enrich treated with oldest+nearest PA\n  treated_pts &lt;- base %&gt;% filter(groupe == label_treat)\n\n  if (nrow(treated_pts) == 0) return(base)\n\n  cand &lt;- st_join(treated_pts, wdpa_after_buf, join = st_within, left = FALSE) %&gt;%\n  mutate(\n    .idx = match(WDPAID, wdpa_after$WDPAID),\n    dist_km = as.numeric(\n      st_distance(\n        geometry,\n        wdpa_after$geometry[.idx],\n        by_element = TRUE\n      )\n    ) / 1000\n  ) %&gt;%\n  select(-.idx)\n\n  best &lt;- cand %&gt;%\n    group_by(DHSCLUST) %&gt;%\n    slice_min(STATUS_YR, with_ties = TRUE) %&gt;%\n    slice_min(dist_km,   with_ties = FALSE) %&gt;%\n    ungroup() %&gt;%\n    st_drop_geometry() %&gt;%\n    select(DHSYEAR, DHSCLUST, WDPAID, STATUS_YR, IUCN_CAT, dist_km)\n\n  base %&gt;% left_join(best, by = c(\"DHSYEAR\",\"DHSCLUST\"))\n}\n\ngps_1997_class &lt;- classify_clusters_with_pa(gps_1997, buffer_10km_before_2008, \n                                            wdpa_from_2008)\ngps_2008_class &lt;- classify_clusters_with_pa(gps_2008, buffer_10km_before_2008, \n                                            wdpa_from_2008)\ngps_2011_class &lt;- classify_clusters_with_pa(gps_2011, buffer_10km_before_2008, \n                                            wdpa_from_2008)\ngps_2013_class &lt;- classify_clusters_with_pa(gps_2013, buffer_10km_before_2008,\n                                            wdpa_from_2008)\ngps_2016_class &lt;- classify_clusters_with_pa(gps_2016, buffer_10km_before_2008,\n                                            wdpa_from_2008)\ngps_2018_class &lt;- classify_clusters_with_pa(gps_2018, buffer_10km_before_2008,\n                                            wdpa_from_2008)\ngps_2021_class &lt;- classify_clusters_with_pa(gps_2021, buffer_10km_before_2008,\n                                            wdpa_from_2008)\n\n\ngps_all_class &lt;- bind_rows(\n  gps_1997_class,\n  gps_2008_class,\n  gps_2011_class,\n  gps_2013_class,\n  gps_2016_class,\n  gps_2018_class,\n  gps_2021_class\n)\n\ntmap_mode(\"plot\")\n\n# Créer un plot pour visualiser la carte des AP avec les clusters\ntm_shape(contour_mada) + tm_polygons() +\ntm_shape(buffer_10km_from_2008) +\n  tm_borders(\"green\", \n             lwd = 2, \n             lty = \"dashed\", \n             fill.legend = tm_legend_hide()) +  \n  tm_shape(buffer_10km_before_2008) +\n  tm_borders(\"darkgreen\", \n             lwd = 2, \n             lty = \"dashed\", \n             fill.legend = tm_legend_hide()) +\n  tm_shape(wdpa_from_2008) +\n  tm_polygons(fill = \"green\", \n              fill_alpha = 0.5,\n              col = \"black\", \n              fill.legend = tm_legend(title = \"à partir de 2008\", position = tm_pos_in(\"right\", \"top\"))) +\n  tm_shape(wdpa_before_2008) +\n  tm_polygons(fill = \"darkgreen\", \n              fill_alpha = 0.5, \n              col =  \"black\", \n              fill.legend = tm_legend(title = \"avant 2008\", position = tm_pos_in(\"right\", \"top\"))) +\n  tm_shape(gps_all_class) +\n  tm_symbols(\n    fill = \"groupe\", \n    fill.legend = tm_legend(title = \"Groupes\"),\n    fill.scale = tm_scale(values = c(\"Treatment\" = \"red\", \"Control\" = \"blue\", \"Excluded\" = \"gray\")),\n     size = 0.5,\n    shape = 21\n  ) +\n  tm_facets(\"DHSYEAR\", nrow = 2, ncol = 4) +\n  tm_add_legend(type = \"polygons\", \n                fill = c(\"green\", \"darkgreen\"), \n                labels = c(\"à partir de 2008\", \"avant 2008\")) +\ntm_layout(\n  legend.outside = TRUE,\n  legend.outside.position = c(\"right\", \"bottom\"),\n  outer.margins = c(0, 0, 0, 0),\n  frame = FALSE\n)\n\n\n\n\n\nGrappes d’enquêtes DHS par rapport aux aires protégées existantes\n\n\n\n\nNous produisons un tableau récapitulatif du nombre de grappes d’enquête classées dans chaque groupe pour les années 1997, 2008 et 2021. Afin de faciliter le comptage et la transformation en tableau, nous supprimons les données spatiales pour ne conserver que les informations attributaires (année d’enquête “DHSYEAR” et groupe de classification “groupe”).\n\n\nCode\n# Sous-catégories pour le groupe \"Traitement\" (dépend de DHSYEAR vs STATUS_YR)\ntreated_sub_clusters &lt;- gps_all_class %&gt;%\n  st_drop_geometry() %&gt;%\n  filter(groupe == \"Treatment\") %&gt;%\n  mutate(subcat = case_when(\n    !is.na(STATUS_YR) & DHSYEAR &lt;  STATUS_YR ~ \"Avant traitement\",\n    !is.na(STATUS_YR) & DHSYEAR &gt;= STATUS_YR ~ \"Déjà traités\",\n    TRUE ~ NA_character_\n  )) %&gt;%\n  count(DHSYEAR, subcat, name = \"n_clusters\") %&gt;%\n  pivot_wider(names_from = subcat, values_from = n_clusters, values_fill = 0)\n\n# Ligne \"Ensemble\" (tous les traités, quel que soit le statut)\ntreated_all_clusters &lt;- gps_all_class %&gt;%\n  st_drop_geometry() %&gt;%\n  filter(groupe == \"Treatment\") %&gt;%\n  count(DHSYEAR, name = \"Ensemble\")\n\n# Colonnes Contrôles / Exclus\nctrl_excl_clusters &lt;- gps_all_class %&gt;%\n  st_drop_geometry() %&gt;%\n  filter(groupe %in% c(\"Control\", \"Excluded\")) %&gt;%\n  mutate(Groupe = recode(groupe, Control = \"Contrôles\", Excluded = \"Exclus\")) %&gt;%\n  count(DHSYEAR, Groupe, name = \"n\") %&gt;%\n  pivot_wider(names_from = Groupe, values_from = n, values_fill = 0)\n\n# Assemblage large (années en lignes)\ntab_wide_clusters &lt;- list(treated_sub_clusters, treated_all_clusters, \n                          ctrl_excl_clusters) %&gt;%\n  Reduce(function(x, y) full_join(x, y, by = \"DHSYEAR\"), .) %&gt;%\n  arrange(DHSYEAR) %&gt;%\n  mutate(across(-DHSYEAR, ~replace_na(.x, 0L)))\n\n# Tableau gt : spanner \"Traitement\" + colonnes Contrôles / Exclus\ngt_table_clusters &lt;- tab_wide_clusters %&gt;%\n  rename(Année = DHSYEAR) %&gt;%\n  gt() %&gt;%\n  tab_header(title = \"Nombre de grappes par année d'enquête et par groupe\") %&gt;%\n  cols_label(\n    `Avant traitement` = \"Avant traitement\",\n    `Déjà traités`     = \"Déjà traités\",\n    Ensemble           = \"Ensemble\",\n    `Contrôles`        = \"Contrôles\",\n    `Exclus`           = \"Exclus\"\n  ) %&gt;%\n  tab_spanner(\n    label = \"Traitement\",\n    columns = c(`Avant traitement`, `Déjà traités`, Ensemble)\n  ) %&gt;%\n  fmt_number(\n    columns = c(`Avant traitement`, `Déjà traités`, Ensemble, `Contrôles`, `Exclus`),\n    decimals = 0,\n    use_seps = TRUE\n  ) %&gt;%\n  cols_align(align = \"center\", columns = everything()) %&gt;%\n  tab_footnote(\n    footnote = md(\"**Avant traitement** : DHSYEAR &lt; STATUS_YR (AP pas encore créée). **Déjà traités** : DHSYEAR ≥ STATUS_YR. **Ensemble** : total des grappes *Traitement*.\"),\n    locations = cells_title(groups = \"title\")\n  )\n\ngt_table_clusters\n\n\n\n\n\n\n\n\nNombre de grappes par année d'enquête et par groupe1\n\n\nAnnée\nTraitement\nContrôles\nExclus\n\n\nAvant traitement\nDéjà traités\nEnsemble\n\n\n\n\n1997\n36\n0\n36\n102\n130\n\n\n2008\n81\n0\n81\n309\n195\n\n\n2011\n29\n2\n31\n139\n96\n\n\n2013\n44\n5\n49\n128\n97\n\n\n2016\n2\n51\n53\n215\n90\n\n\n2018\n0\n110\n110\n398\n266\n\n\n2021\n0\n109\n109\n315\n226\n\n\n\n1 Avant traitement : DHSYEAR &lt; STATUS_YR (AP pas encore créée). Déjà traités : DHSYEAR ≥ STATUS_YR. Ensemble : total des grappes Traitement.\n\n\n\n\n\n\n\n\nMaintenant avec le nombre de ménages :\n\n\nCode\n# Function to read DHS data for the specified year and identifier\nload_dhs_data &lt;- function(dhs_folder, year, identifier) {\n  folder_pattern &lt;- paste0(\".*\", year, \".*\", identifier)\n  \n  matching_folder &lt;- list.dirs(dhs_folder, full.names = TRUE, recursive = TRUE) %&gt;%\n    keep(~ str_detect(.x, folder_pattern))\n  \n  if (length(matching_folder) == 0) {\n    stop(\"No folder found for the specified year and identifier.\")\n  }\n  \n  if (identifier == \"GE\") {\n    file_pattern &lt;- \"\\\\.shp$\"\n    data_loader &lt;- function(file) st_read(file, quiet = TRUE)\n  } else {\n    file_pattern &lt;- \"\\\\.[Dd][Tt][Aa]$\"\n    data_loader &lt;- read_dta\n  }\n  \n  target_file &lt;- list.files(matching_folder, pattern = file_pattern, full.names = TRUE)\n  \n  if (length(target_file) == 0) {\n    stop(\"No valid file found in the folder.\")\n  }\n  \n  data &lt;- data_loader(target_file)\n  \n  return(data)\n}\n\ndhs_folder &lt;- \"data/raw/dhs\"\n\n\n# Années disponibles\nyears_all &lt;- sort(unique(gps_all_class$DHSYEAR))\n\n# Compte ménages (toutes observations) \nhouseholds_counts_all &lt;- map_dfr(years_all, function(y) {\n  \n  # Load data depending on year\n  if (y == 2018) {\n    hr &lt;- read_spss(\"data/raw/mics/2018/SPSS datasets/hh.sav\") %&gt;%\n      transmute(\n        hv001 = HH1,\n        hv002 = HH2,\n        DHSYEAR = y\n      )\n  } else {\n    hr &lt;- load_dhs_data(dhs_folder, y, \"HR\") %&gt;%\n      mutate(DHSYEAR = y) %&gt;%\n      select(hv001, hv002, DHSYEAR)\n  }\n\n  # Load classification for the same year\n  cl_y &lt;- gps_all_class %&gt;%\n    st_drop_geometry() %&gt;%\n    filter(DHSYEAR == y) %&gt;%\n    select(DHSYEAR, DHSCLUST, groupe, STATUS_YR)\n\n  # Join household data with classification\n  hr_cl &lt;- hr %&gt;%\n    left_join(cl_y, by = c(\"DHSYEAR\" = \"DHSYEAR\", \"hv001\" = \"DHSCLUST\"))\n\n  # Compute treatment/control/excluded breakdown\n  avant &lt;- hr_cl %&gt;% filter(groupe == \"Treatment\", !is.na(STATUS_YR), DHSYEAR &lt;  STATUS_YR) %&gt;% nrow()\n  deja  &lt;- hr_cl %&gt;% filter(groupe == \"Treatment\", !is.na(STATUS_YR), DHSYEAR &gt;= STATUS_YR) %&gt;% nrow()\n  ens   &lt;- hr_cl %&gt;% filter(groupe == \"Treatment\") %&gt;% nrow()\n  ctrl  &lt;- hr_cl %&gt;% filter(groupe == \"Control\")   %&gt;% nrow()\n  excl  &lt;- hr_cl %&gt;% filter(groupe == \"Excluded\")  %&gt;% nrow()\n\n  # Return row for this year\n  tibble(\n    DHSYEAR = y,\n    `Avant traitement` = avant,\n    `Déjà traités`     = deja,\n    Ensemble           = ens,\n    `Contrôles`        = ctrl,\n    `Exclus`           = excl\n  )\n})\n\n# Tableau gt (ménages, toutes observations)\ngt_table_menages_all &lt;- households_counts_all %&gt;%\n  rename(Année = DHSYEAR) %&gt;%\n  gt() %&gt;%\n  tab_header(title = \"Nombre de ménages par année d'enquête et par groupe\") %&gt;%\n  cols_label(\n    `Avant traitement` = \"Avant traitement\",\n    `Déjà traités`     = \"Déjà traités\",\n    Ensemble           = \"Ensemble\",\n    `Contrôles`        = \"Contrôles\",\n    `Exclus`           = \"Exclus\"\n  ) %&gt;%\n  tab_spanner(\n    label = \"Traitement\",\n    columns = c(`Avant traitement`, `Déjà traités`, Ensemble)\n  ) %&gt;%\n  fmt_number(\n    columns = c(`Avant traitement`, `Déjà traités`, Ensemble, `Contrôles`, `Exclus`),\n    decimals = 0, use_seps = TRUE\n  ) %&gt;%\n  cols_align(align = \"center\", columns = everything()) %&gt;%\n  tab_footnote(\n    footnote = md(\"**Avant traitement** : DHSYEAR &lt; STATUS_YR (AP pas encore créée). **Déjà traités** : DHSYEAR ≥ STATUS_YR. **Ensemble** : total des ménages du groupe *Traitement*.\"), locations = cells_title(groups = \"title\"))\n\ngt_table_menages_all   \n\n\n\n\n\n\n\n\nNombre de ménages par année d'enquête et par groupe1\n\n\nAnnée\nTraitement\nContrôles\nExclus\n\n\nAvant traitement\nDéjà traités\nEnsemble\n\n\n\n\n1997\n965\n0\n965\n3,505\n2,686\n\n\n2008\n2,451\n0\n2,451\n9,275\n5,852\n\n\n2011\n866\n64\n930\n4,221\n2,915\n\n\n2013\n1,379\n160\n1,539\n3,994\n3,041\n\n\n2016\n61\n1,624\n1,685\n6,771\n2,828\n\n\n2018\n0\n2,858\n2,858\n10,340\n6,919\n\n\n2021\n0\n3,392\n3,392\n10,013\n7,105\n\n\n\n1 Avant traitement : DHSYEAR &lt; STATUS_YR (AP pas encore créée). Déjà traités : DHSYEAR ≥ STATUS_YR. Ensemble : total des ménages du groupe Traitement.",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  },
  {
    "objectID": "01-treatment-assignation.html#enregistrement-des-variables-classifiées",
    "href": "01-treatment-assignation.html#enregistrement-des-variables-classifiées",
    "title": "2  Treatment assignation",
    "section": "2.8 Enregistrement des variables classifiées",
    "text": "2.8 Enregistrement des variables classifiées\nLes informations essentielles sur la classification des grappes d’enquête sont extraites et enregistrées dans un fichier csv en vue d’une utilisation ultérieure. Seules les informations nécessaires à l’identification des grappes et à leur groupe de traitement sont conservées, excluant les données géographiques et les variables non pertinentes.\n\n\nCode\nall_class &lt;- gps_all_class %&gt;%\n  select(DHSYEAR, DHSCLUST, GROUP = groupe, WDPAID, STATUS_YR, IUCN_CAT, dist_km)\n\nwrite_csv(all_class, \"data/derived/cluster_treatment_classification_staggered.csv\")\n\nwrite_csv(wdpa_before_2008, \"data/derived/wdpa_before_2008.csv\")\nwrite_csv(wdpa_from_2008, \"data/derived/wdpa_from_2008.csv\")\n\n\n\n\n\n\nGoodman, Steven M., Marie Jeanne Raherilalao, Sébastien Wohlhauser, Jean Clarck N. Rabenandrasana, Herivololona M. Rakotondratsimba, Fanja Andriamialisoa, and Malalarisoa Razafimpahanana. 2018. Les Aires Protégées Terrestres de Madagascar: Leur Histoire, Description Et Biote. Association Vahatra. https://zoboko.com/publisher/association-vahatra-in-antananarivo.",
    "crumbs": [
      "Data preparation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Treatment assignation</span>"
    ]
  }
]