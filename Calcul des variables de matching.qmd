---
title: "Calcul des variables de matching"
author: "Iriana Razafimahenina"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# Environnement

```{r}
library(tidyverse) #Manipulation et visualisation des données
library(haven) #Importation des données
library(writexl) #Exportation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(codebook) #Documentation et mise en forme des données 
library(gt) #Mise en forme des tableaux 
library(survey) #Analyse des données d'enquêtes
library(MatchIt) #Matching
library(ggplot2) #Figure
library(labelled) # Manipulation des labels
library(readxl) #Lecture des fichiers excels
library(progressr) # Pour avoir des barres de progression
library(tictoc) # Pour minuter le temps d'exécution
library(future) # Pour permettre du calcul parallèle
library(lubridate) # Gestion des dates
library(terra) # Manipulation des données raster 
library(geodata)
library(rstac)
library(mapme.biodiversity)
```

# Répertoire

```{r}

# Définir le chemin absolu pour ton répertoire local
outdir <- "Data/mapme"

# Créer le répertoire si il n'existe pas déjà
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

# Vérifier si le répertoire a bien été créé
if (dir.exists(outdir)) {
  cat("Répertoire créé ou déjà existant : ", outdir)
} else {
  cat("Le répertoire n'a pas pu être créé.")
}
mapme_options(
  outdir = outdir,
  verbose = TRUE
              )
```

# Chargement des données géophysiques des ménages pour 2008

Nous allons charger les données géophysiques des ménages à partir du package R mapme.biodiversity (<https://mapme-initiative.github.io/mapme.biodiversity/index.html>) pour charger et extraire les données sur:

-   Le couvert forestier en 2000 (Hansen et al.2013)

-   La pente et l'altitude (NASA SRTM)

-   La densité de population en 2000 (Worldpop)

-   L'accessibilité en 2000 (JRC, Uchida et Nelson 2011)

```{r}

# Chargement des données 
gps_2008 <- st_read("Data/DHS_data/DHS_2008/MDGE53FL/MDGE53FL.shp")


if (file.exists("Data/output/gps_2008_geo.rds")) {
  gps_2008_geo <- readRDS("Data/output/gps_2008_geo.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  plan(sequential)
  plan(multisession, workers = 4)
  
  
  # Créer un buffer autour de chaque point pour former des polygones
  gps_2008_geo <- st_buffer(gps_2008, dist = 10000)
      
  # chargement des ressources: slope, elevation, population_count, traveltime_2000
  gps_2008_geo <- gps_2008_geo %>%
    get_resources(get_gfw_treecover())
  
  gps_2008_geo <- gps_2008_geo %>%  
    get_resources(get_gfw_lossyear())
  
  gps_2008_geo <- gps_2008_geo %>% 
    get_resources(get_nasa_srtm())
  
  gps_2008_geo <- gps_2008_geo %>% 
    get_resources(get_worldpop(years = 2000))
  
  gps_2008_geo <- gps_2008_geo %>%  
    get_resources(get_accessibility_2000())
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_treecover_area(years = 2000, min_size = 10, min_cover = 35))
  })
  toc()   # 362.75 sec
  
  # slope
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_slope(engine = "extract", stats = "mean"))
  })
  toc() # 367.26 sec
  
  # Elevation
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc() # 349.14 sec
  
  # Population density
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc() # 52.58 sec
  
  # Accessibility
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc() # 37.81 sec
 
  # Enregistrement des données 
  write_rds(gps_2008_geo, "Data/output/gps_2008_geo.rds")
  cat("✅ Données enregistrées dans gps_2008_geo.rds avec géométries en POINT et indicateurs ajoutés.\n")
  
}
```

## Correction des lignes NULL dans le dataframe

```{r}

# Filtrer les lignes où il y a des valeurs NULL
test_2008 <- gps_2008_geo %>%
filter(sapply(treecover_area, is.null))

# Supprimer les lignes avec LATNUM et LONGNUM nulles
test_clean_2008 <- test_2008 %>% 
  filter(LATNUM != 0, LONGNUM != 0)

# création d'un point géospatial à partir des coordonnées de la ligne où la colonne treecover_area est NULL
test_clean_2008 %>%
    st_drop_geometry() %>%
    select(LATNUM, LONGNUM)

# Ligne 1
point_1_2008 <- st_sf(
  geometry = st_sfc(st_point(c(44.3, -25.0))),
  crs = 4326 
)
# Création d'un buffer de 10 km autour du point géospatial
buffer_1_2008 <- st_buffer(point_1_2008, dist = 10000) 

# Téléchargement de treecover_area pour le buffer spécifique 
buffer_1_2008 <- buffer_1_2008 %>%
  get_resources(get_gfw_treecover(),
                get_gfw_lossyear()
  )
# Calcul des indicateurs pour le buffer spécifique
buffer_1_2008 <- buffer_1_2008 %>%
  calc_indicators(
    calc_treecover_area(
      years = 2000, 
      min_size = 1, 
      min_cover = 10
    )
  )
# Extraire la valeur calculée pour trecover_area
new_value_2008 <- buffer_1_2008$treecover_area[[1]]

# Attribution de la nouvelle valeur à la ligne correspondante dans test_clean
test_clean_2008$treecover_area[[1]] <- new_value_2008

# Ligne 2
point_2_2008 <- st_sf(
  geometry = st_sfc(st_point(c(44.9, -25.2))),
  crs = 4326 
)
# Création d'un buffer de 10 km autour du point géospatial
buffer_2_2008 <- st_buffer(point_2_2008, dist = 10000) 

# Téléchargement de treecover_area pour le buffer spécifique 
buffer_2_2008 <- buffer_2_2008 %>%
  get_resources(get_gfw_treecover(),
                get_gfw_lossyear()
  )
# Calcul des indicateurs pour le buffer spécifique
buffer_2_2008 <- buffer_2_2008 %>%
  calc_indicators(
    calc_treecover_area(
      years = 2000, 
      min_size = 1, 
      min_cover = 10
    )
  )
# Extraire la valeur calculée pour trecover_area
new_value_2008 <- buffer_2_2008$treecover_area[[1]]


# Attribution de la nouvelle valeur à la ligne correspondante dans test_clean
test_clean_2008$treecover_area[[2]] <- new_value_2008

```

## Mise à jour de la colonne treecover_area 2008

```{r}

# Remplacement des lignes avec celles de test_clean 
gps_2008_geo[c(462, 472), ] <- test_clean_2008[c(1, 2), ]

# Suppression des lignes avec des LATNUM et LONGNUM nulles
idx_to_remove <- which(sapply(gps_2008_geo$treecover_area, is.null) &
                         (gps_2008_geo$LATNUM == 0 | gps_2008_geo$LONGNUM == 0))
  
# Mise à jour du gps_2008_geo
gps_2008_geo_clean <- gps_2008_geo[-idx_to_remove, ]

```

## Chargement des données sur les précipitations pour 2008

```{r}

if (file.exists("Data/output/gps_2008_geo_clean.rds")) {
  gps_2008_geo_clean <- readRDS("Data/output/gps_2008_geo_clean.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  plan(sequential)
  plan(multisession, workers = 4)
  
  # Chargement des données
  tic("Chargement des données climatiques")
  with_progress({
    gps_2008_geo_clean <- gps_2008_geo_clean %>%
      get_resources(
        get_worldclim_max_temperature(years = 1996:2021, resolution = "10m"),
        get_worldclim_min_temperature(years = 1996:2021, resolution = "10m"),
        get_worldclim_precipitation(years = 1996:2021, resolution = "10m")
      )
  })
  toc()
  
  # Extraction des données 
  tic()
  with_progress({
    gps_2008_geo_clean <- gps_2008_geo_clean %>%
      calc_indicators(
        calc_precipitation_wc(engine = "extract", stats = "mean"),
        calc_temperature_max_wc(engine = "extract", stats = "mean"),
        calc_temperature_min_wc(engine = "extract", stats = "mean")
      )
  })
  toc()
  
  # Enregistrement 
  write_rds(x= gps_2008_geo_clean, file = "Data/output/gps_2008_geo_clean.rds")
}

```

### Calcul de l'indice Standardized Precipitation Evapotranspiration Index (SPEI)

L'indice SPEI est calculé à partir d'une référence à long terme (1981-2010) pour quantifier l'excès ou le manque de pluie. Son calcul se fait à partir des données mensuelles de précipitation et de température minimum et maximum provenant de Worlclim, en utilisant une version améliorée de la méthode Hargreaves ( Modified-Hargreaves methods) définie par Droogers et Allen (2002). La variable sera calculée pour un cercle de 10 km de rayon autour de la coordonnée GPS de la grappe.

```{r}

library(SPEI)
library(gander)
library(ellmer)
library(devtools)
library (fastmap)

# Latitude calculation
if (file.exists("data/output/gps_2008_spei.rds")) {
  gps_2008_spei <- read_rds("data/output/gps_2008_spei.rds")
} else {
  gps_2008_spei <- gps_2008_geo_clean %>% 
    mutate(
      lat = st_coordinates (st_centroid(geometry))[,2])
  
  # Extract the first cluster's climate time series
  row1 <- gps_2008_spei [1,]
  
  # Extract vectors 
  tmin <- row1$temperature_min_wc[[1]]$value
  tmax <- row1$temperature_max_wc[[1]]$value
  prec <- row1$precipitation_wc[[1]]$value
  dates <- row1$temperature_min_wc[[1]]$datetime
  lat <- row1$LATNUM
  
  # Compute reference evapotranspiration (PET) using modified Hargreaves (Droogers & Allen)
  pet <- hargreaves(Tmin = tmin, Tmax = tmax, Pre = prec, lat = lat)
  
  # Compute wtaer balance
  wb <- prec - pet
  
  # Turn to time series
  wb_ts <- ts(wb, start = c(year(min(dates)), month(min(dates))), frequency = 12)
  
  # Compute SPEI (e.g 3-month scale)
  spei_obj <- spei(wb_ts, scale = 3)
  
  # Turn into tibble
  spei_tbl <- tibble(
    datetime = dates, 
    spei = as.numeric(spei_obj$fitted)
  )
  
  # SPEI sous forme de map
  gps_2008_spei <- gps_2008_spei %>%
    mutate(
      spei_wc = pmap(
        list(tmin = temperature_min_wc,
             tmax = temperature_max_wc,
             prec = precipitation_wc,
             lat = lat),
        function(tmin, tmax, prec, lat) {
          data_tmin <- data.frame(date = tmin$datetime, tmin = tmin$value)
          data_tmax <- data.frame(date = tmax$datetime, tmax = tmax$value)
          data_prec <- data.frame(date = prec$datetime, prec = prec$value)
          
        # Fusionner
        data_merged <- reduce(list(data_tmin, data_tmax, data_prec), merge, by = "date")

        # Supprimer les lignes avec NA
        data_clean <- na.omit(data_merged)

        # Si les données nettoyées sont insuffisantes, retourner des NA
        if (nrow(data_clean) < 12) {
          return(tibble(datetime = data_merged$date, spei = NA_real_))
        }

        # Extraire les colonnes propres
        tmin_synced <- data_clean$tmin
        tmax_synced <- data_clean$tmax
        prec_synced <- data_clean$prec
        dates_synced <- data_clean$date
        
        # calcul PET
        pet <- hargreaves(
          Tmin = tmin_synced,
          Tmax = tmax_synced,
          Pre = prec_synced,
          lat = lat
        )
        
        wb <- prec_synced - pet
        
        wb_ts <- ts(wb, start = c(year(min(dates_synced)), month(min(dates_synced))), frequency = 12)
        
        spei_obj <- spei(wb_ts, scale = 3)
        
        # Résultat
        tibble(datetime = dates_synced, spei = as.numeric(spei_obj$fitted))
       
        }
      )
    )
}
 write_rds(x = gps_2008_spei, file = "Data/output/gps_2008_spei.rds")
```

# Chargement des données géophysiques des ménages pour 2021

```{r}

# Chargement des données 
gps_2021 <- st_read("Data/DHS_data/DHS_2021/MDGE81FL/MDGE81FL.shp")


if (file.exists("Data/output/gps_2021_geo.rds")) {
  gps_2021_geo <- readRDS("Data/output/gps_2021_geo.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  plan(sequential)
  plan(multisession, workers = 4)

  # Créer un buffer autour de chaque point pour former des polygones 
  gps_2021_geo <- st_buffer(gps_2021, dist = 10000)
  
  # Définir les ressources à télécharger (corrigé)
  gps_2021_geo <- gps_2021_geo %>%
    get_resources(get_gfw_treecover())
  
  gps_2021_geo <- gps_2021_geo %>%  
    get_resources(get_gfw_lossyear())
  
  gps_2021_geo <- gps_2021_geo %>% 
    get_resources(get_nasa_srtm())
  
  gps_2021_geo <- gps_2021_geo %>% 
    get_resources(get_worldpop(years = 2000))
  
  gps_2021_geo <- gps_2021_geo %>%  
    get_resources(get_accessibility_2000())
  
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    gps_2021_geo <- calc_indicators(
      x = gps_2021_geo, calc_treecover_area(years = 2000, min_size = 10, min_cover = 35))
  })
  toc()   # 362.75 sec
  
  # slope
  tic()
  with_progress({
    gps_2021_geo <- calc_indicators(
      x = gps_2021_geo, calc_slope(engine = "extract", stats = "mean"))
  })
  toc() # 316.09 sec
  
  # Elevation
  tic()
  with_progress({
    gps_2021_geo <- calc_indicators(
      x = gps_2021_geo, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc() # 662.1 sec
  
  # Population density
  tic()
  with_progress({
    gps_2021_geo <- calc_indicators(
      x = gps_2021_geo, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc() # 47.42 sec
  
  # Accessibility
  tic()
  with_progress({
    gps_2021_geo <- calc_indicators(
      x = gps_2021_geo, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc() # 37.81 sec
  
  # Enregistrement des données sous forme de points 
  write_rds(gps_2021_geo, "Data/output/gps_2021_geo.rds")
  cat("Données enregistrées dans gps_2021_geo.rds")
  
  }
```

## Correction des lignes NULL dans le dataframe pour 2021

```{r}

# Filtrer les lignes où il y a des valeurs NULL
test_2021 <- gps_2021_geo %>%
filter(sapply(treecover_area, is.null))

# création d'un point géospatial à partir des coordonnées de la ligne où la colonne treecover_area est NULL
test_2021 %>%
    st_drop_geometry() %>%
    select(LATNUM, LONGNUM)


# Ligne 1
Point_1_2021 <- st_sf(
  geometry = st_sfc(st_point(c(44.9, -25.1))),
  crs = 4326 
)
# Création d'un buffer de 10 km autour du point géospatial
buffer_1_2021 <- st_buffer(Point_1_2021, dist = 10000) 

# Téléchargement de treecover_area pour le buffer spécifique 
buffer_1_2021 <- buffer_1_2021 %>%
  get_resources(get_gfw_treecover(),
                get_gfw_lossyear()
  )
# Vérification d taux de couvert forestier 
resources <- prep_resources(buffer_1_2021, resources = c("gfw_treecover", "gfw_lossyear"), mode = "asset")

# Résumé statistique des valeurs dans chaque raster
lapply(resources, FUN = function(x) summary(terra::values(x)))


# Calcul des indicateurs pour le buffer spécifique
buffer_1_2021 <- buffer_1_2021 %>%
  calc_indicators(
    calc_treecover_area(
      years = 2000, 
      min_size = 1, 
      min_cover = 10
    )
  )
# Extraire la valeur calculée pour trecover_area
new_value_2021 <- buffer_1_2021$treecover_area[[1]]

# Attribution de la nouvelle valeur à la ligne correspondante dans test_clean
test_2021$treecover_area[[1]] <- new_value_2021

# Ligne 2
point_2_2021 <- st_sf(
  geometry = st_sfc(st_point(c(45.0, -25.5))),
  crs = 4326 
)
# Création d'un buffer de 10 km autour du point géospatial
buffer_2_2021 <- st_buffer(point_2_2021, dist = 10000) 

# Téléchargement de treecover_area pour le buffer spécifique 
buffer_2_2021 <- buffer_2_2021 %>%
  get_resources(get_gfw_treecover(),
                get_gfw_lossyear()
  )
# Calcul des indicateurs pour le buffer spécifique
buffer_2_2021 <- buffer_2_2021 %>%
  calc_indicators(
    calc_treecover_area(
      years = 2000, 
      min_size = 1, 
      min_cover = 10
    )
  )
# Extraire la valeur calculée pour trecover_area
new_value_2021 <- buffer_2_2021$treecover_area[[1]]


# Attribution de la nouvelle valeur à la ligne correspondante dans test_2021
test_2021$treecover_area[[2]] <- new_value_2021


```

## Mise à jour de treecover 2021

```{r}

# Identification des index des lignes à corriger dans gps_2021_geo
idx_null <- which(sapply(gps_2021_geo$treecover_area, is.null))

# Remplacement des valeurs NULL par les valeurs corrigées
gps_2021_geo$treecover_area[idx_null] <- test_2021$treecover_area
```

## Chargement des données sur les précipitations pour 2021

```{r}
if (file.exists("Data/output/gps_2021_geo_clean.rds")) {
  gps_2021_geo_clean <- readRDS("Data/output/gps_2021_geo_clean.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  plan(sequential)
  plan(multisession, workers = 4)
  
  # Chargement des données
  tic("Chargement des données climatiques")
  with_progress({
    gps_2021_geo_clean <- gps_2021_geo_clean %>%
      get_resources(
        get_worldclim_max_temperature(years = 1996:2021, resolution = "10m"),
        get_worldclim_min_temperature(years = 1996:2021, resolution = "10m"),
        get_worldclim_precipitation(years = 1996:2021, resolution = "10m")
      )
  })
  toc()
  
  # Extraction des données 
  tic()
  with_progress({
    gps_2021_geo_clean <- gps_2021_geo_clean %>%
      calc_indicators(
        calc_precipitation_wc(engine = "extract", stats = "mean"),
        calc_temperature_max_wc(engine = "extract", stats = "mean"),
        calc_temperature_min_wc(engine = "extract", stats = "mean")
      )
  })
  toc()
  
  # Enregistrement 
  write_rds(x= gps_2021_geo_clean, file = "Data/output/gps_2021_geo_clean.rds")
}

```
