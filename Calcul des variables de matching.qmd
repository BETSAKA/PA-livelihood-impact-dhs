---
title: "Calcul des variables de matching"
author: "Iriana Razafimahenina"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

# Environnement

```{r}
library(tidyverse) #Manipulation et visualisation des données
library(haven) #Importation des données
library(writexl) #Exportation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(codebook) #Documentation et mise en forme des données 
library(gt) #Mise en forme des tableaux 
library(survey) #Analyse des données d'enquêtes
library(MatchIt) #Matching
library(ggplot2) #Figure
library(labelled) # Manipulation des labels
library(readxl) #Lecture des fichiers excels
library(progressr) # Pour avoir des barres de progression
library(tictoc) # Pour minuter le temps d'exécution
library(mapme.biodiversity)
library(future) # Pour permettre du calcul parallèle
library(lubridate) # Gestion des dates
library(terra) # Manipulation des données raster 
library(geodata)
library(rstac)
```

## Répertoire

```{r}

# Définir le chemin absolu pour ton répertoire local
outdir <- "Data/mapme"

# Créer le répertoire si il n'existe pas déjà
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

# Vérifier si le répertoire a bien été créé
if (dir.exists(outdir)) {
  cat("Répertoire créé ou déjà existant : ", outdir)
} else {
  cat("Le répertoire n'a pas pu être créé.")
}
mapme_options(
  outdir = outdir,
  verbose = TRUE
              )
```

## Chargement des données géophysiques des ménages

Nous allons charger les données géophysiques des ménages à partir du package R mapme.biodiversity (<https://mapme-initiative.github.io/mapme.biodiversity/index.html>) pour charger et extraire les données sur:

-   Le couvert forestier en 2000 (Hansen et al.2013)

-   La pente et l'altitude (NASA SRTM)

-   La densité de population en 2000 (Worldpop)

-   L'accessibilité en 2000 (JRC, Uchida et Nelson 2011)

```{r}

# Chargement des données 
gps_2008 <- st_read("Data/DHS_data/DHS_2008/MDGE53FL/MDGE53FL.shp")


if (file.exists("Data/output/gps_2008_geo.rds")) {
  gps_2008_geo <- readRDS("Data/output/gps_2008_geo.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  plan(sequential)
  plan(multisession, workers = 4)
  
  
  # Créer un buffer autour de chaque point pour former des polygones
  gps_2008_geo <- st_buffer(gps_2008, dist = 10000)
      
  # chargement des ressources: slope, elevation, population_count, traveltime_2000
  gps_2008_geo <- gps_2008_geo %>%
    get_resources(get_gfw_treecover())
  
  gps_2008_geo <- gps_2008_geo %>%  
    get_resources(get_gfw_lossyear())
  
  gps_2008_geo <- gps_2008_geo %>% 
    get_resources(get_nasa_srtm())
  
  gps_2008_geo <- gps_2008_geo %>% 
    get_resources(get_worldpop(years = 2000))
  
  gps_2008_geo <- gps_2008_geo %>%  
    get_resources(get_accessibility_2000())
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_treecover_area(years = 2000, min_size = 10, min_cover = 35))
  })
  toc()   # 362.75 sec
  
  # slope
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_slope(engine = "extract", stats = "mean"))
  })
  toc() # 367.26 sec
  
  # Elevation
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc() # 349.14 sec
  
  # Population density
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc() # 52.58 sec
  
  # Accessibility
  tic()
  with_progress({
    gps_2008_geo <- calc_indicators(
      x = gps_2008_geo, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc() # 37.81 sec
 
  # Enregistrement des données sous forme de points (dans le même dataframe gps_2008)
  write_rds(gps_2008_geo, "Data/output/gps_2008_geo.rds")
  cat("✅ Données enregistrées dans gps_2008_geo.rds avec géométries en POINT et indicateurs ajoutés.\n")
  
}
```

### Correction des lignes NULL dans le dataframe

```{r}

# Filtrer les lignes où il y a des valeurs NULL
test <- gps_2008_geo %>%
filter(sapply(treecover_area, is.null))

# Supprimer les lignes avec LATNUM et LONGNUM nulles
test_clean <- test %>% 
  filter(LATNUM != 0, LONGNUM != 0)

# création d'un point géospatial à partir des coordonnées de la ligne où la colonne treecover_area est NULL
test_clean %>%
    st_drop_geometry() %>%
    select(LATNUM, LONGNUM)

# Ligne 1
my_point_1 <- st_sf(
  geometry = st_sfc(st_point(c(44.3, -25.0))),
  crs = 4326 
)
# Création d'un buffer de 10 km autour du point géospatial
my_buffer_1 <- st_buffer(my_point_1, dist = 10000) 

# Téléchargement de treecover_area pour le buffer spécifique 
my_buffer_1 <- my_buffer_1 %>%
  get_resources(get_gfw_treecover(),
                get_gfw_lossyear()
  )
# Calcul des indicateurs pour le buffer spécifique
my_buffer_1 <- my_buffer_1 %>%
  calc_indicators(
    calc_treecover_area(
      years = 2000, 
      min_size = 1, 
      min_cover = 10
    )
  )
# Extraire la valeur calculée pour trecover_area
new_value <- my_buffer_1$treecover_area[[1]]

# Attribution de la nouvelle valeur à la ligne correspondante dans test_clean
test_clean$treecover_area[[1]] <- new_value

# Ligne 2
my_point_2 <- st_sf(
  geometry = st_sfc(st_point(c(44.9, -25.2))),
  crs = 4326 
)
# Création d'un buffer de 10 km autour du point géospatial
my_buffer_2 <- st_buffer(my_point_2, dist = 10000) 

# Téléchargement de treecover_area pour le buffer spécifique 
my_buffer_2 <- my_buffer_2 %>%
  get_resources(get_gfw_treecover(),
                get_gfw_lossyear()
  )
# Calcul des indicateurs pour le buffer spécifique
my_buffer_2 <- my_buffer_2 %>%
  calc_indicators(
    calc_treecover_area(
      years = 2000, 
      min_size = 1, 
      min_cover = 10
    )
  )
# Extraire la valeur calculée pour trecover_area
new_value <- my_buffer_2$treecover_area[[1]]


# Attribution de la nouvelle valeur à la ligne correspondante dans test_clean
test_clean$treecover_area[[2]] <- new_value

```

### Mise à jour du dataframe gps_2008_geo

```{r}

# Remplacement des lignes avec celles de test_clean 
gps_2008_geo[c(462, 472), ] <- test_clean[c(1, 2), ]

# Suppression des lignes avec des LATNUM et LONGNUM nulles
idx_to_remove <- which(sapply(gps_2008_geo$treecover_area, is.null) &
                         (gps_2008_geo$LATNUM == 0 | gps_2008_geo$LONGNUM == 0))
  
# Mise à jour du gps_2008_geo
gps_2008_geo <- gps_2008_geo[-idx_to_remove, ]
```
