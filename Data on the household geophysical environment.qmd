---
title: "Data on the household geophysical environment"
author: "Iriana Razafimahenina"
format: 
  html:
   out-put-file: index.html
   embed-resources: true
   standalone: true
   code-fold: true
  execute:
   warning: false
   error: false
editor: visual
editor-options: 
   chunk_out_type: console
Bibliography: references.bib
editor: visual
editor_options: 
  chunk_output_type: console
---

## Data on the household geophysical environment

Nous allons utiliser le package R mapme.biodiversity (<https://mapme-initiative.github.io/mapme.biodiversity/index.html>) pour charger et extraire les données sur la couverture forestière, la pente et l'altitude, la densité de population, l'accessibilité en 2000.

```{r}
# Library
library(mapme.biodiversity)
library(sf) # Pour les données spatiales 
library(progressr) # Pour avoir des barres de progression
library(tictoc) # Pour minuter le temps d'exécution
library(future) # Pour permettre du calcul parallèle
library(lubridate) # Gestion des dates
library(codebook)
library(gt)
library(terra) # Manipulation des données raster 
library(geodata)

# Définir le chemin absolu pour ton répertoire local
outdir <- "Data"

# Créer le répertoire si il n'existe pas déjà
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

# Vérifier si le répertoire a bien été créé
if (dir.exists(outdir)) {
  cat("Répertoire créé ou déjà existant : ", outdir)
} else {
  cat("Le répertoire n'a pas pu être créé.")
}
mapme_options(
  outdir = outdir,
  verbose = TRUE
)
```

### Définition des unités d'analyse

L'unité d'analyse de cette études est le ménage. Nous allons charger nos clusters de 2008 et 2021.

```{r clusters}
library(dplyr)
library(sf)
library(stringr)
library(purrr)
library(haven)
library(tmap)
library(readr)
library(ggplot2)
library(jsonify)

# Load boundary
  if (file.exists("Data/contour_mada.rds")) {
  contour_mada <- read_rds("Data/contour_mada.rds") 
} else {
  contour_mada <- gadm(country = "Madagascar", level = 0, path = "Data") %>%
    st_as_sf() %>%
    st_transform(29702)
  saveRDS(contour_mada, "Data/contour_mada.rds")
}
  
# Load DHS data 
dhs_folder <- "C:/Users/irian/Documents/IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data"

  load_data <- function(year, type, dhs_folder) {
  year_folder <- file.path(dhs_folder, paste0("DHS_", year))
  
  # Get the .shp (GPS) and .dta (household) file paths
  if (type == "HR") {
    hr_path <- list.files(year_folder, pattern = ".*HR.*\\.dta$", full.names = TRUE, recursive = TRUE, ignore.case = TRUE)
    if (length(hr_path) == 0) stop("No HR file found for the specified year.")
    out <- read_dta(hr_path) # Lecture du fichier .dta
  } else if (type == "GPS") {
    shp_path <- list.files(year_folder, pattern = "\\.shp$", full.names = TRUE, recursive = TRUE)
    if (length(shp_path) == 0) stop("No GPS file found for the specified year.")
    out <- st_read(shp_path, quiet = TRUE) %>%
      st_transform(29702) # Lecture du fichier .shp
  } else {
    stop("Data type unknown, must be HR or GPS")
  }
  return(out) 
}
  
# Execute the function for a specific year
  hr_2008 <- load_data(2008, "HR", dhs_folder)
  gps_2008 <- load_data(2008, "GPS", dhs_folder)
  
  hr_2021 <- load_data(2021, "HR", dhs_folder)
  gps_2021 <- load_data(2021, "GPS", dhs_folder)
  
# Vérification des données GPS
  print(gps_2008)
  print(gps_2021)
  
  st_geometry(gps_2008)
  st_geometry(gps_2021)

# Vérification des données GPS
  if (!"DHSCLUST" %in% colnames(gps_2008)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}
  
  if (!"DHSCLUST" %in% colnames(gps_2021)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}
  
# Création des buffers de 10 km autour des points GPS
  create_buffer <- function(gps_data) {
    gps_data %>% st_transform(29702) %>% st_buffer(dist = 10000)
  }
  
  buffer_10km_2008 <- create_buffer(gps_2008)
  
  buffer_10km_2021 <- create_buffer(gps_2021)

# Créer un sauvegarde des clusters
save_clusters <- function(buffer, output_folder, year) {
  if (!dir.exists(output_folder)) {
    dir.create(output_folder, recursive = TRUE)
    message(paste("Répertoire créé pour l'année", year))
  }
  saveRDS(buffer, file = file.path(output_folder, paste0("household_cluster_", year, ".rds")))
  message(paste("Buffer de 10 km sauvegardé pour l'année", year))

  # Afficher un aperçu des clusters
  message(paste("Aperçu du buffer pour l'année", year, ":"))
  print(buffer)
}


# Chemins de sauvegarde
output_folder_base <- "C:/Users/irian/Documents/Statistiques/PA-livelihood-impact-dhs2/Data"
output_folder_2008 <- file.path(output_folder_base, "household_cluster_2008")
output_folder_2021 <- file.path(output_folder_base, "household_cluster_2021")


save_clusters(buffer_10km_2008, output_folder_2008, 2008)
save_clusters(buffer_10km_2021, output_folder_2021, 2021)

household_cluster_2008 <- readRDS(file.path(output_folder_2008, "household_cluster_2008.rds"))
household_cluster_2021 <- readRDS(file.path(output_folder_2021, "household_cluster_2021.rds"))

# Message de confirmation
cat("Les fichiers household_cluster_2008.rds et household_cluster_2021.rds ont été sauvegardés avec succès.\n")

# Visualiser les buffers et les points GPS 
tmap_mode("view")


contour_mada %>% 
  st_transform(4326) %>% 
  tm_shape() +
    tm_borders(col = "black")

# Visualisation des données pour 2008
create_cluster_map <- function(contour_mada, buffer, gps, year, fill, col, dot_color) {
  tm_shape(contour_mada) +
    tm_borders(col = "black") +
    tm_shape(buffer) +
    tm_polygons(fill = fill, col = col, fill_alpha = 0.5) +
    tm_shape(gps) +
    tm_dots(col = dot_color, size = 0.5) +
    tm_title(paste("Clusters", year, "avec Buffers 10km et Contours de Madagascar")) +
    tm_scalebar()
}

# Créer les cartes
tm_2008 <- create_cluster_map(contour_mada, buffer_10km_2008, gps_2008, 2008, "lightblue", "darkblue", "red")
tm_2021 <- create_cluster_map(contour_mada, buffer_10km_2021, gps_2021, 2021, "lightgreen", "darkgreen", "blue")

tm_2008
tm_2021

```

### Chargement des données de mapme.biodiversity

-   Couvert forestier en 2000 (Hansen et al.2013)

-   Pente et altitude (NASA SRTM)

-   Densité de population en 2000 (Worldpop)

-   Accessibilité en 2000 (JRC, Uchida et Nelson 2011)

-   Précipitations

Nous allons maintenant charger les données géophysiques des ménages à partir de mapme.biodiversity

```{r 2008}
library(mapme.biodiversity)
library(tidyverse)
library(progressr) # Pour avoir des barres de progression
library(tictoc)
library(future)
library(sf)
library(rstac)
library(terra)

# Activer la barre de progression
handlers(global = TRUE)
handlers("progress")

# Vérifier et charger les données
if (file.exists("Data/household_cluster_2008/household_cluster_2008_res.rds")) {
  household_cluster_2008_res <- readRDS("Data/household_cluster_2008/household_cluster_2008_res.rds")
} else {
  plan(sequential)
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    household_cluster_2008 <- household_cluster_2008 %>%
      get_resources(get_gfw_treecover(),
                    get_gfw_lossyear()
      )
  })
  toc()  
  
  # Slope and elevation
  tic()
  with_progress({
    household_cluster_2008 <- household_cluster_2008 %>%
      get_resources(get_nasa_srtm())
  })
  toc()  
  
  # Population density
  tic()
  with_progress({
    household_cluster_2008 <- household_cluster_2008 %>%
      get_resources(get_worldpop(years = 2000))
  })
  toc()  
  
  # Accessibility
  tic()
  with_progress({
    household_cluster_2008 <- household_cluster_2008 %>%
      get_resources(get_accessibility_2000())
  })
  toc()  

  
  # Enregistrement des ressources
  cat("Enregistrement des données dans Data/household_cluster_2008/household_cluster_2008_res.rds\n")
  write_rds(x = household_cluster_2008, file = "Data/household_cluster_2008/household_cluster_2008_res.rds")
  
  cat("Processus terminé avec succès !\n")
}
```

```{r 2021}
# Activer la barre de progression
handlers(global = TRUE)
handlers("progress")


# Vérifier et charger les données
if (file.exists("Data/household_cluster_2021/household_cluster_2021_res.rds")) {
  household_cluster_2021_res <- readRDS("Data/household_cluster_2021/household_cluster_2021_res.rds")
} else {
  plan(sequential)
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    household_cluster_2021 <- household_cluster_2021 %>%
      get_resources(get_gfw_treecover(),
                    get_gfw_lossyear())
  })
  toc()   
  
  # Slope and elevation
  tic()
  with_progress({
    household_cluster_2021 <- household_cluster_2021 %>%
      get_resources(get_nasa_srtm())
  })
  toc()
  
  # Population density
  tic()
  with_progress({
    household_cluster_2021 <- household_cluster_2021 %>%
      get_resources(get_worldpop(years = 2000))
  })
  toc()
  
  # Accessibility
  tic()
  with_progress({
    household_cluster_2021 <- household_cluster_2021 %>%
      get_resources(get_accessibility_2000())
  })
  toc()
  
  # Enregistrement des ressources
  cat("Enregistrement des données dans Data/household_cluster_2021/household_cluster_2021_res.rds\n")
  write_rds(x = household_cluster_2021, file = "Data/household_cluster_2021/household_cluster_2021_res.rds")
  
  cat("Processus terminé avec succès !\n")
}
```

### Extraction des données de mapme.biodiversity

```{r 2008}
library(mapme.biodiversity)
library(tidyverse)
library(progressr) # Pour avoir des barres de progression
library(tictoc)
library(future)
library(sf)
library(rstac)
library(terra)
library(exactextractr)
library(landscapemetrics)

# Vérifier et charger les données
if (file.exists("Data/household_cluster_2008/household_cluster_2008_res.rds")) {
  household_cluster_2008 <- readRDS("household_cluster_2008/household_cluster_2008_res.rds")
} else {
  plan(sequential)
  
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_treecover_area(years = 2000:2023, min_size = 10, min_cover = 35))
  })
  toc()   
  
  # slope
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_slope(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Elevation
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Population density
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Accessibility
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc()   
  
  write_rds(x = household_cluster_2008, file = "Data/household_cluster_2008/household_cluster_2008_res.rds")
}
warnings()

```

```{r 2021}
library(mapme.biodiversity)
library(tidyverse)
library(progressr) # Pour avoir des barres de progression
library(tictoc)
library(future)
library(sf)
library(rstac)
library(terra)
library(exactextractr)
library(landscapemetrics)

# Vérifier et charger les données
if (file.exists("Data/household_cluster_2021/household_cluster_2021_ind.rds")) {
  household_cluster_2021 <- readRDS("Data/household_cluster_2021/household_cluster_2021_ind.rds")
} else {
  plan(sequential)
  
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_treecover_area(years = 2000:2023, min_size = 10, min_cover = 35))
  })
  toc()   
  
  # slope
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_slope(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Elevation
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Population density
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Accessibility
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc()   
  
  
  write_rds(x = household_cluster_2021, file = "Data/household_cluster_2021/household_cluster_2021_ind.rds")
}

warnings()

```

### Chargement et extraction des données sur les précipitations

```{r 2008}

# Vérifier et charger les données
if (file.exists("Data/household_cluster_2008/household_cluster_2008_wc.rds")) {
  household_cluster_2008 <- readRDS("Data/household_cluster_2008/household_cluster_2008_wc.rds")
} else {
  plan(sequential)
 
# Chargement des données de Precipitation
  tic()
  with_progress({
    household_cluster_2008 <- household_cluster_2008 %>%
      get_resources(
        get_worldclim_max_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_min_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_precipitation(years = 1981:2010, resolution = "10m")
      )
  })
  toc() 


# Extraction des données de Precipitation
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_precipitation_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature maximal
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_temperature_max_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature minimal
  tic()
  with_progress({
    household_cluster_2008 <- calc_indicators(
      x = household_cluster_2008, calc_temperature_min_wc(engine = "extract", stats = "mean"))
  })
  toc()  

 write_rds(x = household_cluster_2008, file = "Data/household_cluster_2008/household_cluster_2008_wc.rds")
}

warnings()
```

```{r 2021}
# Chargement des données de Precipitation
  tic()
  with_progress({
    household_cluster_2021 <- household_cluster_2021 %>%
      get_resources(
        get_worldclim_max_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_min_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_precipitation(years = 1981:2010, resolution = "10m")
      )
  })
  toc() 


# Extraction des données de Precipitation
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_precipitation_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature maximal
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_temperature_max_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature minimal
  tic()
  with_progress({
    household_cluster_2021 <- calc_indicators(
      x = household_cluster_2021, calc_temperature_min_wc(engine = "extract", stats = "mean"))
  })
  toc()  

 write_rds(x = household_cluster_2021, file = "Data/household_cluster_2021/household_cluster_2021_wc.rds")
}

warnings()
```

### Calcul de l'indice Standardized Precipitation Evapotranspiration Index (SPEI)

L'indice SPEI est calculé à partir d'une référence à long terme (1981-2010) pour quantifier l'excès ou le manque de pluie. Son calcul se fait à partir des données mensuelles de précipitation et de température minimum et maximum provenant de Worlclim, en utilisant une version améliorée de la méthode Hargreaves ( Modified-Hargreaves methods) définie par Droogers et Allen (2002). La variable sera calculée pour un cercle de 10 km de rayon autour de la coordonnée GPS de la grappe.

```{r 2008}
library(SPEI)
library(gander)
library(ellmer)
library(devtools)
library (fastmap)

# Latitude calculation
household_cluster_2008_wc_spei <- household_cluster_2008 %>% 
  mutate(
    lat = st_coordinates (st_centroid(geometry))[,2]),

# Extract the first cluster's climate time series
row1 <- household_cluster_2008_wc_spei [1,]

# Extract vectors 
tmin <- row1$temperature_min_wc[[1]]$value
tmax <- row1$temperature_max_wc[[1]]$value
prec <- row1$precipitation_wc[[1]]$value
dates <- row1$precipitation_wc[[1]]$datetime
lat <- row1$LATNUM

# Compute reference evapotranspiration (PET) using modified Hargreaves (Droogers & Allen)
pet <- hargreaves(Tmin = tmin, Tmax = tmax, Pre = prec, lat = lat)

# Compute wtaer balance
wb <- prec - pet

# Turn to time series
wb_ts <- ts(wb, start = c(year(min(dates)), month(min(dates))), frequency = 12)

# Compute SPEI (e.g 3-month scale)
spei_obj <- spei(wb_ts, scale = 3)

# Turn into tibble
spei_tbl <- tibble(
  datetime = dates, 
  spei = as.numeric(spei_obj$fitted)
)

# SPEI sous forme de map
household_cluster_2008_wc_spei <- household_cluster_2008_wc_spei %>% 
  mutate(
    spei_wc = mpap(
      list(tmin = temperature_min_wc,
           tmax = temperature_max_wc,
           prec = precipitation_wc,
           lat = latitude),
      function(tmin, tmax, prec, lat) {
        pet <- hargreaves(
          Tmin = tmin$value,
          Tmax = tmax$value,
          Pre = prec$value, 
          lat = lat
        )
        wb <- prec$value - pet
        wb_ts <- ts(wb, start = c(year(min(prec$datetime)), month(min(prec$datetime))), frequency = 12)
        tibble(datetime = prec$datetime, spei = as.numeric(spei_obj$fitted))
      }
    )
  )
```
