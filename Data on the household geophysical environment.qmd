---
title: "Data on the household geophysical environment"
author: "Iriana Razafimahenina"
format: 
  html:
   out-put-file: index.html
   embed-resources: true
   standalone: true
   code-fold: true
  execute:
   warning: false
   error: false
editor: visual
editor-options: 
   chunk_out_type: console
Bibliography: references.bib
editor: visual
editor_options: 
  chunk_output_type: console
---

## Data on the household geophysical environment

Nous allons utiliser le package R mapme.biodiversity (<https://mapme-initiative.github.io/mapme.biodiversity/index.html>) pour charger et extraire les données sur la couverture forestière, la pente et l'altitude, la densité de population, l'accessibilité en 2000.

```{r}
# Library
library(tidyverse) #Manipulation et visualisation des données
library(haven) #Importation des données
library(writexl) #Exportation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(codebook) #Documentation et mise en forme des données 
library(gt) #Mise en forme des tableaux 
library(survey) #Analyse des données d'enquêtes
library(MatchIt) #Matching
library(ggplot2) #Figure
library(labelled) # Manipulation des labels
library(readxl) #Lecture des fichiers excels
library(progressr) # Pour avoir des barres de progression
library(tictoc) # Pour minuter le temps d'exécution
library(mapme.biodiversity)
library(future) # Pour permettre du calcul parallèle
library(lubridate) # Gestion des dates
library(terra) # Manipulation des données raster 
library(geodata)

# Définir le chemin absolu pour ton répertoire local
outdir <- "Data"

# Créer le répertoire si il n'existe pas déjà
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

# Vérifier si le répertoire a bien été créé
if (dir.exists(outdir)) {
  cat("Répertoire créé ou déjà existant : ", outdir)
} else {
  cat("Le répertoire n'a pas pu être créé.")
}
mapme_options(
  outdir = outdir,
  verbose = TRUE
)
```

### Définition des unités d'analyse

L'unité d'analyse de cette études est le ménage. Nous allons charger nos clusters de 2008 et 2021.

```{r clusters}
# Définition du système de coordonnées et de la distance de buffer utilisé
my_crs <- 29702
buffer_dist <- 10000

# Load boundary
contour_mada <- gadm(country = "Madagascar", level = 0, path = "Data") %>%
  st_as_sf() %>%
  st_transform(my_crs)

# Visualisation de la carte avec les contours
tmap_mode("view")

contour_mada %>%
  st_transform(my_crs) %>%
  tm_shape() +
  tm_borders(col = "black")
  
# Load DHS data 
dhs_folder <- "C:/Users/irian/Documents/Statistiques/PA-livelihood-impact-dhs2/Data/DHS_data"

load_data <- function(year, type, dhs_folder) {
  year_folder <- file.path(dhs_folder, paste0("DHS_", year))
  
  # Get the .shp (GPS) and .dta (household) file paths
  if (type == "HR") {
    hr_path <- list.files(year_folder, pattern = ".*HR.*\\.dta$", full.names = TRUE, recursive = TRUE, ignore.case = TRUE)
    if (length(hr_path) == 0) stop("No HR file found for the specified year.")
    out <- read_dta(hr_path) # Lecture du fichier .dta
  } else if (type == "GPS") {
    shp_path <- list.files(year_folder, pattern = "\\.shp$", full.names = TRUE, recursive = TRUE)
    if (length(shp_path) == 0) stop("No GPS file found for the specified year.")
    out <- st_read(shp_path, quiet = TRUE) %>%
      st_transform(my_crs) # Lecture du fichier .shp
  } else {
    stop("Data type unknown, must be HR or GPS")
  }
  return(out) 
}

# Execute the function for a specific year
hr_1997 <- load_data(1997, "HR", dhs_folder)
gps_1997 <- load_data(1997, "GPS", dhs_folder)

hr_2008 <- load_data(2008, "HR", dhs_folder)
gps_2008 <- load_data(2008, "GPS", dhs_folder)

hr_2021 <- load_data(2021, "HR", dhs_folder)
gps_2021 <- load_data(2021, "GPS", dhs_folder)

# Vérification des données GPS
print(gps_1997) 
print(gps_2008)
print(gps_2021)

st_geometry(gps_1997)
st_geometry(gps_2008)
st_geometry(gps_2021)

# Vérification des données GPS
if (!"DHSCLUST" %in% colnames(gps_1997)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}

if (!"DHSCLUST" %in% colnames(gps_2008)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}

if (!"DHSCLUST" %in% colnames(gps_2021)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}

# Générer et afficher les cartes pour chaque année
dhs_map <- function(gps_data, year) {
  tmap_mode("view")
  
  tm_shape(contour_mada) +
    tm_borders(col = "black") +
    tm_shape(gps_data) +
    tm_symbols(
      col = "URBAN_RURA", 
      palette = c("blue", "green"), 
      title.col = "Zone",
      size = 0.5,
      shape = 21,
      border.col = "black"
    ) +
    tm_layout(title = paste("DHS Clusters -", year))
}

# Création des cartes
dhs_map(gps_1997, 1997)
dhs_map(gps_2008, 2008)
dhs_map(gps_2021, 2021)

```

### Chargement des données de mapme.biodiversity

-   Couvert forestier en 2000 (Hansen et al.2013)

-   Pente et altitude (NASA SRTM)

-   Densité de population en 2000 (Worldpop)

-   Accessibilité en 2000 (JRC, Uchida et Nelson 2011)

Nous allons maintenant charger les données géophysiques des ménages à partir de mapme.biodiversity

```{r}
library(mapme.biodiversity)
library(tidyverse)
library(progressr)
library(tictoc)
library(future)
library(sf)
library(rstac)
library(terra)

# Activer la barre de progression
handlers(global = TRUE)
handlers("progress")

# S'assurer que le CRS est en WGS84 pour compatibilité
#if (st_crs(gps_2008)$epsg != 4326) {
# gps_2008 <- st_transform(gps_2008, crs = 4326)
#}

# Créer un buffer autour de chaque point pour former des polygones (10 km ici)
gps_2008 <- st_buffer(gps_2008, dist = 10000)

# Définir les ressources à télécharger (corrigé)
gps_2008 <- gps_2008 %>%
  get_resources(get_gfw_treecover())

gps_2008 <- gps_2008 %>%  
  get_resources(get_gfw_lossyear())

gps_2008 <- gps_2008 %>% 
  get_resources(get_nasa_srtm())

gps_2008 <- gps_2008 %>% 
  get_resources(get_worldpop(years = 2000))

gps_2008 <- gps_2008 %>%  
  get_resources(get_accessibility_2000())

# Extraire les ressources sans changer le type de géométrie
plan(sequential)

if (file.exists("Data/donnees_geo_menages/2008/gps_2008.rds")) {
  gps_2008 <- readRDS("Data/donnees_geo_menages/2008/gps_2008.rds")
} else {
  
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_treecover_area(years = 2000:2023, min_size = 10, min_cover = 35))
  })
  toc()   # 362.75 sec
  
  # slope
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_slope(engine = "extract", stats = "mean"))
  })
  toc() # 316.09 sec
  
  # Elevation
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc() # 662.1 sec
  
  # Population density
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc() # 47.42 sec
  
  # Accessibility
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc() # 37.81 sec
  
  # Convertir les polygones en points en utilisant les centroids
  gps_2008 <- st_centroid(gps_2008)
  
  # Enregistrement des données sous forme de points (dans le même dataframe gps_2008)
  write_rds(gps_2008, "Data/donnees_geo_menages/2008/gps_2008.rds")
  cat("✅ Données enregistrées dans gps_2008.rds avec géométries en POINT et indicateurs ajoutés.\n")
}
```

```{r 2021}
# Activer la barre de progression
handlers(global = TRUE)
handlers("progress")

# Créer un buffer autour de chaque point pour former des polygones (10 km ici)
gps_2021 <- st_buffer(gps_2021, dist = 10000)

# Définir les ressources à télécharger (corrigé)
gps_2021 <- gps_2021 %>%
  get_resources(get_gfw_treecover())

gps_2021 <- gps_2021 %>%  
  get_resources(get_gfw_lossyear())

gps_2021 <- gps_2021 %>% 
  get_resources(get_nasa_srtm())

gps_2021 <- gps_2021 %>% 
  get_resources(get_worldpop(years = 2000))

gps_2021 <- gps_2021 %>%  
  get_resources(get_accessibility_2000())

# Extraire les ressources sans changer le type de géométrie
plan(sequential)

if (file.exists("Data/donnees_geo_menages/2021/gps_2021.rds")) {
  gps_2021 <- readRDS("Data/donnees_geo_menages/2021/gps_2021.rds")
} else {
  
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_treecover_area(years = 2000:2023, min_size = 10, min_cover = 35))
  })
  toc()   # 1519.17 sec
  
  # slope
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_slope(engine = "extract", stats = "mean"))
  })
  toc() # 1464.58 sec
  
  # Elevation
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc() # 1792.73 sec
  
  # Population density
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc() # 102.91 sec
  
  # Accessibility
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc() # 39.22 sec
  
  # Convertir les polygones en points en utilisant les centroids
  gps_2021 <- st_centroid(gps_2021)
  
  # Enregistrement des données sous forme de points (dans le même dataframe gps_2008)
  write_rds(gps_2021, "Data/donnees_geo_menages/2021/gps_2021.rds")
cat("✅ Données enregistrées dans gps_2021.rds avec géométries en POINT et indicateurs ajoutés.\n")

}
```

### Chargement et extraction des données sur les précipitations

```{r 2008}

# Vérifier et charger les données
if (file.exists("Data/donnees_geo_menages/2008/gps_2008_wc.rds")) {
  gps_2008 <- readRDS("Data/donnees_geo_menages/2008/gps_2008_wc.rds")
} else {
  plan(sequential)
 
# Chargement des données de Precipitation
  tic()
  with_progress({
    gps_2008 <- gps_2008 %>%
      get_resources(
        get_worldclim_max_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_min_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_precipitation(years = 1981:2010, resolution = "10m")
      )
  })
  toc() 


# Extraction des données de Precipitation
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_precipitation_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature maximal
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_temperature_max_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature minimal
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_temperature_min_wc(engine = "extract", stats = "mean"))
  })
  toc()  

 write_rds(x = gps_2008, file = "Data/donnees_geo_menages/2008/gps_2008_wc.rds")
}

warnings()
```

```{r 2021}
# Vérifier et charger les données
if (file.exists("Data/donnees_geo_menages/2021/gps_2021_wc.rds")) {
  gps_2021 <- readRDS("Data/donnees_geo_menages/2021/gps_2021_wc.rds")
} else {
  plan(sequential)

# Chargement des données de Precipitation
  tic()
  with_progress({
    gps_2021 <- gps_2021 %>%
      get_resources(
        get_worldclim_max_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_min_temperature(years = 1981:2010, resolution = "10m"),
        get_worldclim_precipitation(years = 1981:2010, resolution = "10m")
      )
  })
  toc() 


# Extraction des données de Precipitation
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_precipitation_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature maximal
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_temperature_max_wc(engine = "extract", stats = "mean"))
  })
  toc()   
  
  # Temperature minimal
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_temperature_min_wc(engine = "extract", stats = "mean"))
  })
  toc()  

 write_rds(x = gps_2021, file = "Data/donnees_geo_menages/2021/gps_2021_wc.rds")
}

warnings()
```

### Calcul de l'indice Standardized Precipitation Evapotranspiration Index (SPEI)

L'indice SPEI est calculé à partir d'une référence à long terme (1981-2010) pour quantifier l'excès ou le manque de pluie. Son calcul se fait à partir des données mensuelles de précipitation et de température minimum et maximum provenant de Worlclim, en utilisant une version améliorée de la méthode Hargreaves ( Modified-Hargreaves methods) définie par Droogers et Allen (2002). La variable sera calculée pour un cercle de 10 km de rayon autour de la coordonnée GPS de la grappe.

```{r 2008}
library(SPEI)
library(gander)
library(ellmer)
library(devtools)
library (fastmap)

# Latitude calculation
gps_2008_wc_spei <- gps_2008 %>% 
  mutate(
    lat = st_coordinates (st_centroid(geometry))[,2])

# Extract the first cluster's climate time series
row1 <- gps_2008_wc_spei [1,]

# Extract vectors 
tmin <- row1$temperature_min_wc[[1]]$value
tmax <- row1$temperature_max_wc[[1]]$value
prec <- row1$precipitation_wc[[1]]$value
#dates <- row1$temperature_min_wc[[1]]$datetime
dates_tmin <- row1$temperature_min_wc[[1]]$datetime
dates_tmax <- row1$temperature_max_wc[[1]]$datetime
dates_prec <- row1$precipitation_wc[[1]]$datetime
lat <- row1$LATNUM

# Synchronize vectors by date
data_tmin <- data.frame(date = dates_tmin, tmin = tmin)
data_tmax <- data.frame(date = dates_tmax, tmax = tmax)
data_prec <- data.frame(date = dates_prec, prec = prec)
data_merged <- reduce(list(data_tmin, data_tmax, data_prec), merge, by = "date")

# Extract synchronized vectors
tmin_synced <- data_merged$tmin
tmax_synced <- data_merged$tmax
prec_synced <- data_merged$prec
dates_synced <- data_merged$date


# Compute reference evapotranspiration (PET) using modified Hargreaves (Droogers & Allen)
pet <- hargreaves(Tmin = tmin_synced, Tmax = tmax_synced, Pre = prec_synced, lat = lat)

# Compute wtaer balance
wb <- prec_synced - pet


# Turn to time series
wb_ts <- ts(wb, start = c(year(min(dates_synced)), month(min(dates_synced))), frequency = 12)

# Compute SPEI (e.g 3-month scale)
spei_obj <- spei(wb_ts, scale = 3)

# Turn into tibble
spei_tbl <- tibble(
  datetime = dates_synced, 
  spei = as.numeric(spei_obj$fitted)
)

# SPEI sous forme de map
gps_2008_wc_spei <- gps_2008_wc_spei %>% 
  mutate(
    spei_wc = pmap(
      list(tmin = temperature_min_wc,
           tmax = temperature_max_wc,
           prec = precipitation_wc,
           lat = lat),
      function(tmin, tmax, prec, lat) {
        # Synchronize vectors by date within the function
        data_tmin <- data.frame(date = tmin$datetime, tmin = tmin$value)
        data_tmax <- data.frame(date = tmax$datetime, tmax = tmax$value)
        data_prec <- data.frame(date = prec$datetime, prec = prec$value)
        data_merged <- reduce(list(data_tmin, data_tmax, data_prec), merge, by = "date")
        
        tmin_synced <- data_merged$tmin
        tmax_synced <- data_merged$tmax
        prec_synced <- data_merged$prec
        dates_synced <- data_merged$date
        
        pet <- hargreaves(
          Tmin = tmin_synced,
          Tmax = tmax_synced,
          Pre = prec_synced, 
          lat = lat
        )
        wb <- prec_synced - pet
        wb_ts <- ts(wb, start = c(year(min(prec$dates_synced)), month(min(prec$date_synced))), frequency = 12)
        tibble(datetime = date_synced, spei = as.numeric(spei_obj$fitted))
      }
    )
  )

length(tmin)
length(tmax)


sum(is.na(tmin))
sum(is.na(tmax))

length(dates)
length(spei_obj$fitted)

```
