---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Treatment assignation

## Objectifs

Nous classons les clusters d'enquêtes DHS (1997, 2008 et 2021) par rapport à leur distance aux aires protégées et à leur localisation en zone rurale ou urbaine. Le résultat attendu est le suivant :

-   [Groupe de traitement]{.underline}: Ménages localisées dans les clusters à moins de 10 km des aires protégées créées à partir de 2008 dans les zones rurales

-   [Groupe de contrôle]{.underline}: Ménages localisées dans les clusters à plus de 10 km des aires protégées dans les zones rurales

-   [Groupe à exclure]{.underline}: Ménages localisées dans les clusters à moins de 10 km des aire protégées créées avant 2008 et dans la zone urbaine

## Chargement des coordonnées GPS des clusters d'enquête

Avant de charger les données GPS de 1997, 2008, 2021, nous précisons les coordonnées GPS utilisées. Les coordonnées GPS, comme la plupart des données ouvertes distribuées sur Internet, sont en WGS 84 (codé EPSG : 4326). Nos données sont aussi traitées en 4326. Toutefois, uniquement pour le calcul des surfaces ou des distances, on va utiliser le système de projection officiel de Madagascar, qui est le Laborde (EPSG : 29702). Une fois les données chargées, on fusionne les trois jeux de données en un seul puis visualisés sur une carte.

```{r}
#| fig-cap: "Grappes d'enquêtes DHS par rapport aux AP existantes en 2008"

library(tidyverse) #Manipulation et visualisation des données
library(haven)
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(gt) #Mise en forme des tableaux 
library(geodata) # Pour avoir le contour de Madagascar
library(writexl) # Pour faire une sortie sous Excel
library(units)
library(leaflet) # Pour faire une cartographie interactive
library(readxl)

# Systèmes de coordonnées de référence 
standard_crs <- 4326
mdg_crs <- 29702 

# On charge les données
gps_1997_initial <- st_read("data/raw/dhs/DHS_1997/MDGE32FL/MDGE32FL.shp")
gps_2008_initial <- st_read("data/raw/dhs/DHS_2008/MDGE53FL/MDGE53FL.shp") 
gps_2021_initial <- st_read("data/raw/dhs/DHS_2021/MDGE81FL/MDGE81FL.shp")

# Set for interactive viewing
tmap_mode("view")

bind_rows(gps_1997_initial, gps_2008_initial, gps_2021_initial) |> 
  tm_shape() + 
  tm_dots() +
  tm_facets("DHSYEAR") 
```

Nous obtenons une carte distincte pour chaque année d'enquête. Sur chaque carte figure des points, dans laquelle chaque point représente un cluster d'enquête, correspondant aux coordonnées GPS fournies par DHS.

## Vérification des données gps des clusters

On vérifie que les coordonnées GPS sont bien dans le pays.

```{r}
# Fonction qui vérifie que les coordonnées ne sont pas nulles
check_coordinates <- function(dhs_gps, country_polygon, negate = FALSE) {
  dhs_gps %>%
    filter(LONGNUM != 0 | LATNUM != 0)
}

gps_1997 <- check_coordinates(gps_1997_initial) 
gps_2008 <- check_coordinates(gps_2008_initial) 
gps_2021 <- check_coordinates(gps_2021_initial) 
```

Les coordonnées GPS de 9 clusters de l'enquête 2008 n'ont pas de coordonnées valides (0,0). Il en manque également un en 1997.

## Chargement des données AP

Les données utilisées sont les données du Système des Aires Protégées à Madgascar (SAPM) obtenues auprès du Service de la Gouvernance des Aires Protégées (SGAP) du Ministère de l'Environnement et de Développement Durable de Madagascar (MEDD). La vérification des dates de création des aires protégées est actuellement en cours. En attendant, nous utilisons la version officielle de 2017, sur laquelle on a corrigé des anomalies topologiques.

Les données de SAPM sont codées en EPSG 9001, que l'on transforme en 4326 pour uniformiser les coordonnées GPS que nous utilisons. Nous le visualisons par la suite à travers une carte.

```{r}
library(wdpar)

wdpa <- wdpa_read("data/raw/WDPA_WDOECM_Jul2025_Public_MDG.zip") %>%
  wdpa_clean() |> 
  filter(STATUS == "Designated") %>%
  mutate(MARINE = recode(MARINE,
                           "terrestrial" = "Terrestre",
                         "marine" = "Marine",
                         "partial" = "Mixte"))

# Load boundary
contour_mada <- gadm(country = "Madagascar", level = 0, path = "data") %>%
  st_as_sf() %>%
  st_set_crs(standard_crs)

# Visualisation
tmap_mode("view")

map <- tm_shape(wdpa) +
  tm_polygons(
    fill = "MARINE",
    fill.scale = tm_scale(
      values = c(
        "Terrestre" = "#228B22",
        "Marine" = "#1E90FF",
        "Mixte" = "gray"
      )
    ),
    id = "ORIG_NAME",
    popup.vars = c("Superficie (ha)" = "REP_AREA")) +
  tm_shape(contour_mada) +
  tm_borders(
    col = "black",
    lwd = 0.5) +
  tm_scalebar(position = c("left", "bottom")) + 
  tm_layout(legend.outside = TRUE)

# Convertir la carte tmap en utilisant Leaflet pour personnaliser la carte interactive
leaflet_map <- tmap_leaflet(map)

# Ajouter un titre et une source 
leaflet_map %>% 
  addControl("<b> Aires protégées de Madagascar</b><br/>Source: WDPA, 2024", position = "topright")
```

On peut aussi générer un format tabulaire pour visualiser les données.

```{r}

# Tableau complet
wdpa_tb <- wdpa %>%
  st_drop_geometry()

dir.create("derived")

write_xlsx(wdpa_tb, "data/derived/WDPA_WDOECM_Jul2025_Public_MDG.xlsx")

wdpa %>%
  DT::datatable()

# Tableau personnalisé 
wdpa_tb_sel <- wdpa_tb %>%
  select(WDPAID, ORIG_NAME, DESIG, DESIG_TYPE, IUCN_CAT, MARINE, REP_AREA, STATUS, STATUS_YR, GOV_TYPE, OWN_TYPE, MANG_AUTH, VERIF, GEOMETRY_TYPE, AREA_KM2)

write_xlsx(wdpa_tb_sel, "data/derived/WDPA_selection_MDG.xlsx")

DT::datatable(wdpa_tb_sel)
```

## Sélection des parties terrestres des AP

Nous commençons par charger les limites administratives nationales de Madagascar, dont on attribue un système de coordonnées 4326. Ces limites sont ensuite croisées avec les aires protégées de SAPM pour extraire uniquement les zones terrestres situées à l'intérieur du pays. Après la transformation au coordonnées de Laborde (29702), nous calculons la superficie de chaque aire protégée terrestre, et visualiser le tout sur une carte.

On garde que les éléments de SAPM qui sont contenu à l'intérieur des aires protégées de Madagascar.

```{r}

# Load boundary
contour_mada <- gadm(country = "Madagascar", level = 0, path = "data") %>%
  st_as_sf() %>%
  st_set_crs(standard_crs)

# Intersection des SAPM avec la limite de Madagascar
wdpa_terrestre <- wdpa %>% 
  st_transform(crs = standard_crs) %>%
  st_make_valid()%>%
  st_intersection(contour_mada)%>%
  st_transform(mdg_crs) %>%
  mutate(`REP_AREA` = as.numeric(st_area(.)) / 10000) %>%
  st_transform(standard_crs)

tm_shape(contour_mada) +
  tm_borders() +
tm_shape(wdpa_terrestre) +
  tm_polygons(fill =  "green", 
              id = "ORIG_NAME",
              popup.vars = c("Superficie terrestre (ha)" = "REP_AREA")) +
  tm_scalebar(position = c("left", "bottom")) + 
  tmap_options(check_and_fix = TRUE) +
  tm_title("Aires protégées terrestres de Madagascar</b><br/>Source: WDPA, 2024") +
  tm_layout(legend.outside = TRUE)

```

::: callout-warning
On a un problème avec les unités pour les surfaces dans la carte.
:::

En examinant la base de donnée, nous avons constaté qu'il manquait la date de création de l'une des aires protégées. Nous allons donc ajouter l'année de création de l'aire protégée Complexe des aires protégées Ambohimirahavavy Marivorahona, créée par le décret 2015-782 du 28 avril 2015 [@goodman2018].

```{r}
# Ajout de la date de création du complexe des aires protégées Ambohimirahavavy Marivorahona 

wdpa_terrestre_mod <- wdpa_terrestre %>%
  mutate(STATUS_YR = ifelse(WDPAID == 555697871, 2015, STATUS_YR))

# Sauvegarder le shapefile modifié 
st_write(wdpa_terrestre_mod, "data/derived/wdpa_terrestre_mod.shp")

```

## Création de buffer pour les AP avant et après 2008

On travaille toujours avec les portions terrestres des AP.

Pour analyser l'impact des aires protégées selon leur période de création, on spécifie les aires protégées créées avant 2008 et à partir de 2008. On applique ensuite une zone tampon de 10 km autour de chaque groupe d'aires protégées. Chaque groupe a été reprojeté dans le système de projection officiel de Madagascar, qui est le Laborde (EPSG : 29702) pour les calculs de distances. Nous créons ensuite une carte pour visualiser les aires protégées et leurs zones d'influence.

```{r}
#| fig-cap: "Aires protégées du WDPA par période de création"

# Buffer de 10 km
buffer_dist <- 10000 

# Spécification des aires protégées avant 2008
wdpa_before_2008 <- wdpa_terrestre_mod %>%
  filter(STATUS_YR < 2008)

# Spécification des aires protégées après 2008
wdpa_from_2008 <- wdpa_terrestre_mod %>%
  filter(STATUS_YR >= 2008)

# Créer des buffers de 10 km autour des AP
buffer_10km_before_2008 <- wdpa_before_2008 %>%
  st_transform(mdg_crs) %>%
  st_buffer(dist = buffer_dist) %>%
  st_make_valid() %>%
  st_union() %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(standard_crs)

buffer_10km_from_2008 <- wdpa_from_2008  %>%
  st_transform(mdg_crs) %>%
  st_buffer(dist = buffer_dist) %>% 
  st_make_valid() %>%
  st_union() %>%
  st_as_sf() %>%
  st_make_valid() %>%
  st_transform(standard_crs)

# Visualisation des cartes 
tm_shape(wdpa_before_2008) +
tm_polygons(fill = "blue", 
            col =  "black", 
            fill_alpha = 0.5) +
tm_shape(buffer_10km_from_2008) +
tm_borders(col = "darkgreen", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +
tm_shape(buffer_10km_before_2008) +
tm_borders(col = "blue", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +
tm_shape(wdpa_from_2008) +
tm_polygons(fill = "darkgreen", 
            col = "black", 
            fill_alpha = 0.5) +
tm_add_legend(type = "polygons", fill = c("blue", "darkgreen"), labels = c("avant 2008", "après 2008")) +
  tm_title("Aires protégées du WDPA par période de création") +
  tm_layout(
    legend.outside = TRUE, 
    legend.position = c("left", "top"),
    frame = FALSE,
    legend.title.size = 1.2,
    legend.text.size = 0.8
  ) +
  tm_compass(type = "8star", position = c("right", "top")) +
  tm_scalebar(position = c("right", "bottom"))
```

On agrège les données pour chaque groupe, en calculant le nombre total d'aires protégées et leur superficie totale, que l'on présente sous forme de tableau.

```{r}
# Definition de la fonction
pivot_year <- 2008

summary_table <- wdpa_terrestre_mod %>%
  st_drop_geometry() %>%
  mutate(
    Creation_Period = case_when(
      STATUS_YR < pivot_year ~ paste("Avant", pivot_year),
      STATUS_YR >= pivot_year ~ paste("A partir de", pivot_year)
    )) %>%
  group_by(Creation_Period) %>%
  summarise(
    Count = n(),
    Area = sum(REP_AREA, na.rm = TRUE) / 100,  # Convert hectares to km²
    .groups = 'drop'
  )


# Formatage du tableau avec gt
gt_table <- gt(summary_table) %>%
  tab_header(
    title = paste("Aires protégées par période de création (Année pivot = ", pivot_year, ")"),
    subtitle = "Zones terrestres uniquement"
  ) %>%
  cols_label(
    Creation_Period = "Période de Création",
    Count = "Nombre d'AP",
    Area = "Surface"
  ) %>%
  fmt_number(
    columns = c(Count, Area),
    decimals = 0
  )

gt_table
```

## Classification des clusters

Les grappes d'enquête sont classées selon leur proximité aux aires protégées créées avant 2008 et à partir de 2008. A l'aide de la fonction classify_clusters(), nous catégorisons chaque cluster en trois groupes: traitement, contrôle ou exclu, selon leur localisation par rapport aux aires protégées et leur statut urbain ou rural. Cette classification est appliquée aux clusters de 1997, 2008 et 2021, puis les résultats sont fusionnés. Nous créons ensuite une carte par année d'étude pour visualiser la localisation des aires protégées et la répartition spatiale des clusters selon leur groupe.

```{r}
#| fig-cap: "Grappes d'enquêtes DHS par rapport aux aires protégées existantes"

classify_clusters <- function(cluster_gps, buffer_before, buffer_from,
                              label_treatment = "Treatment",
                              label_excluded = "Excluded",
                              label_control = "Control") {
  cluster_gps %>%
    # Identifier le groupe de traitement: ménages proche d'AP créées après 2008
    mutate(
      groupe = case_when(
        st_within(geometry, buffer_from, sparse = FALSE)[, 1] & # SI près AP récente
          !st_within(geometry, buffer_before, sparse = FALSE)[, 1] & # ET pas près AP ancienne
          URBAN_RURA == "R" ~ label_treatment, # ET rurale, ALORS traitement
        st_within(geometry, buffer_before, sparse = FALSE) [,1] | # SI près AP ancienne
          URBAN_RURA == "U" ~ label_excluded, # OU urbaine, ALORS exclu
        TRUE ~ label_control # SINON contrôle
      )
    ) 
}

# On classe pour 1997
gps_1997_class <- classify_clusters(cluster_gps = gps_1997,
                                    buffer_before = buffer_10km_before_2008,
                                    buffer_from = buffer_10km_from_2008)

gps_2008_class <- classify_clusters(cluster_gps = gps_2008,
                                    buffer_before = buffer_10km_before_2008,
                                    buffer_from = buffer_10km_from_2008)

gps_2021_class <- classify_clusters(cluster_gps = gps_2021,
                                    buffer_before = buffer_10km_before_2008,
                                    buffer_from = buffer_10km_from_2008)


gps_all_class <- bind_rows(
  gps_1997_class,
  gps_2008_class,
  gps_2021_class
)

# Créer un plot pour visualiser la carte des AP avec les clusters
tm_shape(buffer_10km_from_2008) +
  tm_borders("green", 
             lwd = 2, 
             lty = "dashed", 
             fill.legend = tm_legend_hide()) +  
  tm_shape(buffer_10km_before_2008) +
  tm_borders("darkgreen", 
             lwd = 2, 
             lty = "dashed", 
             fill.legend = tm_legend_hide()) +
  tm_shape(wdpa_from_2008) +
  tm_polygons(fill = "green", 
              fill_alpha = 0.5,
              col = "black", 
              fill.legend = tm_legend(title = "à partir de 2008", position = tm_pos_in("right", "top"))) +
  tm_shape(wdpa_before_2008) +
  tm_polygons(fill = "darkgreen", 
              fill_alpha = 0.5, 
              col =  "black", 
              fill.legend = tm_legend(title = "avant 2008", position = tm_pos_in("right", "top"))) +
  tm_shape(gps_all_class) +
  tm_symbols(
    fill = "groupe", 
    fill.legend = tm_legend(title = "Groupes"),
    fill.scale = tm_scale(values = c("Treatment" = "red", "Control" = "blue", "Excluded" = "gray")),
     size = 0.5,
    shape = 21
  ) +
  tm_facets("DHSYEAR") +
  tm_add_legend(type = "polygons", 
                fill = c("green", "darkgreen"), 
                labels = c("à partir de 2008", "avant 2008")) +
  tm_layout(
    legend.outside = TRUE, 
    legend.position = c("left", "top"),
    frame = FALSE
  ) +
  tm_scalebar(position = c("left", "bottom"))
```

Nous produisons un tableau récapitulatif du nombre de grappes d'enquête classées dans chaque groupe pour les années 1997, 2008 et 2021. Afin de faciliter le comptage et la transformation en tableau, nous supprimons les données spatiales pour ne conserver que les informations attributaires (année d'enquête "DHSYEAR" et groupe de classification "groupe").

```{r}
# Function to read DHS data for the specified year and identifier
load_dhs_data <- function(dhs_folder, year, identifier) {
  folder_pattern <- paste0(".*", year, ".*", identifier)
  
  matching_folder <- list.dirs(dhs_folder, full.names = TRUE, recursive = TRUE) %>%
    keep(~ str_detect(.x, folder_pattern))
  
  if (length(matching_folder) == 0) {
    stop("No folder found for the specified year and identifier.")
  }
  
  if (identifier == "GE") {
    file_pattern <- "\\.shp$"
    data_loader <- function(file) st_read(file, quiet = TRUE)
  } else {
    file_pattern <- "\\.[Dd][Tt][Aa]$"
    data_loader <- read_dta
  }
  
  target_file <- list.files(matching_folder, pattern = file_pattern, full.names = TRUE)
  
  if (length(target_file) == 0) {
    stop("No valid file found in the folder.")
  }
  
  data <- data_loader(target_file)
  
  return(data)
}

dhs_folder <- "data/raw/dhs"

# Load geographic data for 2021 and 2008
gps_2021 <- load_dhs_data(dhs_folder, 2021, "GE")
gps_2008 <- load_dhs_data(dhs_folder, 2008, "GE")

# Identify treatment survey clusters --------------------------

# Identifier les grappes proches des AP ----------------------------------

find_nearby_gps <- function(gps_data, wdpa_data, distance_km, creation_year, after = TRUE) {
  if (after) {
    selected_pas <- wdpa_data %>% filter(STATUS_YR >= creation_year)
  } else {
    selected_pas <- wdpa_data %>% filter(STATUS_YR < creation_year)
  }
  
  selected_pas <- selected_pas %>% st_make_valid()
  
  gps_data <- st_transform(gps_data, st_crs(selected_pas))
  
  buffered_pas <- st_buffer(selected_pas, dist = distance_km * 1000) %>% st_make_valid()
  
  merged_buffer <- st_union(buffered_pas) %>% st_make_valid()
  
  nearby_gps <- gps_data %>%
    mutate(nearby_pa = st_within(geometry, merged_buffer, sparse = FALSE)[, 1])
  return(nearby_gps)
}

# Identifier les groupes de traitement et d'exclusion
treatment_clusters_2021 <- find_nearby_gps(gps_2021, wdpa, 10, 2008, after = TRUE)
exclusion_clusters_2021 <- find_nearby_gps(gps_2021, wdpa, 10, 2008, after = FALSE)

treatment_clusters_2008 <- find_nearby_gps(gps_2008, wdpa, 10, 2008, after = TRUE)
exclusion_clusters_2008 <- find_nearby_gps(gps_2008, wdpa, 10, 2008, after = FALSE)

# Load household data -------------------------------------------------------

household_2021 <- load_dhs_data(dhs_folder, 2021, "HR")
household_2008 <- load_dhs_data(dhs_folder, 2008, "HR")

# Function to calculate clusters and households for different categories  ---------------------------
clusters_and_households <- function(gps_data, hr_data, treatment_clusters, exclusion_clusters, year) {
  clusters_treatment <- treatment_clusters %>% 
    filter(nearby_pa) %>% 
    pull(DHSCLUST)
  clusters_exclusion <- exclusion_clusters %>% 
    filter(nearby_pa) %>% 
    pull(DHSCLUST)
  clusters_control <- gps_data %>%
    filter(!DHSCLUST %in% c(clusters_treatment, clusters_exclusion)) %>%
    pull(DHSCLUST)
  
  total_clusters <- nrow(gps_data)
  total_households <- nrow(hr_data)
  
  households_treatment <- hr_data %>%
    filter(hv001 %in% clusters_treatment) %>%
    nrow()
  
  households_exclusion <- hr_data %>%
    filter(hv001 %in% clusters_exclusion) %>%
    nrow()
  
  households_control <- hr_data %>%
    filter(hv001 %in% clusters_control) %>%
    nrow()
  
  tibble(
    année = year,
    `Grappes traitement` = length(clusters_treatment),
    `Ménages traitement` = households_treatment,
    `Grappes exclusion` = length(clusters_exclusion),
    `Ménages exclusion` = households_exclusion,
    `Grappes contrôle` = length(clusters_control),
    `Ménages contrôle` = households_control,
    `Total des grappes` = total_clusters,
    `Total des ménages` = total_households
  )
}

# Calculate results for all observations
results_all <- list(
  clusters_and_households(gps_2021, household_2021, treatment_clusters_2021, exclusion_clusters_2021, 2021),
  clusters_and_households(gps_2008, household_2008, treatment_clusters_2008, exclusion_clusters_2008, 2008)
) %>%
  bind_rows()

# Calculate results for rural households only
results_rural <- list(
  clusters_and_households(
    gps_2021 %>% filter(URBAN_RURA == "R"),
    household_2021 %>% filter(hv025 == 2),
    treatment_clusters_2021 %>% filter(URBAN_RURA == "R"),
    exclusion_clusters_2021 %>% filter(URBAN_RURA == "R"),
    2021
  ),
  clusters_and_households(
    gps_2008 %>% filter(URBAN_RURA == "R"),
    household_2008 %>% filter(hv025 == 2),
    treatment_clusters_2008 %>% filter(URBAN_RURA == "R"),
    exclusion_clusters_2008 %>% filter(URBAN_RURA == "R"),
    2008
  )
) %>%
  bind_rows()

# Add a column for categorization before selecting the columns
combined_results <- bind_rows(
  results_all %>% mutate(Type = "Toutes observations"),
  results_rural %>% mutate(Type = "Zones rurales")  # Change label to "Zones rurales"
)

# Display the results using gt with improved layout and row groups
gt_table <- gt(combined_results) %>%
  tab_header(
    title = "Nombre de grappes et de ménages d'enquêtes DHS classés selon leur proximité avec des aires protégées"
  ) %>%
  cols_label(
    année = "Année",
    `Grappes traitement` = "Traitement",
    `Grappes exclusion` = "Exclusion",
    `Grappes contrôle` = "Contrôle",
    `Total des grappes` = "Total",
    `Ménages traitement` = "Traitement",
    `Ménages exclusion` = "Exclusion",
    `Ménages contrôle` = "Contrôle",
    `Total des ménages` = "Total"
  ) %>%
  tab_spanner(
    label = "Grappes",
    columns = c(`Grappes traitement`, `Grappes exclusion`, `Grappes contrôle`, `Total des grappes`)
  ) %>%
  tab_spanner(
    label = "Ménages",
    columns = c(`Ménages traitement`, `Ménages exclusion`, `Ménages contrôle`, `Total des ménages`)
  ) %>%
  fmt_number(
    columns = c(`Grappes traitement`, `Grappes exclusion`, `Grappes contrôle`, `Total des grappes`,
                `Ménages traitement`, `Ménages exclusion`, `Ménages contrôle`, `Total des ménages`),
    decimals = 0,
    use_seps = TRUE,
    sep_mark = " ",
    dec_mark = ","
  ) %>%
  fmt_number(
    columns = "année",
    decimals = 0,
    use_seps = FALSE
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  cols_width(
    `Total des ménages` ~ px(150)
  ) %>%
  tab_options(
    table.width = pct(100)
  ) %>%
  tab_footnote(
    footnote = md("**Traitement**: Observations situées à moins de 10 km des AP créées à partir de 2008. **Exclusion**: Observations situées à moins de 10 km des AP créées avant 2008. **Contrôle**: Autres observations."),
    locations = cells_title(groups = "title")
  ) %>%
  tab_row_group(
    label = "Toutes observations",
    rows = Type == "Toutes observations"
  ) %>%
  tab_row_group(
    label = "Zones rurales",
    rows = Type == "Zones rurales"  # Ensure consistency with the new label
  ) %>%
  cols_hide(
    columns = "Type"  # Hide the Type column after using it for row grouping
  )

# Display the formatted gt table
gt_table

```

## Enregistrement des variables classifiées

Les informations essentielles sur la classification des grappes d'enquête sont extraites et enregistrées dans un fichier csv en vue d'une utilisation ultérieure. Seules les informations nécessaires à l'identification des grappes et à leur groupe de traitement sont conservées, excluant les données géographiques et les variables non pertinentes.

```{r}
all_class <- gps_all_class %>%
  select(DHSYEAR, DHSCLUST, GROUP = groupe)

write_csv(wdpa_before_2008, "data/derived/wdpa_before_2008.csv")
write_csv(wdpa_from_2008, "data/derived/wdpa_from_2008.csv")
write_csv(all_class, "data/derived/cluster_treatment_classification.csv")
```
