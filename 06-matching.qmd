---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Matching

## Objectif 

Le document illustre l'application de la méthode de matching dans l'analyse, en maximisant la comparabilité entre les groupes de traitement et de contrôle en termes de caractéristiques observables @ho2007.

## Méthodes

Nous réalisons le matching à l'aide de la méthode genetic matching, en utilisant la fonction GenMatch() du package R MatchIt. Cette méthode combine les variables de matching en une seule mesure unique de distance "Mahalanobis distance matching". Cette distance mesurera la différence entre les unités des groupes appariés pour quantifier la similitude entre les deux groupes d'observations, tout en tenant compte des corrélations entre les covariables et de leurs covariances @diamond2013.

Dans un premier temps, nous appliquons la fonction GenMatch() pour rechercher la combinaison optimale de poids pour chaque covariable afin de maximiser l'équilibre entre le groupe de traitement et de contrôle. Nous obtenons une matrice de poids mais aucune paire n'est encore formée. Dans un second temps, nous utilisons la fonction matchIt(), en intégrant la pondération trouvée auparavant, afin de constituer les paires entre les unités traitées et non traitées.

```{r 2008}
# Library 
library(tidyverse) #Manipulation et visualisation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(MatchIt) #Matching
library(ggplot2) #Figure
library(rbounds)
library(rgenoud)
library(Matching)

# Load data 
hr_2008_final <- readRDS("data/derived/hr_2008_final.rds")

# Matching variables 
matching_variables <- c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")

# Specifying binary variables in the column GROUP
matching_2008 <- hr_2008_final %>%
  filter(GROUP %in% c("Treatment", "Control")) %>%
  mutate(
    treatment = if_else(GROUP == "Treatment", 1, 0)) %>%
  drop_na(all_of(matching_variables))

# Generate a matrix for GenMatch 
X_match <- as.data.frame(st_drop_geometry(matching_2008[, c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")]))

# Optimum combination search for 2008
set.seed(123)

if (file.exists("data/derived/gen_match_model_2008.rds")) {
  matching_result_2008 <- readRDS("data/derived/gen_match_model_2008.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  gen_match_model_2008 <- GenMatch(
    Tr = matching_2008$treatment,
    X = X_match,
    BalanceMatrix = X_match,
    estimand = "ATT",
    M = 1, # 1 appariement pour chaque unité du groupe de traitement
    weights = NULL,
    pop.size = 1000, 
    max.generations = 100,
    wait.generations = 4, 
    caliper = .25,
    print.level = 1,
    cluster = rep("localhost", 4)
  ) # 15 min 
  saveRDS(gen_match_model_2008, "data/derived/gen_match_model_2008.rds")
  cat("Modèle GenMatch enregistré. \n")
}

# Matching with MatchIt for 2008  
  if (file.exists("data/derived/matching_result_2008.rds")) {
  matching_result_2008 <- readRDS("data/derived/matching_result_2008.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  matching_result_2008 <- matchit(
    treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
    data = matching_2008,
    method = "genetic",
    distance = "mahalanobis",
    gen.match = gen_match_model_2008
  )
  # Registrement
  saveRDS(matching_result_2008 , "data/derived/matching_result_2008.rds")
  cat("Données enregistrées")
}

# Summary of Balance
summary(matching_result_2008)
plot(matching_result_2008)
```

Avant le matching pour l'année 2008, nous avons 9 664 groupes de contrôle et 2149 groupes de traitement sur les 11 813 observations. Après le matching, 2 149 groupes sont appariés.

```{r}
# Load data 
hr_2021_final <- readRDS("data/derived/hr_2021_final.rds")

# Specifying binary variables in the column GROUP
matching_2021 <- hr_2021_final %>%
  filter(GROUP %in% c("Treatment", "Control")) %>%
  mutate(
    treatment = if_else(GROUP == "Treatment", 1, 0)) %>%
  drop_na(all_of(matching_variables))

# Generate a matrix for GenMatch 
X_match <- as.data.frame(st_drop_geometry(matching_2021[, c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")]))

# Optimum combination search for 2021
set.seed(123)


if (file.exists("data/derived/matching_result_2021.rds")) {
  matching_result_2021 <- readRDS("data/derived/matching_result_2021.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  gen_match_model_2021 <- GenMatch(
    Tr = matching_2021$treatment,
    X = X_match,
    BalanceMatrix = X_match,
    estimand = "ATT",
    M = 1, # 1 appariement pour chaque unité du groupe de traitement
    weights = NULL,
    pop.size = 1000, 
    max.generations = 100,
    wait.generations = 4, 
    caliper = .25,
    print.level = 1,
    cluster = rep("localhost", 4)
  ) # 15 min 
  saveRDS(gen_match_model_2021, "data/derived/gen_match_model_2021.rds")
  cat("Modèle GenMatch enregistré. \n")
}

# Matching with MatchIt for 2021  
  if (file.exists("data/derived/matching_result_2021.rds")) {
  matching_result_2021 <- readRDS("data/derived/matching_result_2021.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  matching_result_2021 <- matchit(
    treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
    data = matching_2021,
    method = "genetic",
    distance = "mahalanobis",
    gen.match = gen_match_model_2021
  )
  # Registrement
  saveRDS(matching_result_2021 , "data/derived/matching_result_2021.rds")
  cat("Données enregistrées")
}

# Summary of Balance
summary(matching_result_2021)
plot(matching_result_2021)
```

Avant le matching pour l'année 2021, nous avons 2990 groupe de traitement et 10 761 groupe de contrôle sur 13 751 observations. Après le macthing, 2 990 groupes sont appariés.

# Checking covariate balance 

Les modèles d'appariement reposent sur l'hypothèse que les distributions des covariables sont similaires entre les groupes de traitement et de contrôle, rendant cruciale l'évaluation de l'équilibre des covariables. La validité des estimations dépend directement de la qualité de cet équilibre, d'où l'importance de réaliser des tests pour le mesurer. On effectue donc un test d'équilibre des covariables en deux étapes: un test avant appariement et un test après appariement.

Pour effectuer le test avant l'appariement, on détermine les déséquilibres initiaux à partir du test de Standardized Mean Difference (SMD). Le SMD mesure l'écart entre les moyennes des covariables dans les groupes de traitement et les groupes de contrôle pour comparer l'équilibre relatif des variables mesurées dans des unités différentes:

-   Si \|SMD\| \< 0.1, il existe un équilibre satisfaisant entre les groupes pour la covariable.

-   Si SMD \> 0.1, le déséquilibre est significatif @austin2009. Pour réajuster l'équilibre, on augmentera l'intervalle des calipers afin d'obtenir un SMD **≤** 0.1.

Le test après appariement sera un test visuel de la qualité du matching en comparant la distribution de chaque covariable à partir du Q-Q Plot. Dans le cas où le QQ plot se situe en diagonale, le quantile des 2 distributions sont similaires.

## Balance test for 2008

```{r 2008}
library(cobalt)

# Balance before matching
bal_before_2008 <- bal.tab(
  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
  data = matching_2008,
  estimand = "ATT",
  un = TRUE # Inclusion des covariables non appariées 
)

print(bal_before_2008)
```

Les résultats montrent que la valeur de la différence standardisée des moyennes entre les groupes traités et contrôles, calculées avant le matching est supérieur à 0.1, qui indique un déséquilibre significatif . Seule la variable slope_2000 est bien équilibrée avec une valeur de SMD égale à 0.0257. Sans l'appariement, les données brutes montrent des déséquilibres importants entre les groupes pour plusieurs covariables. D'où la nécessité de réaliser un appariement pour réduire ces différences et obtenir des groupes plus comparables pour l'analyse de l'effet du traitement.

```{r}
# Balance after matching
bal_after_2008 <- bal.tab(matching_result_2008)
print(bal_after_2008)
```

Après l'appariement, toutes les variables présentent un SMD très faible (en dessous du seuil de 0.1), qui signifie que les groupes de traitement et de contrôle sont désormais très similaires sur ces variables. Tous les individus traités ont été appariés à un contrôle.

```{r}
library(halfmoon)

# Balance plot before matching
balance_plot_2008 <- matching_2008 %>%
  mutate()


ggplot(matching_2008, aes(p, fill = t, group = t)) + 
  geom_mirror_histogram(bins = 30) +
  annotate("label", 0.5, -10, label = "Control", color = "orange") +
  annotate("label", 0.5, 10, label = "Treated", color = "yellow") +
  scale_y_continuous(labels = abs) +
  labs(x = "gen_match_model_2008",
       y = "count") + 
  theme(legend.position = "none")




```

## Balance test for 2021

On détermine

```{r}

```
