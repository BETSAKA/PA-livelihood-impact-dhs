---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Matching

## Objectif

Le document illustre l'application de la méthode de matching dans l'analyse, en maximisant la comparabilité entre les groupes de traitement et de contrôle en termes de caractéristiques observables @ho2007.

## Méthodes

Nous réalisons le matching à l'aide de la méthode genetic matching, en utilisant la fonction GenMatch() du package R MatchIt. Cette méthode combine les variables de matching en une seule mesure unique de distance "Mahalanobis distance matching". Cette distance mesurera la différence entre les unités des groupes appariés pour quantifier la similitude entre les deux groupes d'observations, tout en tenant compte des corrélations entre les covariables et de leurs covariances @diamond2013.

Dans un premier temps, nous appliquons la fonction GenMatch() pour rechercher la combinaison optimale de poids pour chaque covariable afin de maximiser l'équilibre entre le groupe de traitement et de contrôle. Nous obtenons une matrice de poids mais aucune paire n'est encore formée. Dans un second temps, nous utilisons la fonction matchIt(), en intégrant la pondération trouvée auparavant, afin de constituer les paires entre les unités traitées et non traitées.

## Matching for 2008

```{r 2008}
# Library 
library(tidyverse) #Manipulation et visualisation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(MatchIt) #Matching
library(ggplot2) #Figure
library(rbounds)
library(rgenoud)
library(Matching)

# Load data 
hr_2008_final <- readRDS("data/derived/hr_2008_final.rds")

# Matching variables 
matching_variables <- c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")

# Specifying binary variables in the column GROUP
matching_2008 <- hr_2008_final %>%
  filter(GROUP %in% c("Treatment", "Control")) %>%
  mutate(
    treatment = if_else(GROUP == "Treatment", 1, 0)) %>%
  drop_na(all_of(matching_variables))

# Generate a matrix for GenMatch 
X_match <- as.data.frame(st_drop_geometry(matching_2008[, c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")]))

# Optimum combination search for 2008
set.seed(123)

if (file.exists("data/derived/gen_match_model_2008.rds")) {
  matching_result_2008 <- readRDS("data/derived/gen_match_model_2008.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  gen_match_model_2008 <- GenMatch(
    Tr = matching_2008$treatment,
    X = X_match,
    BalanceMatrix = X_match,
    estimand = "ATT",
    M = 1, # 1 appariement pour chaque unité du groupe de traitement
    weights = NULL,
    pop.size = 1000, 
    max.generations = 100,
    wait.generations = 4, 
    caliper = .25,
    print.level = 1,
    cluster = rep("localhost", 4)
  ) # 15 min 
  saveRDS(gen_match_model_2008, "data/derived/gen_match_model_2008.rds")
  cat("Modèle GenMatch enregistré. \n")
}

# Matching with MatchIt for 2008  
  if (file.exists("data/derived/matching_result_2008.rds")) {
  matching_result_2008 <- readRDS("data/derived/matching_result_2008.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  matching_result_2008 <- matchit(
    treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
    data = matching_2008,
    method = "genetic",
    distance = "mahalanobis",
    gen.match = gen_match_model_2008
  )
  # Registrement
  saveRDS(matching_result_2008 , "data/derived/matching_result_2008.rds")
  cat("Données enregistrées")
}

# Summary of Balance
summary(matching_result_2008)
plot(matching_result_2008)
```

Avant le matching pour l'année 2008, nous avons 9 664 groupes de contrôle et 2149 groupes de traitement sur les 11 813 observations. Après le matching, 2 149 groupes sont appariés.

## Matching for 2021

```{r}
# Load data 
hr_2021_final <- readRDS("data/derived/hr_2021_final.rds")

# Specifying binary variables in the column GROUP
matching_2021 <- hr_2021_final %>%
  filter(GROUP %in% c("Treatment", "Control")) %>%
  mutate(
    treatment = if_else(GROUP == "Treatment", 1, 0)) %>%
  drop_na(all_of(matching_variables))

# Generate a matrix for GenMatch 
X_match <- as.data.frame(st_drop_geometry(matching_2021[, c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")]))

# Optimum combination search for 2021
set.seed(123)


if (file.exists("data/derived/matching_result_2021.rds")) {
  matching_result_2021 <- readRDS("data/derived/matching_result_2021.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  gen_match_model_2021 <- GenMatch(
    Tr = matching_2021$treatment,
    X = X_match,
    BalanceMatrix = X_match,
    estimand = "ATT",
    M = 1, # 1 appariement pour chaque unité du groupe de traitement
    weights = NULL,
    pop.size = 1000, 
    max.generations = 100,
    wait.generations = 4, 
    caliper = .25,
    print.level = 1,
    cluster = rep("localhost", 4)
  ) # 15 min 
  saveRDS(gen_match_model_2021, "data/derived/gen_match_model_2021.rds")
  cat("Modèle GenMatch enregistré. \n")
}

# Matching with MatchIt for 2021  
  if (file.exists("data/derived/matching_result_2021.rds")) {
  matching_result_2021 <- readRDS("data/derived/matching_result_2021.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  matching_result_2021 <- matchit(
    treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
    data = matching_2021,
    method = "genetic",
    distance = "mahalanobis",
    gen.match = gen_match_model_2021
  )
  # Registrement
  saveRDS(matching_result_2021 , "data/derived/matching_result_2021.rds")
  cat("Données enregistrées")
}

# Summary of Balance
summary(matching_result_2021)
plot(matching_result_2021)
```

Avant le matching pour l'année 2021, nous avons 2 990 groupe de traitement et 10 761 groupe de contrôle sur 13 751 observations. Après le macthing, 2 990 groupes sont appariés.

## Checking covariate balance

Les modèles d'appariement reposent sur l'hypothèse que les distributions des covariables sont similaires entre les groupes de traitement et de contrôle, rendant cruciale l'évaluation de l'équilibre des covariables. La validité des estimations dépend directement de la qualité de cet équilibre, d'où l'importance de réaliser des tests pour le mesurer. On effectue donc un test d'équilibre des covariables en deux étapes: un test avant appariement et un test après appariement.

Pour effectuer le test avant l'appariement, on détermine les déséquilibres initiaux à partir du test de Standardized Mean Difference (SMD). Le SMD mesure l'écart entre les moyennes des covariables dans les groupes de traitement et les groupes de contrôle pour comparer l'équilibre relatif des variables mesurées dans des unités différentes:

-   Si \|SMD\| \< 0.1, il existe un équilibre satisfaisant entre les groupes pour la covariable.

-   Si SMD \> 0.1, le déséquilibre est significatif @austin2009. Pour réajuster l'équilibre, on augmentera l'intervalle des calipers afin d'obtenir un SMD **≤** 0.1.

Le test après appariement sera un test visuel de la qualité du matching en comparant la distribution de chaque covariable à partir d'un plot. La méthode graphique offre une vue d'ensemble de la distribution des covariables. Le graphique facilite ainsi l'identification des déséquilibres à différents niveaux de la distribution. Lorsque les points Q-Q plot se situent près de la diagonale, le quantile des deux distributions sont similaires, signalant ainsi un bon équilibre

### Balance test for 2008

#### Balance test before matching

```{r 2008}

library(halfmoon)
library(cobalt)


# Balance before matching
bal_before_2008 <- bal.tab(
  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
  data = matching_2008,
  estimand = "ATT",
  un = TRUE # Inclusion des covariables non appariées 
)

print(bal_before_2008)

# Balance plot before matching
matching_before_2008 <- matching_2008 %>%
  pivot_longer(
    cols = all_of(matching_variables),
    names_to = "variable",
    values_to = "value"
  )
  

ggplot(matching_before_2008, aes(x = value, fill = GROUP)) +
  geom_mirror_histogram(alpha = 0.5) +
  facet_wrap(~variable, scales = "free") +
  scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
  labs(
    tittle = "Covariate Distribution before matching (2008)",
    x = "Valeur de la covariable",
    y = "Densité",
    fill = "Group"
  ) +
  theme_minimal()
```

Les résultats montrent que la valeur de la différence standardisée des moyennes entre les groupes traités et contrôles, calculées avant le matching est supérieur à 0.1, qui indique un déséquilibre significatif . Seule la variable slope_2000 est bien équilibrée avec une valeur de SMD égale à 0.0257. Sans l'appariement, les données brutes montrent des déséquilibres importants entre les groupes pour plusieurs covariables. D'où la nécessité de réaliser un appariement pour réduire ces différences et obtenir des groupes plus comparables pour l'analyse de l'effet du traitement.

#### Balance test after matching

```{r}
# Balance after matching
bal_after_2008 <- bal.tab(matching_result_2008)
print(bal_after_2008)

# Balance plot after matching
matched_data_2008 <- match.data(matching_result_2008)


matching_after_2008 <- matched_data_2008 %>%
  pivot_longer(
    cols = all_of(matching_variables),
names_to = "variable",
values_to = "value"
)
  
  ggplot(matching_after_2008, aes(x = value, fill = GROUP)) +
    geom_density(alpha = 0.5, color = "black", linewidth = 0.7, adjust = 0.7) +
    facet_wrap(~variable, scales = "free") +
    scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
    labs(
      title = "Covariate distribution after matching (2008)",
      x = "Valeur de la covariable",
      y = "Densité",
      fill = "Group"
    ) +
    theme_minimal()
```

Après l'appariement, toutes les variables présentent un SMD très faible (en dessous du seuil de 0.1), qui signifie que les groupes de traitement et de contrôle sont désormais très similaires sur ces variables. Tous les individus traités ont été appariés à un contrôle.

#### Q-Q Plot analysis

```{r}
library(patchwork)

plots_2008 <- lapply(matching_variables, function(var){
  ggplot(matched_data_2008, aes(sample = .data[[var]], color = GROUP)) +
    stat_qq() +
    stat_qq_line() +
    labs(
      title = paste("Q-Q plot de", var), 
      x = "Quantiles théoriques", 
      y = "Quantiles échantillon", color = "Groupe"
      ) +
    theme_minimal() +
    theme(legend.position = "bottom")
})

# Patchwork grid assembly
wrap_plots(plots_2008, ncol = 2)
```

Sur les graphiques, on peut voir qu'il y a des différences de forme entre les distributions comparées. Pour la majorité des covariables (treecover_area_2000, slope_2000, traveltime_2000), les distributions des groupes de contrôle et de traitement sont similaires, presque parfaite. Les points Q-Q plots sont proches de la diagonale montrant que le matching a bien équilibré ces variables. Quant aux covariables elevation_2000 , les courbes de distribution montrent quelques différences entre le groupe de traitement et de contrôle. Ces différences s'accentuent dans le cas de la covariable population_count_2000, qui se diffèrent beaucoup dans les extrêmes. Le matching a équilibré les covariables mais ce n'est pas totalement parfait.

### Balance test for 2021

#### Balance test before matching

```{r}
# Balance before matching
bal_before_2021 <- bal.tab(
  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
  data = matching_2021,
  estimand = "ATT",
  un = TRUE # Inclusion des covariables non appariées 
)

print(bal_before_2021)

# Balance plot before matching
matching_before_2021 <- matching_2021 %>%
  pivot_longer(
    cols = all_of(matching_variables),
    names_to = "variable",
    values_to = "value"
  )
  

ggplot(matching_before_2021, aes(x = value, fill = GROUP)) +
  geom_mirror_histogram(alpha = 0.5) +
  facet_wrap(~variable, scales = "free") +
  scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
  labs(
    tittle = "Covariate Distribution before matching (2021)",
    x = "Valeur de la covariable",
    y = "Densité",
    fill = "Group"
  ) +
  theme_minimal()
```

Les résultats montrent qu'il y a une différence entre les groupes de traitement et les groupes de contrôle pour chaque covariable avant l'appariement. Tous les covariables présentes des déséquilibres modérés entre les groupes, sauf pour la variable population_count_2000 qui montre un déséquilibre majeur.

#### Balance test after matching

```{r}
# Balance after matching
bal_after_2021 <- bal.tab(matching_result_2021)
print(bal_after_2021)

# Balance plot after matching
matched_data_2021 <- match.data(matching_result_2021)


matching_after_2021 <- matched_data_2021 %>%
  pivot_longer(
    cols = all_of(matching_variables),
names_to = "variable",
values_to = "value"
)
  
  ggplot(matching_after_2021, aes(x = value, fill = GROUP)) +
    geom_density(alpha = 0.5, color = "black", linewidth = 0.7, adjust = 0.7) +
    facet_wrap(~variable, scales = "free") +
    scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
    labs(
      title = "Covariate Distribution after matching (2021)",
      x = "Valeur de la covariable",
      y = "Densité",
      fill = "Group"
    ) +
    theme_minimal()
```

Les résultats montrent que toutes les valeurs des SMD sont très faibles, comprises entre 0.0361 et 0.1033, indiquant ainsi un excellent équilibre entre les groupes pour l'ensemble des covariables. Les graphiques confirment également cet équilibre: les courbes des groupes de contrôle (en vert) et les groupes de traitement (en bleue) se superposent largement, traduisant une forte similitude dans la distribution des covariables après l'appariement.

#### Q-Q Plot analysis

```{r}
library(patchwork)

plots_2021 <- lapply(matching_variables, function(var){
  ggplot(matched_data_2021, aes(sample = .data[[var]], color = GROUP)) +
    stat_qq() +
    stat_qq_line() +
    labs(
      title = paste("Q-Q plot of", var), 
      x = " Theorical Quantiles", 
      y = "Sample Quantile", color = "Group"
      ) +
    theme_minimal() +
    theme(legend.position = "bottom")
})

# Patchwork grid assembly
wrap_plots(plots_2021, ncol = 2)
```

Les distributions des groupes de contrôle et de traitement de treecover_area_2000, slope_2000, elevation_2000 et traveltime_2000_2000 sont presque similairement parfaite. Cela montre que le matching a bien équilibré ces variables. Dans le cas du population_count_2000, les courbes sont également très proches de la diagonale, mais présentent des petits écarts pour les valeurs extrêmes.
