---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Matching

## Objectif

Le document illustre l'application de la méthode de matching dans l'analyse. L'objectif de cette méthode est d'équilibrer les échantillons, c'est-à-dire de maximiser la comparabilité entre les groupes de traitement et de contrôle en termes de caractéristiques observables [@ho2007]. En effet, si les deux groupes sont très différents avant le traitement, il est difficile de savoir si les différences observées après viennent du traitement ou simplement de ces différences initiales. D'où l'importance du matching, qui permet de neutraliser ces différences. Plus précisement, nous utilisons le genetic matching, une variante des méthodes de matching. Bien qu'ayant le même objectif, cette approche repose sur des algorithmes d'optimisation qui ajustent les facteurs de confusion susceptibles d'influencer à la fois la probabilité de recevoir le traitement et les résultats observés.

## Méthodes

Nous réalisons le matching à l'aide de la méthode genetic matching, en utilisant la fonction GenMatch() du package R MatchIt. Cette méthode combine les variables de matching en une seule mesure unique de distance "Mahalanobis distance matching". Cette distance mesurera la différence entre les unités des groupes appariés pour quantifier la similitude entre les deux groupes d'observations, tout en tenant compte des corrélations entre les covariables et de leurs covariances [@diamond2013].

Dans un premier temps, nous appliquons la fonction GenMatch() pour identifier la combinaison optimale de poids attribués à chaque covariable, dans le but de maximiser l'équilibre entre le groupe de traitement et de contrôle. Nous obtenons une matrice de poids mais aucune paire n'est encore formée. Dans un second temps, nous utilisons la fonction matchIt(), en intégrant la pondération trouvée auparavant, afin de constituer les paires entre les unités traitées et non traitées.

## Matching for 1997

```{r}
# Library 
library(tidyverse) #Manipulation et visualisation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(MatchIt) #Matching
library(ggplot2) #Figure
library(rbounds)
library(rgenoud)
library(Matching)

# Load data 
hr_1997_final <- readRDS("data/derived/hr_1997_final.rds")

# Matching variables 
matching_variables <- c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")

# Specifying binary variables in the column GROUP
matching_1997 <- hr_1997_final %>%
  filter(GROUP %in% c("Treatment", "Control")) %>%
  mutate(
    treatment = if_else(GROUP == "Treatment", 1, 0)) %>%
  drop_na(all_of(matching_variables))

# Generate a matrix for GenMatch 
X_match <- as.data.frame(st_drop_geometry(matching_1997[, c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")]))

# Optimum combination search for 1997
set.seed(123)

if (file.exists("data/derived/gen_match_model_1997.rds")) {
  matching_result_1997 <- readRDS("data/derived/gen_match_model_1997.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  gen_match_model_1997 <- GenMatch(
    Tr = matching_1997$treatment,
    X = X_match,
    BalanceMatrix = X_match,
    estimand = "ATT",
    M = 1, # 1 appariement pour chaque unité du groupe de traitement
    weights = NULL,
    pop.size = 1000, 
    max.generations = 100,
    wait.generations = 4, 
    caliper = .25,
    print.level = 1,
    cluster = rep("localhost", 4)
  ) # 15 min 
  saveRDS(gen_match_model_1997, "data/derived/gen_match_model_1997.rds")
  cat("Modèle GenMatch enregistré. \n")
}

# Matching with MatchIt for 1997  
  if (file.exists("data/derived/matching_result_1997.rds")) {
  matching_result_1997 <- readRDS("data/derived/matching_result_1997.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  matching_result_1997 <- matchit(
    treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
    data = matching_1997,
    method = "genetic",
    distance = "mahalanobis",
    gen.match = gen_match_model_1997
  )
  # Registrement
  saveRDS(matching_result_1997 , "data/derived/matching_result_1997.rds")
  cat("Données enregistrées")
}

# Summary of Balance
summary(matching_result_1997)
plot(matching_result_1997)

# Extract matched data for 1997
data_matched_1997 <- match.data(matching_result_1997)

data_matched_1997 <- data_matched_1997 %>%
  filter(weights > 0)
nrow(data_matched_1997)

saveRDS(data_matched_1997,"data/derived/data_matched_1997.rds" )
```

Avant le matching, nous comptons 3 505 observations pour l'année 1997. Après le matching, nous obtenons 1930 observations appariées (965 groupes de traitement et 965 groupes de contrôles).

## Matching for 2008

```{r}

# Load data 
hr_2008_final <- readRDS("data/derived/hr_2008_final.rds")

# Matching variables 
matching_variables <- c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")

# Specifying binary variables in the column GROUP
matching_2008 <- hr_2008_final %>%
  filter(GROUP %in% c("Treatment", "Control")) %>%
  mutate(
    treatment = if_else(GROUP == "Treatment", 1, 0)) %>%
  drop_na(all_of(matching_variables))

# Generate a matrix for GenMatch 
X_match <- as.data.frame(st_drop_geometry(matching_2008[, c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")]))

# Optimum combination search for 2008
set.seed(123)

if (file.exists("data/derived/gen_match_model_2008.rds")) {
  matching_result_2008 <- readRDS("data/derived/gen_match_model_2008.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  gen_match_model_2008 <- GenMatch(
    Tr = matching_2008$treatment,
    X = X_match,
    BalanceMatrix = X_match,
    estimand = "ATT",
    M = 1, # 1 appariement pour chaque unité du groupe de traitement
    weights = NULL,
    pop.size = 1000, 
    max.generations = 100,
    wait.generations = 4, 
    caliper = .25,
    print.level = 1,
    cluster = rep("localhost", 4)
  ) # 16 min et 25s 
  saveRDS(gen_match_model_2008, "data/derived/gen_match_model_2008.rds")
  cat("Modèle GenMatch enregistré. \n")
}

# Matching with MatchIt for 2008  
  if (file.exists("data/derived/matching_result_2008.rds")) {
  matching_result_2008 <- readRDS("data/derived/matching_result_2008.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  matching_result_2008 <- matchit(
    treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
    data = matching_2008,
    method = "genetic",
    distance = "mahalanobis",
    gen.match = gen_match_model_2008
  )
  # Registrement
  saveRDS(matching_result_2008 , "data/derived/matching_result_2008.rds")
  cat("Données enregistrées")
}

# Summary of Balance
summary(matching_result_2008)
plot(matching_result_2008)

# Extract matched data for 2008
data_matched_2008 <- match.data(matching_result_2008)

data_matched_2008 <- data_matched_2008 %>%
  filter(weights > 0)
nrow(data_matched_2008)

saveRDS(data_matched_2008,"data/derived/data_matched_2008.rds" )
```

Avant le matching pour l'année 2008, nous avons 9 307 groupes de contrôle et 2 419 groupes de traitement sur les 15 364 observations. Après le matching, 4 838 groupes sont appariés, avec un total de 13 405 observations.

## Matching for 2021

```{r}
# Load data 
hr_2021_final <- readRDS("data/derived/hr_2021_final.rds")

# Specifying binary variables in the column GROUP
matching_2021 <- hr_2021_final %>%
  filter(GROUP %in% c("Treatment", "Control")) %>%
  mutate(
    treatment = if_else(GROUP == "Treatment", 1, 0)) %>%
  drop_na(all_of(matching_variables))

# Generate a matrix for GenMatch 
X_match <- as.data.frame(st_drop_geometry(matching_2021[, c("treecover_area_2000", "slope_2000", "elevation_2000", "population_count_2000", "traveltime_2000_2000")]))

# Optimum combination search for 2021
set.seed(123)


if (file.exists("data/derived/matching_result_2021.rds")) {
  matching_result_2021 <- readRDS("data/derived/matching_result_2021.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  gen_match_model_2021 <- GenMatch(
    Tr = matching_2021$treatment,
    X = X_match,
    BalanceMatrix = X_match,
    estimand = "ATT",
    M = 1, # 1 appariement pour chaque unité du groupe de traitement
    weights = NULL,
    pop.size = 1000, 
    max.generations = 100,
    wait.generations = 4, 
    caliper = .25,
    print.level = 1,
    cluster = rep("localhost", 4)
  ) # 20 min 
  saveRDS(gen_match_model_2021, "data/derived/gen_match_model_2021.rds")
  cat("Modèle GenMatch enregistré. \n")
}

# Matching with MatchIt for 2021  
  if (file.exists("data/derived/matching_result_2021.rds")) {
  matching_result_2021 <- readRDS("data/derived/matching_result_2021.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  matching_result_2021 <- matchit(
    treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
    data = matching_2021,
    method = "genetic",
    distance = "mahalanobis",
    gen.match = gen_match_model_2021
  )
  # Registrement
  saveRDS(matching_result_2021 , "data/derived/matching_result_2021.rds")
  cat("Données enregistrées")
}

# Summary of Balance
summary(matching_result_2021)
plot(matching_result_2021)

# Extract matched data for 2021
data_matched_2021 <- match.data(matching_result_2021)

data_matched_2021 <- data_matched_2021 %>%
  filter(weights > 0)
nrow(data_matched_2021)

saveRDS(data_matched_2021,"data/derived/data_matched_2021.rds" )
```

Avant le matching pour l'année 2021, nous avons 10 074 groupe de traitement et 3 331 groupe de contrôle sur 15 364 observations. Après le macthing, 6 662 groupes sont appariés, avec un total de 13 405 observations.

## Checking covariate balance

Les modèles d'appariement reposent sur l'hypothèse que les distributions des covariables sont similaires entre les groupes de traitement et de contrôle, rendant cruciale l'évaluation de l'équilibre des covariables. La validité des estimations dépend directement de la qualité de cet équilibre, d'où l'importance de réaliser des tests pour le mesurer. On effectue donc un test d'équilibre des covariables en deux étapes: un test avant appariement et un test après appariement.

Pour effectuer le test avant l'appariement, on détermine les déséquilibres initiaux à partir du test de Standardized Mean Difference (SMD). Le SMD mesure l'écart entre les moyennes des covariables dans les groupes de traitement et les groupes de contrôle pour comparer l'équilibre relatif des variables mesurées dans des unités différentes:

-   Si \|SMD\| \< 0.1, il existe un équilibre satisfaisant entre les groupes pour la covariable.

-   Si SMD \> 0.1, le déséquilibre est significatif @austin2009. Pour réajuster l'équilibre, on augmentera l'intervalle des calipers afin d'obtenir un SMD **≤** 0.1.

Le test après appariement sera un test visuel de la qualité du matching en comparant la distribution de chaque covariable à partir d'un plot. La méthode graphique offre une vue d'ensemble de la distribution des covariables. Le graphique facilite ainsi l'identification des déséquilibres à différents niveaux de la distribution. Lorsque les points Q-Q plot se situent près de la diagonale, le quantile des deux distributions sont similaires, signalant ainsi un bon équilibre

### Balance test for 1997

#### Balance test before matching

```{r}
library(halfmoon)
library(cobalt)


# Balance before matching
bal_before_1997 <- bal.tab(
  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
  data = matching_1997,
  estimand = "ATT",
  un = TRUE # Inclusion des covariables non appariées 
)

print(bal_before_1997)

# Balance plot before matching
matching_before_1997 <- matching_1997 %>%
  pivot_longer(
    cols = all_of(matching_variables),
    names_to = "variable",
    values_to = "value"
  )
  

ggplot(matching_before_1997, aes(x = value, fill = GROUP)) +
  geom_mirror_histogram(alpha = 0.5) +
  facet_wrap(~variable, scales = "free") +
  scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
  labs(
    tittle = "Covariate Distribution before matching (1997)",
    x = "Valeur de la covariable",
    y = "Densité",
    fill = "Group"
  ) +
  theme_minimal()
```

#### Balance test after matching

```{r}
# Balance after matching
bal_after_1997 <- bal.tab(matching_result_1997)
print(bal_after_1997)

# Balance plot after matching
matched_data_1997 <- match.data(matching_result_1997)


matching_after_1997 <- matched_data_1997 %>%
  pivot_longer(
    cols = all_of(matching_variables),
names_to = "variable",
values_to = "value"
)
  
  ggplot(matching_after_1997, aes(x = value, fill = GROUP)) +
    geom_density(alpha = 0.5, color = "black", linewidth = 0.7, adjust = 0.7) +
    facet_wrap(~variable, scales = "free") +
    scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
    labs(
      title = "Covariate distribution after matching (1997)",
      x = "Valeur de la covariable",
      y = "Densité",
      fill = "Group"
    ) +
    theme_minimal()
```

### Balance test for 2008

#### Balance test before matching

```{r}

library(halfmoon)
library(cobalt)


# Balance before matching
bal_before_2008 <- bal.tab(
  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
  data = matching_2008,
  estimand = "ATT",
  un = TRUE # Inclusion des covariables non appariées 
)

print(bal_before_2008)

# Balance plot before matching
matching_before_2008 <- matching_2008 %>%
  pivot_longer(
    cols = all_of(matching_variables),
    names_to = "variable",
    values_to = "value"
  )
  

ggplot(matching_before_2008, aes(x = value, fill = GROUP)) +
  geom_mirror_histogram(alpha = 0.5) +
  facet_wrap(~variable, scales = "free") +
  scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
  labs(
    tittle = "Covariate Distribution before matching (2008)",
    x = "Valeur de la covariable",
    y = "Densité",
    fill = "Group"
  ) +
  theme_minimal()
```

Les résultats montrent que la valeur de la différence standardisée des moyennes entre les groupes traités et contrôles, calculées avant le matching est supérieur à 0.1, qui indique un déséquilibre significatif . Seule la variable slope_2000 a un équilibre modérée avec une valeur de SMD égale à 0.1337. Sans l'appariement, les données brutes montrent des déséquilibres importants entre les groupes pour plusieurs covariables. D'où la nécessité de réaliser un appariement pour réduire ces différences et obtenir des groupes plus comparables pour l'analyse de l'effet du traitement.

#### Balance test after matching

```{r}
# Balance after matching
bal_after_2008 <- bal.tab(matching_result_2008)
print(bal_after_2008)

# Balance plot after matching
matched_data_2008 <- match.data(matching_result_2008)


matching_after_2008 <- matched_data_2008 %>%
  pivot_longer(
    cols = all_of(matching_variables),
names_to = "variable",
values_to = "value"
)
  
  ggplot(matching_after_2008, aes(x = value, fill = GROUP)) +
    geom_density(alpha = 0.5, color = "black", linewidth = 0.7, adjust = 0.7) +
    facet_wrap(~variable, scales = "free") +
    scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
    labs(
      title = "Covariate distribution after matching (2008)",
      x = "Valeur de la covariable",
      y = "Densité",
      fill = "Group"
    ) +
    theme_minimal()
```

Après l'appariement, toutes les variables présentent un SMD très faible (en dessous du seuil de 0.1), qui signifie que les groupes de traitement et de contrôle sont désormais très similaires sur ces variables. Tous les individus traités ont été appariés à un contrôle.

#### Q-Q Plot analysis

```{r}
library(patchwork)

plots_2008 <- lapply(matching_variables, function(var){
  ggplot(matched_data_2008, aes(sample = .data[[var]], color = GROUP)) +
    stat_qq() +
    stat_qq_line() +
    labs(
      title = paste("Q-Q plot de", var), 
      x = "Quantiles théoriques", 
      y = "Quantiles échantillon", color = "Groupe"
      ) +
    theme_minimal() +
    theme(legend.position = "bottom")
})

# Patchwork grid assembly
wrap_plots(plots_2008, ncol = 2)
```

Sur les graphiques, on peut voir qu'il y a des différences de forme entre les distributions comparées. Pour la majorité des covariables (treecover_area_2000, slope_2000, traveltime_2000), les distributions des groupes de contrôle et de traitement sont similaires, presque parfaite. Les points Q-Q plots sont proches de la diagonale montrant que le matching a bien équilibré ces variables. Quant aux covariables elevation_2000 , les courbes de distribution montrent quelques différences entre le groupe de traitement et de contrôle. Ces différences s'accentuent dans le cas de la covariable population_count_2000, qui se diffèrent beaucoup dans les extrêmes. Le matching a équilibré les covariables mais ce n'est pas totalement parfait.

### Balance test for 2021

#### Balance test before matching

```{r}
# Balance before matching
bal_before_2021 <- bal.tab(
  treatment ~ treecover_area_2000 + slope_2000 + elevation_2000 + population_count_2000 + traveltime_2000_2000,
  data = matching_2021,
  estimand = "ATT",
  un = TRUE # Inclusion des covariables non appariées 
)

print(bal_before_2021)

# Balance plot before matching
matching_before_2021 <- matching_2021 %>%
  pivot_longer(
    cols = all_of(matching_variables),
    names_to = "variable",
    values_to = "value"
  )
  

ggplot(matching_before_2021, aes(x = value, fill = GROUP)) +
  geom_mirror_histogram(alpha = 0.5) +
  facet_wrap(~variable, scales = "free") +
  scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
  labs(
    tittle = "Covariate Distribution before matching (2021)",
    x = "Covariate value",
    y = "Density",
    fill = "Group"
  ) +
  theme_minimal()
```

Les résultats montrent qu'il y a une différence entre les groupes de traitement et les groupes de contrôle pour chaque covariable avant l'appariement. Tous les covariables présentes des déséquilibres modérés entre les groupes, sauf pour la variable population_count_2000 qui montre un déséquilibre majeur.

#### Balance test after matching

```{r}
# Balance after matching
bal_after_2021 <- bal.tab(matching_result_2021)
print(bal_after_2021)

# Balance plot after matching
matched_data_2021 <- match.data(matching_result_2021)


matching_after_2021 <- matched_data_2021 %>%
  pivot_longer(
    cols = all_of(matching_variables),
names_to = "variable",
values_to = "value"
)
  
  ggplot(matching_after_2021, aes(x = value, fill = GROUP)) +
    geom_density(alpha = 0.5, color = "black", linewidth = 0.7, adjust = 0.7) +
    facet_wrap(~variable, scales = "free") +
    scale_fill_manual(values = c("Control" = "green", "Treatment" = "blue")) +
    labs(
      title = "Covariate Distribution after matching (2021)",
      x = "Covariate value",
      y = "Density",
      fill = "Group"
    ) +
    theme_minimal()
```

Les résultats montrent que toutes les valeurs des SMD sont très faibles, comprises entre -0.0692 et 0.1155, indiquant ainsi un excellent équilibre entre les groupes pour l'ensemble des covariables. Les graphiques confirment également cet équilibre: les courbes des groupes de contrôle (en vert) et les groupes de traitement (en bleue) se superposent largement, traduisant une forte similitude dans la distribution des covariables après l'appariement.

#### Q-Q Plot analysis

```{r}
library(patchwork)

plots_2021 <- lapply(matching_variables, function(var){
  ggplot(matched_data_2021, aes(sample = .data[[var]], color = GROUP)) +
    stat_qq() +
    stat_qq_line() +
    labs(
      title = paste("Q-Q plot of", var), 
      x = " Theorical Quantiles", 
      y = "Sample Quantile", color = "Group"
      ) +
    theme_minimal() +
    theme(legend.position = "bottom")
})

# Patchwork grid assembly
wrap_plots(plots_2021, ncol = 2)
```

Les distributions des groupes de contrôle et de traitement de treecover_area_2000, slope_2000, elevation_2000 et traveltime_2000_2000 sont presque similairement parfaite. Cela montre que le matching a bien équilibré ces variables. Dans le cas du population_count_2000, les courbes sont également très proches de la diagonale, mais présentent des petits écarts pour les valeurs extrêmes.
