---
title: "PA-livelihood-impact-dhs"
author: "Iriana Razafimahenina"
format: 
  html:
   out-put-file: index.html
   embed-resources: true
   standalone: true
   code-fold: true
  execute:
   warning: false
   error: false
editor: visual
editor-options: 
   chunk_out_type: console
Bibliography: references.bib
---

# Environnement

```{r}
library(tidyverse) #Manipulation et visualisation des données
library(haven) #Importation des données
library(writexl) #Exportation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(codebook) #Documentation et mise en forme des données 
library(gt) #Mise en forme des tableaux 
library(survey) #Analyse des données d'enquêtes
library(MatchIt) #Matching
library(ggplot2) #Figure
library(labelled) # Manipulation des labels
library(janitor) #Nettoyage des données 
library(psych) #Analyse psychométrique
library(readxl) #Lecture des fichiers excels

```

# Data structuring

Nous allons chargé les données nécessaires à l'analyse.

## Socioeconomic household data

### Reproduction of wealth index

Cette section a pour objectif de reproduire le wealth index de DHS 2021, 2008 et 1997. Dans un premier temps, nous reproduirons les scores factoriels du wealth index (hv271) à l'aide d'une analyse par composante principale (ACP), en nous basant sur le code SPSS utilisé par DHS pour construire cet indice. Le calcul des scores factoriels permet de créer un indicateur composite agrégant l'information des différentes variables de manière pondérée. Dans un second temps, nous reproduirons le wealth index hv270 des années étudiées.

#### Wealth index for 2021

```{r}
# Load DHS 2021 Data
hh_2021 <- read_dta("../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/DHS_2021/MDHR81DT/MDHR81FL.DTA")

# Filter valid households
hh_2021 <- hh_2021 %>%
  filter(hv015 == 1)

# Build a variable dictionnary
codebook_2021 <- hh_2021 |> 
  look_for() |> 
  as_tibble()

# Define function to dichotomize categorical variables
dichotomize <- function(data, var, condition, new_var, new_var_label) {
  data %>%
    mutate({{ new_var }} := if_else({{ condition }}, 1, 0, missing = 0)) %>%
    labelled::set_variable_labels(!!rlang::ensym(new_var) := new_var_label) %>%
    labelled::set_value_labels(!!rlang::ensym(new_var) := c("No" = 0, "Yes" = 1))
}

# Define a function that will reclassify if the toilet are shared
shared_fac <- function(data, var, new_var, new_var_label) {
  data %>%
    mutate(
      {{ new_var }} := if_else(hv225 == 1 & {{ var }} == 1, 1, 0, missing = 0),
      {{ var }} := if_else(hv225 == 1, 0, {{ var }}, missing = 0)
    ) %>%
    labelled::set_variable_labels(!!rlang::ensym(new_var) := new_var_label) %>%
    labelled::set_value_labels(!!rlang::ensym(new_var) := c("No" = 0, "Yes" = 1))
}

# Function to categorize livestock counts
categorize_livestock <- function(data, var, prefix, category_ranges, category_labels) {
  
  # Ensure missing values and conditions are applied first
  data <- data %>%
    mutate(
      {{ var }} := if_else(is.na({{ var }}) | hv246 != 1, 0, {{ var }})
    )
  
  # Create categorized dummy variables with the given prefix
  for (i in seq_along(category_ranges)) {
    new_var <- paste0(prefix, "_", i)  # Custom prefix for output variable names
    label <- category_labels[i]
    
    data <- data %>%
      mutate(
        !!sym(new_var) := as.integer({{ var }} >= category_ranges[[i]][1] & {{ var }} <= category_ranges[[i]][2])
      ) %>%
      set_variable_labels(!!sym(new_var) := label)
  }
  
  return(data)
}

# To mimic no2zero in DHS SPSS code (our values are already coded 0 and 1)

no2zero <- function(data, new_var, old_var, replace_na = TRUE) {
  data %>%
    rename({{ new_var }} := {{ old_var }}) %>%
    mutate({{ new_var }} := if_else(replace_na & is.na({{ new_var }}), 0, {{ new_var }}))
}

# Dichotomization as per SPSS original script
# I rename the outputs to have the same as in: 
# https://www.dhsprogram.com/programming/wealth%20index/Madagascar%20DHS%202021/Madagascar%20DHS%202021.sps.txt

test <- hh_2021 %>%
  
  # Source of drinking water
  dichotomize(hv201, hv201 == 11, QH101_11, "Source of drinking water: Eau du robinet dans le logement") %>%
  dichotomize(hv201, hv201 == 12, QH101_12, "Source of drinking water: Eau du robinet dans la cour/Parcelle") %>%
  dichotomize(hv201, hv201 == 13, QH101_13, "Source of drinking water: Eau du robinet du voisin") %>%
  dichotomize(hv201, hv201 == 14, QH101_14, "Source of drinking water: Eau du robinet public/Borne fontaine") %>%
  dichotomize(hv201, hv201 == 21, QH101_21, "Source of drinking water: Puits à pompe ou forage") %>%
  dichotomize(hv201, hv201 == 31, QH101_31, "Source of drinking water: Puits creusés protégés") %>%
  dichotomize(hv201, hv201 == 32, QH101_32, "Source of drinking water: Puits creusés non protégés") %>%
  dichotomize(hv201, hv201 == 41, QH101_41, "Source of drinking water: Source protégée") %>%
  dichotomize(hv201, hv201 == 42, QH101_42, "Source of drinking water: Source non protégée") %>%
  dichotomize(hv201, hv201 == 51, QH101_51, "Source of drinking water: Eau de pluie") %>%
  dichotomize(hv201, hv201 == 61, QH101_61, "Source of drinking water: Camion citerne") %>%
  dichotomize(hv201, hv201 == 71, QH101_71, "Source of drinking water: Charette avec petite citerne/tonneau") %>%
  dichotomize(hv201, hv201 == 81, QH101_81, "Source of drinking water: Eau de surface/Rivière/Barrage/Lac/Mare/Canal") %>%
  dichotomize(hv201, hv201 == 91, QH101_91, "Source of drinking water: Eau en bouteille") %>%
  dichotomize(hv201, hv201 == 96, QH101_96, "Source of drinking water: Autre") %>%
  
  # Qui va chercher l'eau?
  # dichotomize(hv236, hv236 == 1, QH104A_1, "Qui va chercher l'eau: Femme adulte (>=15 ans)") %>%
  # dichotomize(hv236, hv236 == 2, QH104A_2, "Qui va chercher l'eau: Homme adulte (>=15 ans)") %>%
  # dichotomize(hv236, hv236 == 3, QH104A_3, "Qui va chercher l'eau: Fille (<15 ans)") %>%
  # dichotomize(hv236, hv236 == 4, QH104A_4, "Qui va chercher l'eau: Garçons (<15 ans)") %>%
  
  # Type of toilet facility
  dichotomize(hv205, hv205 == 11, QH109_11, "Type of toilet facility: Chasse d'eau - à un système d'égout") %>%
  dichotomize(hv205, hv205 == 12, QH109_12, "Type of toilet facility: Chasse d'eau - à une fosse septique") %>%
  dichotomize(hv205, hv205 == 13, QH109_13, "Type of toilet facility: Chasse d'eau - fosse d'aisance") %>%
  dichotomize(hv205, hv205 == 14, QH109_14, "Type of toilet facility: Chasse d'eau - à quelque chose d'autre") %>%
  dichotomize(hv205, hv205 == 15, QH109_15, "Type of toilet facility: Chasse d'eau - ne sait pas") %>%
  dichotomize(hv205, hv205 == 21, QH109_21, "Type of toilet facility: Fosses/latrines - ventilées améliorées (VIP)") %>%
  dichotomize(hv205, hv205 == 22, QH109_22, "Type of toilet facility: Fosses/latrines - avec dalles") %>%
  dichotomize(hv205, hv205 == 23, QH109_23, "Type of toilet facility: Fosses/latrines - sans dalles/trou ouvert") %>%
  dichotomize(hv205, hv205 == 31, QH109_31, "Type of toilet facility: Toilettes à compostage") %>%
  dichotomize(hv205, hv205 == 41, QH109_41, "Type of toilet facility: Seau/tinette") %>%
  dichotomize(hv205, hv205 == 51, QH109_51, "Type of toilet facility: Toilettes /latrines suspendues") %>%
  dichotomize(hv205, hv205 == 61, QH109_61, "Type of toilet facility: Pas de toilette/nature") %>%
  dichotomize(hv205, hv205 == 96, QH109_96, "Type of toilet facility: Autre") %>%
  
  # Create shared toilet facility indicators
  shared_fac(QH109_11, QH109_11_sh, "Type of toilet facility: Chasse d'eau - à un système d'égout - shared") %>%
  shared_fac(QH109_12, QH109_12_sh, "Type of toilet facility: Chasse d'eau - à une fosse septique - shared") %>%
  shared_fac(QH109_13, QH109_13_sh, "Type of toilet facility: Chasse d'eau - fosse d'aisance - shared") %>%
  shared_fac(QH109_14, QH109_14_sh, "Type of toilet facility: Chasse d'eau - à quelque chose d'autre - shared") %>%
  shared_fac(QH109_15, QH109_15_sh, "Type of toilet facility: Chasse d'eau - ne sait pas - shared") %>%
  shared_fac(QH109_21, QH109_21_sh, "Type of toilet facility: Fosses/latrines - ventilées ameliorées (VIP) - shared") %>%
  shared_fac(QH109_22, QH109_22_sh, "Type of toilet facility: Fosses/latrines - avec dalles - shared") %>%
  shared_fac(QH109_23, QH109_23_sh, "Type of toilet facility: Fosses/latrines - sans dalles/trou ouvert - shared") %>%
  shared_fac(QH109_31, QH109_31_sh, "Type of toilet facility: Toilettes à compostage - shared") %>%
  shared_fac(QH109_41, QH109_41_sh, "Type of toilet facility: Seau/tinette - shared") %>%
  shared_fac(QH109_51, QH109_51_sh, "Type of toilet facility: Toilettes /latrines suspendues - shared") %>%
  shared_fac(QH109_96, QH109_96_sh, "Type of toilet facility: Autre - shared") %>%
  
  # Type of cooking fuel 
  dichotomize(hv226, hv226 == 1, QH113_1, "Type of cooking fuel: Electricité") %>%
  dichotomize(hv226, hv226 == 2, QH113_2, "Type of cooking fuel: Gaz propane liquifié (GPL)") %>%
  dichotomize(hv226, hv226 == 3, QH113_3, "Type of cooking fuel: Gaz naturel") %>%
  dichotomize(hv226, hv226 == 4, QH113_4, "Type of cooking fuel: Biogaz") %>%
  dichotomize(hv226, hv226 == 5, QH113_5, "Type of cooking fuel: Kérosène/Petrole") %>%
  dichotomize(hv226, hv226 == 6, QH113_6, "Type of cooking fuel: Charbon, lignite") %>%
  dichotomize(hv226, hv226 == 7, QH113_7, "Type of cooking fuel: Charbon de bois") %>%
  dichotomize(hv226, hv226 == 8, QH113_8, "Type of cooking fuel: Bois") %>%
  dichotomize(hv226, hv226 == 9, QH113_9, "Type of cooking fuel: Paille/Branche/Herbes") %>%
  dichotomize(hv226, hv226 == 10, QH113_10, "Type of cooking fuel: Résidus agricoles") %>%
  # The commented-out SPSS variable (hv226=11) is skipped
  dichotomize(hv226, hv226 == 95, QH113_95, "Type of cooking fuel: Pas de repas préparé dans le ménage") %>%
  dichotomize(hv226, hv226 == 11 | hv226 == 96, QH113_96, "Type of cooking fuel: Autre/Bouse") %>%
  
  # Cows/bulls
  categorize_livestock(hv246b, "QH118A",
                       list(c(1,4), c(5,9), c(10,98)), 
                       c("Cows/bulls: 1-4", "Cows/bulls: 5-9", "Cows/bulls: 10+")) %>%
  
  # Zébus
  categorize_livestock(hv246g, "QH118B",
                       list(c(1,4), c(5,9), c(10,98)), 
                       c("Zébus: 1-4", "Zébus: 5-9", "Zébus: 10+")) %>%
  
  # Horses/donkeys/mules
  categorize_livestock(hv246c, "QH118C", 
                       list(c(1,4), c(5,9), c(10,98)), 
                       c("Horses/donkeys/mules: 1-4", "Horses/donkeys/mules: 5-9", "Horses/donkeys/mules: 10+")) %>%
  
  # Goats
  categorize_livestock(hv246d, "QH118D",
                       list(c(1,4), c(5,9), c(10,98)), 
                       c("Goats: 1-4", "Goats: 5-9", "Goats: 10+")) %>%
  
  # Sheep
  categorize_livestock(hv246e, "QH118E",
                       list(c(1,4), c(5,9), c(10,98)), 
                       c("Sheep: 1-4", "Sheep: 5-9", "Sheep: 10+")) %>%
  
  # Chickens/poultry (different range)
  categorize_livestock(hv246f, "QH118F", 
                       list(c(1,9), c(10,29), c(30,98)), 
                       c("Chickens or other poultry: 1-9", "Chickens or other poultry: 10-29", "Chickens or other poultry: 30+")) %>%
  
  # Ducks/geese/turkeys
  categorize_livestock(hv246h, "QH118G", 
                       list(c(1,4), c(5,9), c(10,98)), 
                       c("Canards/Oies/Dindes: 1-4", "Canards/Oies/Dindes: 5-9", "Canards/Oies/Dindes: 10+")) %>%
  
  # Pigs
  categorize_livestock(hv246i, "QH118H", 
                       list(c(1,4), c(5,9), c(10,98)), 
                       c("Cochons: 1-4", "Cochons: 5-9", "Cochons: 10+")) %>%
  
  # Define land area
  mutate(
    landarea = hv245,  # Assign hv245 to landarea
    landarea = if_else(is.na(hv245) | hv245 >= 99.8, 99.9, landarea),  # Set to 99.9 if missing or >= 99.8
    landarea = if_else(is.na(hv244) | hv244 != 1, 0, landarea)  # Set to 0 if QH119 is missing or not 1
  ) %>%
  
  # Household assets
  no2zero(QH121A, hv206) %>%   # Electricity
  no2zero(QH121B, hv207) %>%   # Radio
  no2zero(QH121C, hv208) %>%   # Television
  no2zero(QH121D, hv221) %>%   # Telephone (non-mobile)
  no2zero(QH121E, hv243e) %>%  # Computer
  no2zero(QH121F, hv209) %>%   # Refrigerator
  no2zero(QH121G, sh121g) %>%  # Bed
  no2zero(QH121H, sh121h) %>%  # Table
  no2zero(QH121I, sh121i) %>%  # Chair
  no2zero(QH121J, sh121j) %>%  # Sofa
  no2zero(QH121K, sh121k) %>%  # Sewing machine
  no2zero(QH121L, sh121l) %>%  # Fan
  no2zero(QH121M, sh121m) %>%  # DVD player
  no2zero(QH121N, sh121n) %>%  # Water heater
  
  # Personal assets
  no2zero(QH122A, hv243b) %>% # Watch
  no2zero(QH122B, hv243a) %>% # Mobile phone
  no2zero(QH122C, hv210) %>%  # Bicycle
  no2zero(QH122D, hv211) %>%  # Motorcycle or scooter
  no2zero(QH122E, hv243c) %>% # Animal drawn cart
  no2zero(QH122F, hv212) %>%  # Car or truck
  no2zero(QH122G, hv243d) %>% # Boat with motor
  
  # Financial acces
  no2zero(QH123, hv247) %>%   # Has a bank account
  
  # Main floor material
  dichotomize(hv213, hv213 == 11, QH142_11, "Main floor material: Terre/sable") %>%
  dichotomize(hv213, hv213 == 12, QH142_12, "Main floor material: Bouse") %>%
  dichotomize(hv213, hv213 == 21, QH142_21, "Main floor material: Planches en bois") %>%
  dichotomize(hv213, hv213 == 22, QH142_22, "Main floor material: Palmes/bambou") %>%
  dichotomize(hv213, hv213 == 23, QH142_23, "Main floor material: Nattes") %>%
  dichotomize(hv213, hv213 == 31, QH142_31, "Main floor material: Parquet ou bois ciré") %>%
  dichotomize(hv213, hv213 == 32, QH142_32, "Main floor material: Bandes de vinyles/asphalte") %>%
  dichotomize(hv213, hv213 == 33, QH142_33, "Main floor material: Carrelage") %>%
  dichotomize(hv213, hv213 == 34, QH142_34, "Main floor material: Ciment") %>%
  dichotomize(hv213, hv213 == 35, QH142_35, "Main floor material: Moquette") %>%
  dichotomize(hv213, hv213 == 96, QH142_96, "Main floor material: Autre") %>%
  
  # Main roof material
  dichotomize(hv215, hv215 == 11, QH143_11, "Main roof material: Pas de toit") %>%
  dichotomize(hv215, hv215 == 12, QH143_12, "Main roof material: Chaume/feuilles/herbes") %>%
  dichotomize(hv215, hv215 == 13, QH143_13, "Main roof material: Mottes de terre") %>%
  dichotomize(hv215, hv215 == 21, QH143_21, "Main roof material: Natte") %>%
  dichotomize(hv215, hv215 == 22, QH143_22, "Main roof material: Palme/bambou") %>%
  dichotomize(hv215, hv215 == 23, QH143_23, "Main roof material: Planches en bois") %>%
  dichotomize(hv215, hv215 == 24, QH143_24, "Main roof material: Carton") %>%
  dichotomize(hv215, hv215 == 31, QH143_31, "Main roof material: Tôle") %>%
  dichotomize(hv215, hv215 == 32, QH143_32, "Main roof material: Bois") %>%
  dichotomize(hv215, hv215 == 33, QH143_33, "Main roof material: Zinc/fibre de ciment") %>%
  dichotomize(hv215, hv215 == 34, QH143_34, "Main roof material: Tuiles") %>%
  dichotomize(hv215, hv215 == 35, QH143_35, "Main roof material: Ciment") %>%
  dichotomize(hv215, hv215 == 36, QH143_36, "Main roof material: Shingles") %>%
  dichotomize(hv215, hv215 == 96, QH143_96, "Main roof material: Autre") %>%
  
  # Main wall material
  dichotomize(hv214, hv214 == 11, QH144_11, "Main wall material: Pas de mur") %>%
  dichotomize(hv214, hv214 == 12, QH144_12, "Main wall material: Bambou/Cane/Palme/Tronc") %>%
  dichotomize(hv214, hv214 == 13, QH144_13, "Main wall material: Terre") %>%
  dichotomize(hv214, hv214 == 21, QH144_21, "Main wall material: Bambou avec boue") %>%
  dichotomize(hv214, hv214 == 22, QH144_22, "Main wall material: Pierres avec boue") %>%
  dichotomize(hv214, hv214 == 23, QH144_23, "Main wall material: Adobe non recouvert") %>%
  dichotomize(hv214, hv214 == 24, QH144_24, "Main wall material: Contre-Plaque") %>%
  dichotomize(hv214, hv214 == 25, QH144_25, "Main wall material: Carton") %>%
  dichotomize(hv214, hv214 == 26, QH144_26, "Main wall material: Bois de récupération") %>%
  dichotomize(hv214, hv214 == 31, QH144_31, "Main wall material: Ciment") %>%
  dichotomize(hv214, hv214 == 32, QH144_32, "Main wall material: Pierres avec chaux/ciment") %>%
  dichotomize(hv214, hv214 == 33, QH144_33, "Main wall material: Briques") %>%
  dichotomize(hv214, hv214 == 34, QH144_34, "Main wall material: Blocs de ciment") %>%
  dichotomize(hv214, hv214 == 35, QH144_35, "Main wall material: Adobe recouvert") %>%
  dichotomize(hv214, hv214 == 36, QH144_36, "Main wall material: Planches en bois/Shingles") %>%
  dichotomize(hv214, hv214 == 37, QH144_37, "Main wall material: Tôle") %>%
  dichotomize(hv214, hv214 == 96, QH144_96, "Main wall material: Autres") %>%
  
  # Members sleeping
  mutate(
    hv216 = if_else(is.na(hv216) | hv216 == 0, hv012, hv216),  # Replace hv216 if 0 or NA with hv012
    memsleep = trunc(hv012 / hv216),  # Ensure integer values
    memsleep = if_else(is.na(hv216) | hv216 >= 99 | memsleep >= 98, NA_real_, memsleep)  # Assign NA instead of 99
  ) %>%
  set_variable_labels(memsleep = "Number of members per sleeping room") %>%
  
  # Set rural / urban
  mutate(
    urban = as.integer(hv025 == 1),  # Urban is 1 if hv025 == 1, else 0
    rural = as.integer(hv025 == 2)   # Rural is 1 if hv025 == 2, else 0
  ) %>%
  
  # Recoding of 3 variables is not documented in DHS SPSS example, although they are used in the PCA
  no2zero(LAND, hv244) # Owns land
# MISSING VARIABLES : HOUSE + DOMESTIC

factor_vars_2021 <- c(
  "QH101_11", "QH101_12", "QH101_13", "QH101_14", "QH101_21", "QH101_31", "QH101_32", "QH101_41", "QH101_42", "QH101_51", 
  "QH101_61", "QH101_71", "QH101_81", "QH101_91", "QH101_96",
  "QH109_11", "QH109_12", "QH109_13", "QH109_14", "QH109_15", "QH109_21", "QH109_22", "QH109_23", "QH109_31", "QH109_41", 
  "QH109_51", "QH109_61", "QH109_96",
  "QH109_11_sh", "QH109_12_sh", "QH109_13_sh", "QH109_14_sh", "QH109_15_sh", "QH109_21_sh", "QH109_22_sh", "QH109_23_sh", 
  "QH109_31_sh", "QH109_41_sh", "QH109_51_sh", "QH109_96_sh",
  "QH113_1", "QH113_2", "QH113_3", "QH113_4", "QH113_5", "QH113_6", "QH113_7", "QH113_8", "QH113_9", "QH113_10", 
  "QH113_95", "QH113_96",
  "QH121A", "QH121B", "QH121C", "QH121D", "QH121E", "QH121F", "QH121G", "QH121H", "QH121I", "QH121J", "QH121K", 
  "QH121L", "QH121M", "QH121N", "QH122A", "QH122B", "QH122C", "QH122D", "QH122E", "QH122F", "QH122G", "QH123",
  "QH142_11", "QH142_12", "QH142_21", "QH142_22", "QH142_23", "QH142_31", "QH142_32", "QH142_33", "QH142_34", "QH142_35", "QH142_96",
  "QH143_11", "QH143_12", "QH143_13", "QH143_21", "QH143_22", "QH143_23", "QH143_24", "QH143_31", "QH143_32", "QH143_33", 
  "QH143_34", "QH143_35", "QH143_36", "QH143_96",
  "QH144_11", "QH144_12", "QH144_13", "QH144_21", "QH144_22", "QH144_23", "QH144_24", "QH144_25", "QH144_26", "QH144_31", 
  "QH144_32", "QH144_33", "QH144_34", "QH144_35", "QH144_36", "QH144_37", "QH144_96",
  "LAND", "memsleep" # Variables manquantes : "DOMESTIC", "HOUSE"
)

hh_2021_rec <- test %>%
  mutate(across(all_of(factor_vars_2021), ~ as.numeric(replace_na(., 0))))

# Remove zero-variance variables
zero_var_cols <- hh_2021_rec %>%
  select(all_of(factor_vars_2021)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "variance") %>%
  filter(variance == 0) %>%
  pull(variable)

factor_vars_2021 <- setdiff(factor_vars_2021, zero_var_cols)  # Exclude those variables

# Run PCA only on valid variables
pca_result_2021 <- principal(
  cor(hh_2021_rec %>% select(all_of(factor_vars_2021)), use = "pairwise.complete.obs"), 
  nfactors = 1, rotate = "none", scores = TRUE, covar = FALSE
)


file_path <- "../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_wealth_index/Madagascar DHS 2021_simplified.xlsx"

# Read the sheets
common_pca <- read_excel(file_path, sheet = "Common")

# Extract variable names and labels
common_pca_clean <- common_pca %>%
  mutate(
    variable = str_extract(`Component Score Coefficient Matrix`, "^[^ ]+"), # Extract first word (variable name)
    description = str_remove(`Component Score Coefficient Matrix`, "^[^ ]+ ") # Remove variable name from description
  )

# Extract PCA loadings from R
r_pca_loadings <- tibble(
  variable = rownames(pca_result_2021$loadings),
  r_pca_loading = pca_result_2021$loadings[, 1]
)

# Merge with DHS PCA results
comparison <- common_pca_clean %>%
  left_join(r_pca_loadings, by = "variable") %>%
  select(variable, description, `DHS Factor Score` = `Component`, r_pca_loading)

# ¨Plot PCA loadings
ggplot(comparison, aes(x = as.numeric(`DHS Factor Score`), y = r_pca_loading)) +
  geom_point() +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "DHS Loadings vs. PCA Loadings",
    x = "DHS Factor Loadings",
    y = "Reproduced PCA Loadings"
  ) +
  theme_minimal()

# Compute correlation between DHS factor scores and R PCA loadings
corr_2021_loadings <- cor.test(as.numeric(comparison$`DHS Factor Score`), comparison$r_pca_loading)
print(corr_2021_loadings)

hh_2021_rec <- hh_2021_rec %>%
  mutate(
    factor_score = as.vector(scale(hh_2021_rec %>% select(all_of(factor_vars_2021))) %*% pca_result_2021$loadings[, 1])
  )

# Scatter plot: hv271 vs Computed Factor Score
ggplot(hh_2021_rec, aes(x = hv271, y = factor_score)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "hv271 vs Computed Factor Score",
    x = "hv271 (Wealth Index Score)",
    y = "Computed Factor Score"
  ) +
  theme_minimal()

```

Les points sont alignés le long de la ligne bleue indiquant qu'il existe une corrélation positive entre le hv271 (wealth index score) et le factor score. La reproduction du wealth index par l'ACP est conforme aux codes SPSS de DHS. Nous allons maintenant réaliser une analyse factorielle spécifiquement pour les ménages urbaines.

```{r}
# Filter urban households
hh_urban_2021 <- hh_2021_rec %>% filter(urban == 1)

# Selection variable
factor_vars_urban_2021 <- c(
  "QH101_11", "QH101_12", "QH101_13", "QH101_14", "QH101_21",
  "QH101_31", "QH101_32", "QH101_41", "QH101_42", "QH101_51", 
  "QH101_61", "QH101_71", "QH101_81", "QH101_91", 
  "QH109_11", "QH109_12", "QH109_13", "QH109_14", "QH109_15", 
  "QH109_21", "QH109_22", "QH109_23", "QH109_31", "QH109_41", 
  "QH109_51", "QH109_61", "QH109_96", 
  "QH109_11_sh", "QH109_12_sh", "QH109_13_sh", "QH109_14_sh", "QH109_15_sh", 
  "QH109_21_sh", "QH109_22_sh", "QH109_23_sh", "QH109_31_sh", "QH109_41_sh", 
  "QH109_51_sh", "QH109_96_sh", 
  "QH113_1", "QH113_2", "QH113_3", "QH113_4", "QH113_5", 
  "QH113_6", "QH113_7", "QH113_8", "QH113_9", "QH113_10", 
  "QH113_95", "QH113_96", 
  "QH121A", "QH121B", "QH121C", "QH121D", "QH121E", "QH121F", 
  "QH121G", "QH121H", "QH121I", "QH121J", "QH121K", "QH121L", 
  "QH121M", "QH121N", 
  "QH122A", "QH122B", "QH122C", "QH122D", "QH122E", "QH122F", "QH122G", 
  "QH123", 
  "QH142_11", "QH142_12", "QH142_21", "QH142_22", "QH142_23", 
  "QH142_31", "QH142_32", "QH142_33", "QH142_34", "QH142_35", 
  "QH142_96", 
  "QH143_11", "QH143_12", "QH143_13", "QH143_21", "QH143_22", 
  "QH143_23", "QH143_24", "QH143_31", "QH143_32", "QH143_33", 
  "QH143_34", "QH143_35", "QH143_36", "QH143_96", 
  "QH144_11", "QH144_12", "QH144_13", "QH144_21", "QH144_22", 
  "QH144_23", "QH144_24", "QH144_25", "QH144_26", "QH144_31", 
  "QH144_32", "QH144_33", "QH144_34", "QH144_35", "QH144_36", 
  "QH144_37", "QH144_96",
  "LAND", "memsleep",
  "QH118A_1", "QH118A_2", "QH118A_3", "QH118B_1", "QH118B_2", "QH118B_3", 
  "QH118C_1", "QH118C_2", "QH118C_3", "QH118D_1", "QH118D_2", "QH118D_3", 
  "QH118E_1", "QH118E_2", "QH118E_3", "QH118F_1", "QH118F_2", "QH118F_3", 
  "QH118G_1", "QH118G_2", "QH118G_3", "QH118H_1", "QH118H_2", "QH118H_3", 
  "landarea" # Variables manquantes : "DOMESTIC", "HOUSE"
)

# Replace NA by the mean
hh_urban_2021_rec <- hh_urban_2021_rec %>%
  mutate(across(all_of(factor_vars_urban_2021), ~ ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))


# Remove zero-variance variables
zero_var_cols <- hh_urban_2021_rec %>%
  select(all_of(factor_vars_urban_2021)) %>%
  summarise(across(everything(), ~ var(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "variance") %>%
  filter(variance == 0) %>%
  pull(variable)

factor_vars_urban_2021 <- setdiff(factor_vars_urban_2021, zero_var_cols)  # Exclude those variables

# Run PCA
pca_urban_2021 <- fa(hh_urban_2021_rec %>% select(all_of(factor_vars_urban_2021)), 
                nfactors = 1, fm = "pc", rotate = "none", scores = "regression")



```

### Récupération de la variable hv270a (wealth index de la zone rurale) pour l'année 2021

Le processus consiste à charger les données DHS 1997, 2008 et 2021. DHS 1997 et DHS 2008 ne comprend que les scores factoriels de l'indice de richesse utilisé dans l'enquête, on va dans un premier temps récupérer le wealth index des ménages ruraux de DHS 2021.

```{r}
# Définition du chemin du dossier principal
main_folder <- "../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/"

# Load DHS data
load_data <- function(year, type){
  year_folder <- paste0(main_folder, "DHS_", year)
  
# Get the .shp (GPS) and .dta (household) file paths
  if (type == "HR") {
    hr_path <- list.files(year_folder, pattern = ".*HR.*\\.dta$", full.names = TRUE, recursive = TRUE, ignore.case = TRUE)
    out <- read_dta(hr_path) #Lecture du fichier .dta
  } else if (type == "GPS") {
    shp_path <- list.files(year_folder, pattern = "\\.shp$", full.names = TRUE, recursive = TRUE)
    out <- st_read(shp_path, quiet = TRUE) %>%
      st_transform(4326) #Lecture du fichier .shp
  } else {
    print("data type unknown, must be HR or GPS")
  }
  return (out) 
}
  
# Execute the function for a specific year
  dhs_1997_hr <- load_data(1997, "HR")
  dhs_1997_gps <- load_data(1997, "GPS")
  
  dhs_2008_hr <- load_data(2008, "HR")
  dhs_2008_gps <- load_data(2008, "GPS")
  
  dhs_2021_hr <- load_data(2021, "HR")
  dhs_2021_gps <- load_data(2021, "GPS")
  
# Recover the variable hv270a (rural wealth index) for 2021
dhs_2021_hr <- load_data(2021, "HR")

hv270a_2021 <- dhs_2021_hr %>% 
  filter(hv025 == 2) %>% # Filtrage des ménages ruraux 
  select(hhid, hv270a) %>%
  rename(wealth_index_rural = hv270a)
```

> **Pas de production des codes ?**

### Reproduction du wealth index hv270 pour 2008

Reproduction du wealth index hv271 de DHS 2008

Dans un premier temps, nous procéderons au recodage des variables pertinentes issues de l'ensemble des données des ménages de DHS afin de constituer l'indice de richesse. Les valeurs manquantes seront imputées soit par la moyenne des variables pour les variables dichotomisées, soit par zéro pour les variables liées à l'élevage. A partir des données recodées, nous établirons une matrice de corrélation pour les variables sélectionnées et réaliserons une analyse en composante principale afin d'extraire la première composante principale, représentant le facteur d'indice de richesse. Nous calculerons ensuite les scores factoriels pour chaque ménage en utilisant les coefficients issues de l'ACP. Enfin, nous effectuerons une comparaison des scores reconstruits pour chaque ménage avec les scores factoriels officiels de DHS (hv271), en utilisant à la fois une analyse graphique et un test de corrélation.

```{r}

# Reproduce the wealth index factor score hv271 for 2008 

# Load necessary libraries
library(labelled)
library(janitor)
library(psych)

# Load DHS Data 
hh_2008 <- read_dta("../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/DHS_2008/MDHR51DT/MDHR51FL.DTA")

# Step 1: Recode relevant variables from the DHS household dataset
hh_2008 <- hh_2008 %>%
filter(hv015 == 1)

hv271_2008 <- hh_2008 %>%
  mutate(
    # water source
    h2oires = if_else(hv201 == 11, 1, 0),
    h2oyard = if_else(hv201 == 12, 1, 0),
    h2opub = if_else(hv201 == 13, 1, 0),
    h2owell = if_else(hv201 == 21, 1, 0),
    h2opwell = if_else(hv201 == 31, 1, 0),
    h2ouwell = if_else(hv201 == 32, 1, 0),
    h2spring = if_else(hv201 %in% c(41, 42), 1, 0),
    h2osurf = if_else(hv201 == 43, 1, 0),
    h2ooth = if_else(hv201 > 50 & hv201 < 97, 1, 0),
    # Toilet types
    flushp = if_else((hv205 > 10 & hv205 < 15) & hv225 == 0, 1, 0),
    flushs = if_else((hv205 > 10 & hv205 < 15) & hv225 == 1, 1, 0),
    latvipp = if_else(hv205 == 21 & hv225 == 0, 1, 0),
    latvips = if_else(hv205 == 21 & hv225 == 1, 1, 0),
    latslbp = if_else(hv205 %in% c(22, 23) & hv225 == 0, 1, 0),
    latslbs = if_else(hv205 %in% c(22, 23) & hv225 == 1, 1, 0),
    latopp = if_else(hv205 == 24 & hv225 == 0, 1, 0),
    latops = if_else(hv205 == 24 & hv225 == 1, 1, 0),
    latbush = if_else(hv205 == 31, 1, 0),
    latothp = if_else((hv205 > 40 & hv205 < 44) & hv225 == 0, 1, 0),
    latoths = if_else((hv205 > 40 & hv205 < 44) & hv225 == 1, 1, 0),
    # Amenities
    electric = if_else(hv206 == 1, 1, 0),
    radio = if_else(hv207 == 1, 1, 0),
    tv = if_else(hv208 == 1, 1, 0),
    fridge = if_else(hv209 == 1, 1, 0),
    bicycle = if_else(hv210 == 1, 1, 0),
    motobk = if_else(hv211 == 1, 1, 0),
    car = if_else(hv212 == 1, 1, 0),
    mphone = if_else(hv243a == 1, 1, 0),
    watch = if_else(hv243b == 1, 1, 0),
    bank = if_else(hv247 == 1, 1, 0),
    # floor type variables
    dirtfloo = if_else(hv213 %in% c(11, 12), 1, 0),
    plnkfloo = if_else(hv213 == 21, 1, 0),
    palmfloo = if_else(hv213 == 22, 1, 0),
    matfloo = if_else(hv213 %in% c(23, 96), 1, 0),
    parqfloo = if_else(hv213 == 31, 1, 0),
    vinfloo = if_else(hv213 == 32, 1, 0),
    tilefloo = if_else(hv213 == 33, 1, 0),
    cemtfloo = if_else(hv213 == 34, 1, 0),
    carpfloo = if_else(hv213 == 35, 1, 0),
    # Cooking fuel
    cookelec = if_else(hv226 == 1, 1, 0),
    cooklpg = if_else(hv226 %in% c(2, 3, 4, 5), 1, 0),
    cookcoal = if_else(hv226 %in% c(6, 7), 1, 0),
    cookwood = if_else(hv226 == 8, 1, 0),
    cookstrw = if_else(hv226 %in% c(9, 10, 11), 1, 0),
    cooknone = if_else(hv226 %in% c(95, 96), 1, 0),
    #wall materials
    grnwall = if_else(hv214 == 12, 1, 0),
    dirtwall = if_else(hv214 %in% c(11, 13), 1, 0),
    bamwall = if_else(hv214 %in% c(21, 22), 1, 0),
    rwdwall = if_else(hv214 %in% c(23, 24, 25, 26), 1, 0),
    cmtwall = if_else(hv214 == 31, 1, 0),
    stncwall = if_else(hv214 == 32, 1, 0),
    brckwall = if_else(hv214 == 33, 1, 0),
    blckwall = if_else(hv214 == 34, 1, 0),
    woodwall = if_else(hv214 == 36, 1, 0),
    othwall = if_else(hv214 == 96, 1, 0),
    # roofing materials
    natroof = if_else(hv215 %in% c(11, 12), 1, 0),
    sodroof = if_else(hv215 == 13, 1, 0),
    rudroof = if_else(hv215 %in% c(21, 22, 24), 1, 0),
    plnkroof = if_else(hv215 == 23, 1, 0),
    ironroof = if_else(hv215 %in% c(31, 95, 96), 1, 0),
    woodroof = if_else(hv215 == 32, 1, 0),
    cemtroof = if_else(hv215 %in% c(33, 35, 36), 1, 0),
    tileroof = if_else(hv215 == 34, 1, 0),
    # Handle missing values for hv216 and compute members per sleeping room
    hv216 = if_else(is.na(hv216)|hv216 == 0, hv012, hv216),
    memsleep = hv012 / hv216,
    # pondération
    hhmemwt = hv005 / 1000000 * hv012,
    wt = hv005 / 1000000
  )

# Step 2: Store variable names for reuse
dich_vars_2008 <- c(
  "h2oires", "h2oyard", "h2opub", "h2owell", "h2opwell", "h2ouwell",
  "h2spring", "h2osurf", "h2ooth", "flushp", "flushs", "latvipp", "latvips",
  "latslbp", "latslbs", "latopp", "latops", "latbush", "latothp", "latoths",
  "electric", "radio", "tv", "fridge", "bicycle", "motobk", "car", "mphone",
  "watch", "bank", "memsleep", "dirtfloo", "plnkfloo", "palmfloo", "matfloo",
  "parqfloo", "vinfloo", "tilefloo", "cemtfloo", "carpfloo", "cookelec",
  "cooklpg", "cookcoal", "cookwood", "cookstrw", "cooknone", "grnwall",
  "dirtwall", "bamwall", "rwdwall", "cmtwall", "stncwall", "brckwall",
  "blckwall", "woodwall", "othwall", "natroof", "sodroof", "rudroof",
  "plnkroof", "ironroof", "woodroof", "cemtroof", "tileroof"
)

animal_husbandry_vars <- c(
  "hv246a", "hv246b", "hv246c", "hv246d", "hv246e", "hv246f", "hv246g", "hv246h"
)

all_factor_vars_2008 <- c(dich_vars_2008 , animal_husbandry_vars)

# Step 3 : Compute a correlation matrix for the selected variables

# Perform PCA
perform_pca <- function(data, vars) {
  cor_matrix <- cor(data %>% select(all_of(vars)), use = "complete.obs")
  principal(cor_matrix, nfactors = 1, rotate = "none", scores = TRUE, covar = FALSE)
}

pca_result <- perform_pca(hv271_2008, c(dich_vars_2008, animal_husbandry_vars))

# Extract PCA loadings and compute factor scores
hv271_2008 <- hv271_2008 %>%
  mutate(
    factor_score = as.vector(scale(hv271_2008 %>% select(all_of(dich_vars_2008), all_of(animal_husbandry_vars))) %*% pca_result$loadings[, 1])
  )

# Step 4:  Comparison and Visualization
comparison <- tibble(
  variable = paste0("Var", seq_along(pca_result$loadings[, 1])), # Replace with actual names if needed
  dhs_factor_score = c(0.051, 0.036, 0.044, 0.001, 0.006, -0.023, -0.027, -0.040, -0.004,
                       0.049, 0.024, 0.005, 0.010, 0.012, 0.018, 0.011, 0.033, -0.070,
                       0.004, 0.010, 0.096, 0.053, 0.094, 0.060, 0.035, 0.036, 0.047,
                       0.090, 0.072, 0.067, -0.035, -0.022, 0.009, -0.022, -0.059,
                       0.037, 0.004, 0.032, 0.066, 0.007, 0.016, 0.029, 0.084, -0.088,
                       -0.002, 0.001, -0.035, -0.042, -0.017, 0.006, 0.047, 0.013,
                       0.054, 0.014, 0.009, 0.008, -0.047, -0.043, -0.008, -0.007,
                       0.085, -0.005, 0.009, 0.017, -0.017, -0.004, 0.000, -0.009,
                       -0.009, -0.007, -0.003, 0.005), # SPSS values
  r_pca_loading = pca_result$loadings[, 1]
)

# Plot: DHS Loadings vs PCA Loadings
ggplot(comparison, aes(x = dhs_factor_score, y = r_pca_loading)) +
  geom_point() +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "DHS Loadings vs. PCA Loadings",
    x = "DHS Factor Loadings",
    y = "Reproduced PCA Loadings"
  ) +
  theme_minimal()
```

[Interprétation du graphique]{.underline}

Le graphique compare les saturations officiels obtenues par DHS (axe des x) et les saturation reproduites par l'ACP (axe des y). Chaque point sur le graphique représente une variable incluse dans le calcul du wealth index. La ligne bleue, qui représente un ajustement linéaire des points, montre une forte corrélation entre les deux séries de saturations, confirmant ainsi que la reconstruction des scores reproduit fidèlement les calculs officiels de DHS.

```{r}
# Correlation and visualization
corr_2008_loadings <- cor.test(comparison$dhs_factor_score, comparison$r_pca_loading)
corr_2008_loadings
```

[Interprétation du test de corrélation]{.underline}

Le test calcule la corrélation entre les wealth index factor score officiels du DHS et les saturations reproduites par l'ACP. Les résultats démontrent que les scores factoriels du wealth index de DHS et les saturations reproduites par l'ACP sont extrêmement corrélés avec un coefficient de 0.9999555, ou que les séries sont pratiquement identiques.

```{r}
# Plot: hv271 vs Factor Score
ggplot(hv271_2008, aes(x = hv271, y = factor_score)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "hv271 vs Computed Factor Score",
    x = "hv271 (Wealth Index Score)",
    y = "Computed Factor Score"
  ) +
  theme_minimal()

# Perform a correlation test between hv271 and factor_score
corr_2008_obs <- cor.test(hv271_2008$hv271, hv271_2008$factor_score, use = "complete.obs")
corr_2008_obs
```

[Interprétation:]{.underline}

Le graphique compare hv271 avec les scores factoriels du wealth index reproduites par l'analyse par composante principale. Les résultats stipulent qu'il y a une forte concentration des points autour de la droite de régression et que le coefficient de corrélation de Pearson indique une corrélation extrêmement forte et positive entre les deux variables (wealth index score hv271 et les scores factoriels calculés).

2.  Reproduction du wealth index hv270 de DHS 2008

Nous calculons le wealth index hv270 de DHS 2008 à partir des scores factoriels reproduits à l'aide de l'ACP générés précédemment. Puis, on crée un classement de hv270 en divisant les scores factoriels en quintiles. Enfin, on attribue un rang (quintile) à chaque ménage en fonction du score du wealth index.

```{r}
# Calculate wealth index quintile (hv270)
hv271_2008 <- hv271_2008 %>%
  mutate(
    hv270_2008 = ntile(factor_score, 5)  # Divise hv270 en 5 quintiles égaux
  )

# Check quintile distribution
print(table(hv271_2008$hv270_2008))
print(summary(hv271_2008$hv270_2008))

# Pearson and Spearman correlation test with DHS wealth scores(hv271)
hv270_2008_corr <- cor(hv271_2008$hv270_2008, hv271_2008$hv270, method = "pearson", use = "complete.obs")
hv270bis_2008_corr <- cor(hv271_2008$hv270_2008, hv271_2008$hv270, method = "spearman", use = "complete.obs")
```

Les résultats des tests de corrélation se rapprochent et donc les quintiles de richesse reproduisent bien la structure de de hv271.

```{r}
# Calculate descriptive statistics by quintile
stats_quintiles_2008 <- hv271_2008 %>%
  group_by(hv270_2008) %>%
  summarise(
    mean_factor_score = mean(factor_score, na.rm = TRUE),
    median_factor_score = median(factor_score, na.rm = TRUE),
    sd_factor_score = sd(factor_score, na.rm = TRUE),
    n = n()
  )

print(stats_quintiles_2008)

# Visualization wealth index quintiles
ggplot(hv271_2008, aes(x = as.factor(hv270_2008), y = factor_score, fill = as.factor(hv270_2008))) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3) +
  labs(
    title = "Distribution de l'indice de richesse (hv270) par quintile",
    x = "Quintile de richesse",
    y = "Indice de richesse (factor_score)"
  ) +
  scale_fill_brewer(palette = "Blues") +
  theme_minimal() +
  theme(legend.position = "none")

```

Le boxplot montre la distribution de l'indice de richesse pour chaque quintile (1 correspond aux 20% des ménages les plus pauvres et 5 aux 20 % des ménages les plus riches). La ligne médiane représente la médiane du factor score pour le quintile et les points dispersés autour montrent la répartition des observations individuelles.Il se trouve que Chaque quintile couvre une plage différente des scores factoriels, confirmant que l'indice de richesse varie significativement entre les quintiles.

### Reproduction du wealth index DHS 1997

1.  Reproduction du wealth index hv271 de DHS 1997

Nous recodons les variables pertinentes issues de l'ensemble des données des ménages de DHS afin de constituer l'indice de richesse. Les procédures de recodage ne sont pas fournies et donc pour cette étape, nous allons analyser les étiquettes des variables recodées et le contenu du questionnaire de 1997.

```{r}
# Reproduce the wealth index hv271 for 1997 

# Load necessary libraries
library(labelled)
library(janitor)
library(psych)

# Load DHS Data 
hh_1997 <- read_dta("../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/DHS_1997/MDHR31DT/MDHR31FL.DTA")


# Step 1: Recode relevant variables from the DHS household dataset
hv271_1997 <- hh_1997 %>% 
  mutate(
    # Specific to 1997 ---------------------
    # Toilet types (latbush below)
    fown = if_else((hv205 == 10 | hv205 == 11), 1, 0),
    latpit  = if_else((hv205 == 20 | hv205 == 21), 1, 0),
    latvip = if_else(hv205 == 22, 1, 0),
    latother = if_else(hv205 == 96, 1, 0),
    latbush = if_else(hv205 == 31, 1, 0),
    # Phone
    phone = if_else(hv221 == 1, 1, 0),
    # Same as 2008 ------------------------
    # water source
    h2oires = if_else(hv201 == 11, 1, 0), # "If piped drinking water in residence"
    h2oiwell = if_else(hv201 == 22, 1, 0), # "If has a well in residence"
    h2osurf = if_else(hv201 %in% c(31, 32, 33, 34), 1, 0), # "If uses river, canal or surface water for drinking"
    h2ooth = if_else(hv201 > 51, 1, 0), # "Other source of drinking water"
    h2ocessi = if_else(hv201 == 23, 1, 0), # "If gets water from an open well/hole/cesspool in residence"
    h2orain = if_else(hv201 == 41, 1, 0), # "If rain for drinking water"
    h2opub = if_else(hv201 == 13, 1, 0), # "If uses a public faucet (piped)"
    h2ocesso = if_else(hv201 == 26, 1, 0), # "If gets water from open well/hole/cesspool outside residence"
    h2oores = if_else(hv201 == 12, 1, 0), # "If has piped water outside residence"
    h2bores = if_else(hv201 == 21, 1, 0), # "If has borehole with pump in residence"
    h2oboout = if_else(hv201 == 24, 1, 0), # "If has borehole with pump outside of residence"
    h2oowell = if_else(hv201 == 25, 1, 0), # "If has well outside of residence"
    h2otruck = if_else(hv201 == 51, 1, 0),# "If gets water from a tanker truck"
    # Amenities
    electric = if_else(hv206 == 1, 1, 0),
    radio = if_else(hv207 == 1, 1, 0),
    tv = if_else(hv208 == 1, 1, 0),
    fridge = if_else(hv209 == 1, 1, 0),
    bicycle = if_else(hv210 == 1, 1, 0),
    motobk = if_else(hv211 == 1, 1, 0),
    car = if_else(hv212 == 1, 1, 0),
    # floor type variables
    dirtfloo = if_else(hv213 %in% c(11, 12), 1, 0),
    woodfloo = if_else(hv213 == 21, 1, 0),
    palmfloo = if_else(hv213 == 22, 1, 0),
    parqfloo = if_else(hv213 == 31, 1, 0),
    vinfloo = if_else(hv213 == 32, 1, 0),
    tilefloo = if_else(hv213 == 33, 1, 0),
    cemtfloo = if_else(hv213 == 34, 1, 0),
    carpfloo = if_else(hv213 == 35, 1, 0),
    othfloor = if_else(hv213 == 96, 1, 0),
    # Handle missing values for hv216 and compute members per sleeping room
    hv216 = if_else(is.na(hv216)|hv216 == 0, hv012, hv216),
    memsleep = hv012 / hv216,
    # pondération
    hhmemwt = hv005 / 1000000 * hv012,
    wt = hv005 / 1000000
  )
# Compute ownland variable 
ir_1997 <- read_dta("../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/DHS_1997/MDIR31DT/MDIR31FL.DTA")

# Compute ownland variable for households
ownland_by_household <- ir_1997 %>%
  select(v001, v002, own_land_partner = v707, own_land_respondent = v740) %>%
  mutate(
    # Convert to binary (1 if owns land personally or by family, 0 otherwise)
    own_land_partner = if_else(own_land_partner %in% c(1, 2), 1, 0, missing = 0),
    own_land_respondent = if_else(own_land_respondent %in% c(1, 2), 1, 0, missing = 0),
    own_any_land = own_land_partner + own_land_respondent) %>%
  group_by(v001, v002) %>%
  summarise(ownland = sum(own_any_land, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(ownland = ifelse(ownland > 0, 1, 0))

# Add ownland variable to hh_1997 by joining on hv001 and hv002
hv271_1997 <- hv271_1997 %>%
  left_join(ownland_by_household, by = c("hv001" = "v001", "hv002" = "v002"))
# Check number of unmatched (we do not have data for all hh)
sum(is.na(hv271_1997$ownland))

# Replace NA in ownland with 0 (if household doesn't have any matching members)
hv271_1997 <- hv271_1997 %>%
  mutate(ownland = if_else(is.na(ownland), 0, ownland))

# Define the equivalent variables for 1997 based on SPSS specification and recoded names
pca_loading_dhs <- tibble::tribble(
       ~code,                                            ~variable, ~dhs_factor,
  "electric",                                    "Has electricity",  0.15080,
     "radio",                                          "Has radio",  0.10360,
        "tv",                                     "Has television",  0.13631,
    "fridge",                                   "Has refrigerator",  0.08574,
   "bicycle",                                        "Has bicycle",  0.04035,
    "motobk",                                     "Has motorcycle",  0.04297,
       "car",                                            "Has car",  0.07643,
     "phone",                                      "Has telephone",  0.06839,
   "ownland",     "If household works own or family's agric. land",  -0.09713,
  "memsleep",                "Number of members per sleeping room",  -0.05370,
   "h2oires",               "If piped drinking water in residence",  0.11394,
  "h2oiwell",                         "If has a well in residence",  0.01202,
   "h2osurf", "If uses river, canal or surface water for drinking",  -0.10437,
    "h2ooth",                     "Other source of drinking water",  -0.00177,
      "fown",                           "If uses own flush toilet",  0.09723,
  "h2ocessi",    "Water from open well/hole/cesspool in residence",  0.00524,
   "latbush",                      "If uses bush,field as latrine",  -0.12692,
  "latother",                           "If other type of latrine",  0.00208,
  "dirtfloo",      "If has dirt, sand, dung as  floor in dwelling",  -0.00042,
  "woodfloo",     "If has wood, plank principal floor in dwelling",  0.03547,
  "cemtfloo",                      "If has cement principal floor",  0.08999,
  "othfloor",                      "If has other type of flooring",  -0.00141,
   "h2orain",                         "If rain for drinking water",  -0.00163,
    "h2opub",                    "If uses a public faucet (piped)",  0.08025,
  "h2ocesso",         "Water from open well/hole/cesspool outside",  -0.02915,
    "latpit",                   "If uses a traditional pit toilet",  0.08954,
    "latvip",                              "If uses a VIP latrine",  0.00948,
  "parqfloo",             "If has parquet or polished wood floors",  0.07280,
  "tilefloo",            "If has tiles for main flooring material",  0.03367,
  "palmfloo",          "If has palm or bamboo for floor materials",  -0.12683,
  "carpfloo",                           "If has carpeted flooring",  0.01799,
   "h2oores",               "If has piped water outside residence",  0.01861,
   "h2bores",             "If has borehole with pump in residence",  0.01642,
  "h2oboout",     "If has borehole with pump outside of residence",  -0.01110,
  "h2oowell",                   "If has well outside of residence",  -0.00205,
  "h2otruck",                  "If gets water from a tanker truck",  -0.00265
  )

all_factor_vars_1997 <- pca_loading_dhs$code

# Step 2: Replace missing values
hv271_1997 <- hv271_1997 %>%
  mutate(across(all_of(all_factor_vars_1997),
                ~ if_else(is.na(.), mean(., na.rm = TRUE), .)))
 
# Step 3 : Compute a correlation matrix for the selected variables

# Perform PCA
#pca_result_1997 <- perform_pca(hv271_1997, all_factor_vars_1997)
pca_result_1997 <- principal(hv271_1997 %>% select(all_of(all_factor_vars_1997)), nfactors = 1, rotate = "none")


# Add factor scores to the dataset
hv271_1997 <- hv271_1997 %>%
  mutate(
    factor_score = as.vector(scale(hv271_1997 %>% 
                                     select(all_of(all_factor_vars_1997))) %*% 
                               pca_result_1997$loadings[, 1]))

# Create a tibble for DHS scores and R PCA loadings
r_pca_loadings <- tibble(
  code = rownames(pca_result_1997$loadings),
  r_pca_loading = as.vector(pca_result_1997$loadings[, 1])
)

# Step 4:  Comparison and Visualization

# Join the tibbles and calculate differences
comparison <- left_join(pca_loading_dhs, r_pca_loadings, by = "code") %>%
  mutate(difference = r_pca_loading - dhs_factor)

# Plot 1: DHS Loadings vs PCA Loadings
ggplot(comparison, aes(x = dhs_factor, y = r_pca_loading)) +
  geom_point() +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "DHS Loadings vs. PCA Loadings (1997)",
    x = "DHS Factor Loadings",
    y = "Reproduced PCA Loadings"
  ) +
  theme_minimal()

# Calculate and print the correlation
correlation <- cor.test(comparison$dhs_factor, comparison$r_pca_loading, use = "complete.obs")
print(correlation)
```

[Interprétation]{.underline}: Le graphique compare les saturations officiels obtenues par DHS (axe des x) et les saturation reproduites par l'ACP (axe des y). Chaque point sur le graphique représente une variable incluse dans le calcul du wealth index. La ligne bleue, qui représente un ajustement linéaire des points, montre une forte corrélation entre les deux séries de saturations, confirmant ainsi que la reconstruction des scores reproduit les calculs officiels de DHS. Cependant, nous allons effectuer des tests de corrélations pour vérifier la qualité des reconstructions du fait qu'un point se décale à gauche de la ligne bleue.

```{r}
# Calculate and print the correlation
correlation <- cor.test(comparison$dhs_factor, comparison$r_pca_loading, use = "complete.obs")
print(correlation)
```

Le test de corrélation indique que l'ACP produit bien les pondérations utilisées par le DHS avec un coefficient égale à 0.992924. Nous allons vérifier la qualité de l'ACP.

```{r}
#Vérification de la qualité de PCA
print(pca_result_1997$values / sum(pca_result_1997$values))

#Vérification de la structure des données 
summary(hv271_1997 %>% select(all_of(all_factor_vars_1997)))
#Evaluation du nombre optimal des facteurs 
fa.parallel(hv271_1997 %>% select(all_of(all_factor_vars_1997)), fa = "pc")
```

[Interprétation]{.underline}: Le graphique montre que la matrice de corrélation contient des valeurs propres négatives ou nulles qui empêchent certains calculs d'être correctement effectués. Nous allons alors identifier les variables qui sont redondantes ou trop corrélées.

```{r}
cor_matrix <- cor(hv271_1997 %>% select(all_of(all_factor_vars_1997)), use = "pairwise.complete.obs")
eigen(cor_matrix)$values

```

Les premières composantes ont des plus grandes valeurs que les suivantes. Les valeurs deviennent plus petites après les premières composantes indiquant que ces composantes contiennent de moins en moins d'informations utiles. On retrouve des valeurs très proches de zéro avec une valeur négative dans les dernières composantes.

```{r}

highly_correlated <- findCorrelation(cor_matrix, cutoff = 0.9)  # Seuil à ajuster
print(highly_correlated)


highly_correlated <- findCorrelation(cor_matrix, cutoff = 0.75)
print(highly_correlated)

```

interprétation: Il a été détecté que 17 variable de la matrice de corrélation est fortement corrélée avec au moins une autre variable selon le seuil de 0.75

```{r}
screeplot(prcomp(hv271_1997 %>% select(all_of(all_factor_vars_1997)), scale = TRUE), type = "lines")

pca_result <- prcomp(hv271_1997 %>% select(all_of(all_factor_vars_1997)), scale = TRUE)
cumsum(pca_result$sdev^2) / sum(pca_result$sdev^2)
```

```{r}
# Component extraction
hv271_1997$wealth_index <- pca_result$x[, 1]

# Check wealth index distribution
summary(hv271_1997$wealth_index)
hist(hv271_1997$wealth_index, breaks = 30, main = "Distribution de l'indice de richesse", col = "lightblue")


```

Interprétation: la distribution de l'indice de richesse est asymétrique et donc nous devons normaliser les données.

2.  Reproduction du wealth index hv270 de DHS 1997

### Recalcul du wealth index hv270a pour 1997 et 2008

1.  Calcul du wealth index hv270a pour 2021

```{r}
# Extracting variables
wealth_data_2021 <- dhs_2021_hr %>%
  select(hhid, hv025, hv271, hv270) %>%
  rename(factor_score = hv271, wealth_quintile = hv270)

# Recalculation of quintiles for 2021
wealth_data_2021 <- wealth_data_2021 %>%
  mutate(
    hv270a_2021 = ntile(factor_score, 5)  
  )

# Séparate quintiles for urban and rural areas

# Quintiles for urban households
wealth_urban_2021 <- wealth_data_2021 %>%
  filter(hv025 == 1) %>%
  mutate(hv270a_urban_2021 = ntile(factor_score, 5))

# Quintiles for rural households
wealth_rural_2021 <- wealth_data_2021 %>%
  filter(hv025 == 2) %>%
  mutate(hv270a_rural_2021 = ntile(factor_score, 5))

# Correlation Test
hv270a_2021_corr <- cor(wealth_data_2021$hv270a_2021, wealth_data_2021$wealth_quintile, method = "pearson", use = "complete.obs")
hv270a_2021_corr_spearman <- cor(wealth_data_2021$hv270a_2021, wealth_data_2021$wealth_quintile, method = "spearman", use = "complete.obs")

# Displaying results
print(paste("Corrélation Pearson :", round(hv270a_2021_corr, 3)))
print(paste("Corrélation Spearman :", round(hv270a_2021_corr_spearman, 3)))

```

2.  Calcul du wealth index hv270a pour 2008

    [**Urban**]{.underline}

```{r}
# Filter urban households
hv271_urban_2008 <- hv271_2008 %>%
  filter(hv025 == 1)

# Calculate the quintile specific to urban households (hv270a)
hv271_urban_2008 <- hv271_urban_2008 %>%
  mutate(
    hv270a_urban_2008 = ntile(factor_score, 5)  
  )

# Check the distribution of quintiles
print(table(hv271_urban_2008$hv270a_urban_2008))
print(summary(hv271_urban_2008$hv270a_urban_2008))

# Test the correlation between hv270a_2008 and hv270 (DHS)
hv270a_urban_2008_corr <- cor(hv271_urban_2008$hv270a_urban_2008, hv271_urban_2008$hv270, method = "pearson", use = "complete.obs")
hv270abis_urban_2008_corr <- cor(hv271_urban_2008$hv270a_urban_2008, hv271_urban_2008$hv270, method = "spearman", use = "complete.obs")

# Visualization
print(hv270a_urban_2008_corr)
print(hv270abis_urban_2008_corr)
```

[**RURAL**]{.underline}

```{r}
# Filter rural households
hv271_rural_2008 <- hv271_2008 %>%
  filter(hv025 == 2)

# Calculate the quintile specific to rural households (hv270a)
hv271_rural_2008 <- hv271_rural_2008 %>%
  mutate(
    hv270a_rural_2008 = ntile(factor_score, 5)  
  )

# Check the distribution of quintiles
print(table(hv271_rural_2008$hv270a_rural_2008))
print(summary(hv271_rural_2008$hv270a_rural_2008))

# Test the correlation between hv270a_2008 and hv270 (DHS)
hv270a_rural_2008_corr <- cor(hv271_rural_2008$hv270a_rural_2008, hv271_rural_2008$hv270, method = "pearson", use = "complete.obs")
hv270abis_rural_2008_corr<- cor(hv271_rural_2008$hv270a_rural_2008, hv271_rural_2008$hv270, method = "spearman", use = "complete.obs")

# Visualization
print(hv270a_rural_2008_corr)
print(hv270abis_rural_2008_corr)

```

[**Comparaison de rural et urbain par rapport à hv270 de DHS**]{.underline}

```{r}

# Scatterplot pour l'urbain
ggplot(hv271_urban_2008, aes(x = hv270a_urban_2008, y = hv270)) +
  geom_jitter(alpha = 0.5, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  labs(title = "Corrélation entre Quintiles Urbains et Indice DHS",
       x = "Quintile Recalculé (hv270a)",
       y = "Indice DHS (hv270)") +
  theme_minimal()

# Scatterplot pour le rural
ggplot(hv271_rural_2008, aes(x = hv270a_rural_2008, y = hv270)) +
  geom_jitter(alpha = 0.5, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  labs(title = "Corrélation entre Quintiles Ruraux et Indice DHS",
       x = "Quintile Recalculé (hv270a)",
       y = "Indice DHS (hv270)") +
  theme_minimal()



```

[Interprétation:]{.underline} On peut voir sur le graphique que la tendance rouge est proche d'une droite diagonale donc la corrélation est forte entre hv270 et hv270a.

2.  Segmentation de wealth index en centiles

3.  Calcul du Z score standardisé du wealth index

4.  Ajout des variables âges et sexes du chef de ménage dans l'analyse

## Data on the household geophysical environment

Nous allons utiliser le package R mapme.biodiversity (<https://mapme-initiative.github.io/mapme.biodiversity/index.html>) pour charger et extraire les données sur la couverture forestière, la pente et l'altitude, la densité de population, l'accessibilité en 2000.

```{r}
# Library
library(sf) # Pour les données spatiales 
library(progressr) # Pour avoir des barres de progression
library(tictoc) # Pour minuter le temps d'exécution
library(future) # Pour permettre du calcul parallèle
library(lubridate) # Gestion des dates
library(codebook)
library(gt)
library(terra) # Manipulation des données raster 
library(geodata)

# Définir le chemin absolu pour ton répertoire local
outdir <- "C:/Users/irian/Documents/Statistiques/PA-livelihood-impact-dhs2/Data"

# Créer le répertoire si il n'existe pas déjà
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

# Vérifier si le répertoire a bien été créé
if (dir.exists(outdir)) {
  cat("Répertoire créé ou déjà existant : ", outdir)
} else {
  cat("Le répertoire n'a pas pu être créé.")
}
mapme_options(
  outdir = outdir,
  verbose = TRUE
              )

```

### Définition des unités d'analyse

L'unité d'analyse de cette études est le ménage.

```{r clusters}
library(dplyr)
library(sf)
library(stringr)
library(purrr)
library(haven)
library(tmap)
library(readr)

# Function to read DHS data for the specified year and identifier 
load_dhs_data <- function(dhs_folder, year, identifier){
  folder_pattern <- paste0(".*", year, ".*", identifier)
  
  matching_folder <- list.dirs(dhs_folder, full.names = TRUE, recursive = TRUE) %>%
    keep(~ str_detect(.x, folder_pattern))
  
  if (length(matching_folder) == 0) {
    stop("No folder found for the specified year and identifier.")
  }
  
  if (identifier == "GE") {
    file_pattern <- "\\.shp$"
    data_loader <- function(file) st_read(file, quiet = TRUE)
  } else {
    file_pattern <- "\\.[Dd][Tt][Aa]$"
    data_loader <- read_dta
  }
  
  target_file <- list.files(matching_folder, pattern = file_pattern, 
                            full.names = TRUE)
  
  if (length(target_file) == 0) {
    stop("No valid file found in the folder.")
  }
  
  data <- data_loader(target_file)
  return(data)
}

# Localisation des données 
dhs_folder <- "C:/Users/irian/Documents/IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data"
  
# Load DHS data
  load_data <- function(year, type, dhs_folder) {
  year_folder <- file.path(dhs_folder, paste0("DHS_", year))
  
  # Get the .shp (GPS) and .dta (household) file paths
  if (type == "HR") {
    hr_path <- list.files(year_folder, pattern = ".*HR.*\\.dta$", full.names = TRUE, recursive = TRUE, ignore.case = TRUE)
    if (length(hr_path) == 0) stop("No HR file found for the specified year.")
    out <- read_dta(hr_path) # Lecture du fichier .dta
  } else if (type == "GPS") {
    shp_path <- list.files(year_folder, pattern = "\\.shp$", full.names = TRUE, recursive = TRUE)
    if (length(shp_path) == 0) stop("No GPS file found for the specified year.")
    out <- st_read(shp_path, quiet = TRUE) %>%
      st_transform(4326) # Lecture du fichier .shp
  } else {
    stop("Data type unknown, must be HR or GPS")
  }
  return(out) 
}
  
# Execute the function for a specific year
  hr_2008 <- load_data(2008, "HR", dhs_folder)
  gps_2008 <- load_data(2008, "GPS", dhs_folder)
  
  hr_2021 <- load_data(2021, "HR", dhs_folder)
  gps_2021 <- load_data(2021, "GPS", dhs_folder)
  
# Vérification des données GPS
  print(gps_2008)
  print(gps_2021)
  
  st_geometry(gps_2008)
  st_geometry(gps_2021)
  
# Create clusters
  if (!"DHSCLUST" %in% colnames(gps_2008)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}
  
  if (!"DHSCLUST" %in% colnames(gps_2021)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}
  
# Création des buffers de 10 km autour des points GPS
  buffer_10km_2008 <- gps_2008 %>%
    st_buffer(dist = 10000)
  
  buffer_10km_2021 <- gps_2021 %>%
    st_buffer(dist = 10000)

# Charger les contours de Madagascar
  if (file.exists("data/grille_mada_laborde.rds")) {
  grille_mada_laborde <- read_rds("data/grille_mada_laborde.rds") 
} else {
  contour_mada_laborde <- gadm(country = "Madagascar", resolution = 1, level = 4, path = "data") %>%
    st_as_sf() %>%
    st_transform(29702)
  saveRDS(contour_mada_laborde, "data/grille_mada_laborde.rds")
}
   
# Visualiser les buffers et les points GPS 
tmap_mode("view")

# Visualisation des données pour 2008
tm_shape(contour_mada_laborde) +
  tm_borders(col = "black") +
  tm_shape(buffer_10km_2008) +
  tm_polygons(col = "lightblue", border.col = "darkblue", fill_alpha = 0.5) +
  tm_shape(gps_2008) +
  tm_dots(col = "red", size = 0.5) +
  tm_layout() +  # Utiliser tm_layout() pour la mise en page générale
  tm_title("Clusters 2008 avec Buffers 10km et Contours de Madagascar")  

# Visualisation des données pour 2021
tm_shape(contour_mada_laborde) +
  tm_borders(col = "black") +
  tm_shape(buffer_10km_2021) +
  tm_polygons(col = "lightgreen", border.col = "darkgreen", fill_alpha = 0.5) +
  tm_shape(gps_2021) +
  tm_dots(col = "blue", size = 0.5) +
  tm_layout() +  # Utiliser tm_layout() pour la mise en page générale
  tm_title("Clusters 2021 avec Buffers 10km et Contours de Madagascar")  


# Créer un sauvegarde des clusters
output_folder <- file.path(dhs_folder, "household_cluster_RDS")
if (!dir.exists(output_folder)) {
  dir.create(output_folder, recursive = TRUE)
}

# Sauvegarder les clusters avec le nom "household_cluster"
saveRDS(buffer_10km_2008, file = file.path(output_folder, "household_cluster_2008.rds"))
saveRDS(buffer_10km_2021, file = file.path(output_folder, "household_cluster_2021.rds"))

# Message de confirmation
cat("Les fichiers household_cluster_2008.rds et household_cluster_2021.rds ont été sauvegardés avec succès.\n")

```
