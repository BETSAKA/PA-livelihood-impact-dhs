---
title: "PA-livelihood-impact-dhs"
author: "Iriana Razafimahenina"
format: 
  html:
   out-put-file: index.html
   embed-resources: true
   standalone: true
   code-fold: true
  execute: 
   warning: false
   error: false
editor: visual
editor-options: 
   chunk_out_type: console
Bibliography: references.bib
---

## Environnement

```{r}
library(tidyverse) #Manipulation et visualisation des données
library(haven) #Importation des données
library(writexl) #Exportation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(codebook) #Documentation et mise en forme des données 
library(gt) #Mise en forme des tableaux 
library(survey) #Analyse des données d'enquêtes
library(MatchIt) #Matching
library(ggplot2) #Figure

```

## Data structuring

Nous allons chargé les données nécessaires à l'analyse.

## Socioeconomic household data

### Récupération de la variable hv270a (wealth index de la zone rurale) pour l'année 2021

Le processus consiste à charger les données DHS 1997, 2008 et 2021. DHS 1997 et DHS 2008 ne comprend que les scores factoriels de l'indice de richesse utilisé dans l'enquête, on va dans un premier temps récupérer le wealth index des ménages ruraux de DHS 2021.

```{r}
# Définition du chemin du dossier principal
main_folder <- "../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/"

# Load DHS data
load_data <- function(year, type){
  year_folder <- paste0(main_folder, "DHS_", year)
  
# Get the .shp (GPS) and .dta (household) file paths
  if (type == "HR") {
    hr_path <- list.files(year_folder, pattern = ".*HR.*\\.dta$", full.names = TRUE, recursive = TRUE, ignore.case = TRUE)
    out <- read_dta(hr_path) #Lecture du fichier .dta
  } else if (type == "GPS") {
    shp_path <- list.files(year_folder, pattern = "\\.shp$", full.names = TRUE, recursive = TRUE)
    out <- st_read(shp_path, quiet = TRUE) %>%
      st_transform(4326) #Lecture du fichier .shp
  } else {
    print("data type unknown, must be HR or GPS")
  }
  return (out) 
}
  
# Execute the function for a specific year
  dhs_1997_hr <- load_data(1997, "HR")
  dhs_1997_gps <- load_data(1997, "GPS")
  
  dhs_2008_hr <- load_data(2008, "HR")
  dhs_2008_gps <- load_data(2008, "GPS")
  
  dhs_2021_hr <- load_data(2021, "HR")
  dhs_2021_gps <- load_data(2021, "GPS")
  
# Recover the variable hv270a (rural wealth index) for 2021
dhs_2021_hr <- load_data(2021, "HR")

hv270a_2021 <- dhs_2021_hr %>% 
  filter(hv025 == 2) %>% # Filtrage des ménages ruraux 
  select(hhid, hv270a) %>%
  rename(wealth_index_rural = hv270a)
```

### Reproduction du wealth index hv270 pour 2008

Cette section a pour objectif de reproduire le wealth index hv270 de DHS 2008. Dans un premier temps, nous reproduirons les scores factoriels du wealth index (hv271) à l'aide d'une analyse par composante principale (ACP), en nous basant sur le code SPSS utilisé par DHS pour construire cet indice. Le calcul des scores factoriels permet de créer un indicateur composite agrégant l'information des différentes variables de manière pondérée. Dans un second temps, nous reproduirons le wealth index hv270 de DHS 2008.

1.  Reproduction du wealth index hv271 de DHS 2008

Dans un premier temps, nous procéderons au recodage des variables pertinentes issues de l'ensemble des données des ménages de DHS afin de constituer l'indice de richesse. Les valeurs manquantes seront imputées soit par la moyenne des variables pour les variables dichotomisées, soit par zéro pour les variables liées à l'élevage. A partir des données recodées, nous établirons une matrice de corrélation pour les variables sélectionnées et réaliserons une analyse en composante principale afin d'extraire la première composante principale, représentant le facteur d'indice de richesse. Nous calculerons ensuite les scores factoriels pour chaque ménage en utilisant les coefficients issues de l'ACP. Enfin, nous effectuerons une comparaison des scores reconstruits pour chaque ménage avec les scores factoriels officiels de DHS (hv271), en utilisant à la fois une analyse graphique et un test de corrélation.

```{r}

# Reproduce the wealth index factor score hv271 for 2008 

# Load necessary libraries
library(labelled)
library(janitor)
library(psych)

# Load DHS Data 
hh_2008 <- read_dta("../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/DHS_2008/MDHR51DT/MDHR51FL.DTA")

# Step 1: Recode relevant variables from the DHS household dataset
hh_2008 <- hh_2008 %>%
filter(hv015 == 1)

hv271_2008 <- hh_2008 %>%
  mutate(
    # water source
    h2oires = if_else(hv201 == 11, 1, 0),
    h2oyard = if_else(hv201 == 12, 1, 0),
    h2opub = if_else(hv201 == 13, 1, 0),
    h2owell = if_else(hv201 == 21, 1, 0),
    h2opwell = if_else(hv201 == 31, 1, 0),
    h2ouwell = if_else(hv201 == 32, 1, 0),
    h2spring = if_else(hv201 %in% c(41, 42), 1, 0),
    h2osurf = if_else(hv201 == 43, 1, 0),
    h2ooth = if_else(hv201 > 50 & hv201 < 97, 1, 0),
    # Toilet types
    flushp = if_else((hv205 > 10 & hv205 < 15) & hv225 == 0, 1, 0),
    flushs = if_else((hv205 > 10 & hv205 < 15) & hv225 == 1, 1, 0),
    latvipp = if_else(hv205 == 21 & hv225 == 0, 1, 0),
    latvips = if_else(hv205 == 21 & hv225 == 1, 1, 0),
    latslbp = if_else(hv205 %in% c(22, 23) & hv225 == 0, 1, 0),
    latslbs = if_else(hv205 %in% c(22, 23) & hv225 == 1, 1, 0),
    latopp = if_else(hv205 == 24 & hv225 == 0, 1, 0),
    latops = if_else(hv205 == 24 & hv225 == 1, 1, 0),
    latbush = if_else(hv205 == 31, 1, 0),
    latothp = if_else((hv205 > 40 & hv205 < 44) & hv225 == 0, 1, 0),
    latoths = if_else((hv205 > 40 & hv205 < 44) & hv225 == 1, 1, 0),
    # Amenities
    electric = if_else(hv206 == 1, 1, 0),
    radio = if_else(hv207 == 1, 1, 0),
    tv = if_else(hv208 == 1, 1, 0),
    fridge = if_else(hv209 == 1, 1, 0),
    bicycle = if_else(hv210 == 1, 1, 0),
    motobk = if_else(hv211 == 1, 1, 0),
    car = if_else(hv212 == 1, 1, 0),
    mphone = if_else(hv243a == 1, 1, 0),
    watch = if_else(hv243b == 1, 1, 0),
    bank = if_else(hv247 == 1, 1, 0),
    # floor type variables
    dirtfloo = if_else(hv213 %in% c(11, 12), 1, 0),
    plnkfloo = if_else(hv213 == 21, 1, 0),
    palmfloo = if_else(hv213 == 22, 1, 0),
    matfloo = if_else(hv213 %in% c(23, 96), 1, 0),
    parqfloo = if_else(hv213 == 31, 1, 0),
    vinfloo = if_else(hv213 == 32, 1, 0),
    tilefloo = if_else(hv213 == 33, 1, 0),
    cemtfloo = if_else(hv213 == 34, 1, 0),
    carpfloo = if_else(hv213 == 35, 1, 0),
    # Cooking fuel
    cookelec = if_else(hv226 == 1, 1, 0),
    cooklpg = if_else(hv226 %in% c(2, 3, 4, 5), 1, 0),
    cookcoal = if_else(hv226 %in% c(6, 7), 1, 0),
    cookwood = if_else(hv226 == 8, 1, 0),
    cookstrw = if_else(hv226 %in% c(9, 10, 11), 1, 0),
    cooknone = if_else(hv226 %in% c(95, 96), 1, 0),
    #wall materials
    grnwall = if_else(hv214 == 12, 1, 0),
    dirtwall = if_else(hv214 %in% c(11, 13), 1, 0),
    bamwall = if_else(hv214 %in% c(21, 22), 1, 0),
    rwdwall = if_else(hv214 %in% c(23, 24, 25, 26), 1, 0),
    cmtwall = if_else(hv214 == 31, 1, 0),
    stncwall = if_else(hv214 == 32, 1, 0),
    brckwall = if_else(hv214 == 33, 1, 0),
    blckwall = if_else(hv214 == 34, 1, 0),
    woodwall = if_else(hv214 == 36, 1, 0),
    othwall = if_else(hv214 == 96, 1, 0),
    # roofing materials
    natroof = if_else(hv215 %in% c(11, 12), 1, 0),
    sodroof = if_else(hv215 == 13, 1, 0),
    rudroof = if_else(hv215 %in% c(21, 22, 24), 1, 0),
    plnkroof = if_else(hv215 == 23, 1, 0),
    ironroof = if_else(hv215 %in% c(31, 95, 96), 1, 0),
    woodroof = if_else(hv215 == 32, 1, 0),
    cemtroof = if_else(hv215 %in% c(33, 35, 36), 1, 0),
    tileroof = if_else(hv215 == 34, 1, 0),
    # Handle missing values for hv216 and compute members per sleeping room
    hv216 = if_else(is.na(hv216)|hv216 == 0, hv012, hv216),
    memsleep = hv012 / hv216,
    # pondération
    hhmemwt = hv005 / 1000000 * hv012,
    wt = hv005 / 1000000
  )

# Step 2: Store variable names for reuse
dich_vars_2008 <- c(
  "h2oires", "h2oyard", "h2opub", "h2owell", "h2opwell", "h2ouwell",
  "h2spring", "h2osurf", "h2ooth", "flushp", "flushs", "latvipp", "latvips",
  "latslbp", "latslbs", "latopp", "latops", "latbush", "latothp", "latoths",
  "electric", "radio", "tv", "fridge", "bicycle", "motobk", "car", "mphone",
  "watch", "bank", "memsleep", "dirtfloo", "plnkfloo", "palmfloo", "matfloo",
  "parqfloo", "vinfloo", "tilefloo", "cemtfloo", "carpfloo", "cookelec",
  "cooklpg", "cookcoal", "cookwood", "cookstrw", "cooknone", "grnwall",
  "dirtwall", "bamwall", "rwdwall", "cmtwall", "stncwall", "brckwall",
  "blckwall", "woodwall", "othwall", "natroof", "sodroof", "rudroof",
  "plnkroof", "ironroof", "woodroof", "cemtroof", "tileroof"
)

animal_husbandry_vars <- c(
  "hv246a", "hv246b", "hv246c", "hv246d", "hv246e", "hv246f", "hv246g", "hv246h"
)

all_factor_vars_2008 <- c(dich_vars_2008 , animal_husbandry_vars)

# Step 3 : Compute a correlation matrix for the selected variables

# Perform PCA
perform_pca <- function(data, vars) {
  cor_matrix <- cor(data %>% select(all_of(vars)), use = "complete.obs")
  principal(cor_matrix, nfactors = 1, rotate = "none", scores = TRUE, covar = FALSE)
}

pca_result <- perform_pca(hv271_2008, c(dich_vars_2008, animal_husbandry_vars))

# Extract PCA loadings and compute factor scores
hv271_2008 <- hv271_2008 %>%
  mutate(
    factor_score = as.vector(scale(hv271_2008 %>% select(all_of(dich_vars_2008), all_of(animal_husbandry_vars))) %*% pca_result$loadings[, 1])
  )

# Step 4:  Comparison and Visualization
comparison <- tibble(
  variable = paste0("Var", seq_along(pca_result$loadings[, 1])), # Replace with actual names if needed
  dhs_factor_score = c(0.051, 0.036, 0.044, 0.001, 0.006, -0.023, -0.027, -0.040, -0.004,
                       0.049, 0.024, 0.005, 0.010, 0.012, 0.018, 0.011, 0.033, -0.070,
                       0.004, 0.010, 0.096, 0.053, 0.094, 0.060, 0.035, 0.036, 0.047,
                       0.090, 0.072, 0.067, -0.035, -0.022, 0.009, -0.022, -0.059,
                       0.037, 0.004, 0.032, 0.066, 0.007, 0.016, 0.029, 0.084, -0.088,
                       -0.002, 0.001, -0.035, -0.042, -0.017, 0.006, 0.047, 0.013,
                       0.054, 0.014, 0.009, 0.008, -0.047, -0.043, -0.008, -0.007,
                       0.085, -0.005, 0.009, 0.017, -0.017, -0.004, 0.000, -0.009,
                       -0.009, -0.007, -0.003, 0.005), # SPSS values
  r_pca_loading = pca_result$loadings[, 1]
)

# Plot: DHS Loadings vs PCA Loadings
ggplot(comparison, aes(x = dhs_factor_score, y = r_pca_loading)) +
  geom_point() +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "DHS Loadings vs. PCA Loadings",
    x = "DHS Factor Loadings",
    y = "Reproduced PCA Loadings"
  ) +
  theme_minimal()
```

[Interprétation du graphique]{.underline}

Le graphique compare les saturations officiels obtenues par DHS (axe des x) et les saturation reproduites par l'ACP (axe des y). Chaque point sur le graphique représente une variable incluse dans le calcul du wealth index. La ligne bleue, qui représente un ajustement linéaire des points, montre une forte corrélation entre les deux séries de saturations, confirmant ainsi que la reconstruction des scores reproduit fidèlement les calculs officiels de DHS.

```{r}
# Correlation and visualization
corr_2008_loadings <- cor.test(comparison$dhs_factor_score, comparison$r_pca_loading)
corr_2008_loadings
```

[Interprétation du test de corrélation]{.underline}

Le test calcule la corrélation entre les wealth index factor score officiels du DHS et les saturations reproduites par l'ACP. Les résultats démontrent que les scores factoriels du wealth index de DHS et les saturations reproduites par l'ACP sont extrêmement corrélés avec un coefficient de 0.9999555, ou que les séries sont pratiquement identiques.

```{r}
# Plot: hv271 vs Factor Score
ggplot(hv271_2008, aes(x = hv271, y = factor_score)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "hv271 vs Computed Factor Score",
    x = "hv271 (Wealth Index Score)",
    y = "Computed Factor Score"
  ) +
  theme_minimal()

# Perform a correlation test between hv271 and factor_score
corr_2008_obs <- cor.test(hv271_2008$hv271, hv271_2008$factor_score, use = "complete.obs")
corr_2008_obs
```

[Interprétation:]{.underline}

Le graphique compare hv271 avec les scores factoriels du wealth index reproduites par l'analyse par composante principale. Les résultats stipulent qu'il y a une forte concentration des points autour de la droite de régression et que le coefficient de corrélation de Pearson indique une corrélation extrêmement forte et positive entre les deux variables (wealth index score hv271 et les scores factoriels calculés).

2.  Reproduction du wealth index hv270 de DHS 2008

Nous calculons le wealth index hv270 de DHS 2008 à partir des scores factoriels reproduits à l'aide de l'ACP générés précédemment. Puis, on crée un classement de hv270 en divisant les scores factoriels en quintiles. Enfin, on attribue un rang (quintile) à chaque ménage en fonction du score du wealth index.

```{r}
# Calculate wealth index quintile (hv270)
hv271_2008 <- hv271_2008 %>%
  mutate(
    hv270_2008 = ntile(factor_score, 5)  # Divise hv270 en 5 quintiles égaux
  )

# Check quintile distribution
print(table(hv271_2008$hv270_2008))
print(summary(hv271_2008$hv270_2008))

# Pearson and Spearman correlation test with DHS wealth scores(hv271)
hv270_2008_corr <- cor(hv271_2008$hv270_2008, hv271_2008$hv270, method = "pearson", use = "complete.obs")
hv270bis_2008_corr <- cor(hv271_2008$hv270_2008, hv271_2008$hv270, method = "spearman", use = "complete.obs")
```

Les résultats des tests de corrélation se rapprochent et donc les quintiles de richesse reproduisent bien la structure de de hv271.

```{r}
# Calculate descriptive statistics by quintile
stats_quintiles_2008 <- hv271_2008 %>%
  group_by(hv270_2008) %>%
  summarise(
    mean_factor_score = mean(factor_score, na.rm = TRUE),
    median_factor_score = median(factor_score, na.rm = TRUE),
    sd_factor_score = sd(factor_score, na.rm = TRUE),
    n = n()
  )

print(stats_quintiles_2008)

# Visualization wealth index quintiles
ggplot(hv271_2008, aes(x = as.factor(hv270_2008), y = factor_score, fill = as.factor(hv270_2008))) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3) +
  labs(
    title = "Distribution de l'indice de richesse (hv270) par quintile",
    x = "Quintile de richesse",
    y = "Indice de richesse (factor_score)"
  ) +
  scale_fill_brewer(palette = "Blues") +
  theme_minimal() +
  theme(legend.position = "none")

```

Le boxplot montre la distribution de l'indice de richesse pour chaque quintile (1 correspond aux 20% des ménages les plus pauvres et 5 aux 20 % des ménages les plus riches). La ligne médiane représente la médiane du factor score pour le quintile et les points dispersés autour montrent la répartition des observations individuelles.Il se trouve que Chaque quintile couvre une plage différente des scores factoriels, confirmant que l'indice de richesse varie significativement entre les quintiles.

### Reproduction du wealth index DHS 1997

1.  Reproduction du wealth index hv271 de DHS 1997

Nous recodons les variables pertinentes issues de l'ensemble des données des ménages de DHS afin de constituer l'indice de richesse. Les procédures de recodage ne sont pas fournies et donc pour cette étape, nous allons analyser les étiquettes des variables recodées et le contenu du questionnaire de 1997.

```{r}
# Reproduce the wealth index hv271 for 1997 

# Load necessary libraries
library(labelled)
library(janitor)
library(psych)

# Load DHS Data 
hh_1997 <- read_dta("../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/DHS_1997/MDHR31DT/MDHR31FL.DTA")


# Step 1: Recode relevant variables from the DHS household dataset
hv271_1997 <- hh_1997 %>% 
  mutate(
    # Specific to 1997 ---------------------
    # Toilet types (latbush below)
    fown = if_else((hv205 == 10 | hv205 == 11), 1, 0),
    latpit  = if_else((hv205 == 20 | hv205 == 21), 1, 0),
    latvip = if_else(hv205 == 22, 1, 0),
    latother = if_else(hv205 == 96, 1, 0),
    latbush = if_else(hv205 == 31, 1, 0),
    # Phone
    phone = if_else(hv221 == 1, 1, 0),
    # Same as 2008 ------------------------
    # water source
    h2oires = if_else(hv201 == 11, 1, 0), # "If piped drinking water in residence"
    h2oiwell = if_else(hv201 == 22, 1, 0), # "If has a well in residence"
    h2osurf = if_else(hv201 %in% c(31, 32, 33, 34), 1, 0), # "If uses river, canal or surface water for drinking"
    h2ooth = if_else(hv201 > 51, 1, 0), # "Other source of drinking water"
    h2ocessi = if_else(hv201 == 23, 1, 0), # "If gets water from an open well/hole/cesspool in residence"
    h2orain = if_else(hv201 == 41, 1, 0), # "If rain for drinking water"
    h2opub = if_else(hv201 == 13, 1, 0), # "If uses a public faucet (piped)"
    h2ocesso = if_else(hv201 == 26, 1, 0), # "If gets water from open well/hole/cesspool outside residence"
    h2oores = if_else(hv201 == 12, 1, 0), # "If has piped water outside residence"
    h2bores = if_else(hv201 == 21, 1, 0), # "If has borehole with pump in residence"
    h2oboout = if_else(hv201 == 24, 1, 0), # "If has borehole with pump outside of residence"
    h2oowell = if_else(hv201 == 25, 1, 0), # "If has well outside of residence"
    h2otruck = if_else(hv201 == 51, 1, 0),# "If gets water from a tanker truck"
    # Amenities
    electric = if_else(hv206 == 1, 1, 0),
    radio = if_else(hv207 == 1, 1, 0),
    tv = if_else(hv208 == 1, 1, 0),
    fridge = if_else(hv209 == 1, 1, 0),
    bicycle = if_else(hv210 == 1, 1, 0),
    motobk = if_else(hv211 == 1, 1, 0),
    car = if_else(hv212 == 1, 1, 0),
    # floor type variables
    dirtfloo = if_else(hv213 %in% c(11, 12), 1, 0),
    woodfloo = if_else(hv213 == 21, 1, 0),
    palmfloo = if_else(hv213 == 22, 1, 0),
    parqfloo = if_else(hv213 == 31, 1, 0),
    vinfloo = if_else(hv213 == 32, 1, 0),
    tilefloo = if_else(hv213 == 33, 1, 0),
    cemtfloo = if_else(hv213 == 34, 1, 0),
    carpfloo = if_else(hv213 == 35, 1, 0),
    othfloor = if_else(hv213 == 96, 1, 0),
    # Handle missing values for hv216 and compute members per sleeping room
    hv216 = if_else(is.na(hv216)|hv216 == 0, hv012, hv216),
    memsleep = hv012 / hv216,
    # pondération
    hhmemwt = hv005 / 1000000 * hv012,
    wt = hv005 / 1000000
  )
# Compute ownland variable 
ir_1997 <- read_dta("../../IRD_Drive/BETSAKA_MADAGASCAR/Données/Enquêtes ménages/DHS Madagascar/DHS_data/DHS_1997/MDIR31DT/MDIR31FL.DTA")

# Compute ownland variable for households
ownland_by_household <- ir_1997 %>%
  select(v001, v002, own_land_partner = v707, own_land_respondent = v740) %>%
  mutate(
    # Convert to binary (1 if owns land personally or by family, 0 otherwise)
    own_land_partner = if_else(own_land_partner %in% c(1, 2), 1, 0, missing = 0),
    own_land_respondent = if_else(own_land_respondent %in% c(1, 2), 1, 0, missing = 0),
    own_any_land = own_land_partner + own_land_respondent) %>%
  group_by(v001, v002) %>%
  summarise(ownland = sum(own_any_land, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(ownland = ifelse(ownland > 0, 1, 0))

# Add ownland variable to hh_1997 by joining on hv001 and hv002
hv271_1997 <- hv271_1997 %>%
  left_join(ownland_by_household, by = c("hv001" = "v001", "hv002" = "v002"))
# Check number of unmatched (we do not have data for all hh)
sum(is.na(hv271_1997$ownland))

# Replace NA in ownland with 0 (if household doesn't have any matching members)
hv271_1997 <- hv271_1997 %>%
  mutate(ownland = if_else(is.na(ownland), 0, ownland))

# Define the equivalent variables for 1997 based on SPSS specification and recoded names
pca_loading_dhs <- tibble::tribble(
       ~code,                                            ~variable, ~dhs_factor,
  "electric",                                    "Has electricity",  0.15080,
     "radio",                                          "Has radio",  0.10360,
        "tv",                                     "Has television",  0.13631,
    "fridge",                                   "Has refrigerator",  0.08574,
   "bicycle",                                        "Has bicycle",  0.04035,
    "motobk",                                     "Has motorcycle",  0.04297,
       "car",                                            "Has car",  0.07643,
     "phone",                                      "Has telephone",  0.06839,
   "ownland",     "If household works own or family's agric. land",  -0.09713,
  "memsleep",                "Number of members per sleeping room",  -0.05370,
   "h2oires",               "If piped drinking water in residence",  0.11394,
  "h2oiwell",                         "If has a well in residence",  0.01202,
   "h2osurf", "If uses river, canal or surface water for drinking",  -0.10437,
    "h2ooth",                     "Other source of drinking water",  -0.00177,
      "fown",                           "If uses own flush toilet",  0.09723,
  "h2ocessi",    "Water from open well/hole/cesspool in residence",  0.00524,
   "latbush",                      "If uses bush,field as latrine",  -0.12692,
  "latother",                           "If other type of latrine",  0.00208,
  "dirtfloo",      "If has dirt, sand, dung as  floor in dwelling",  -0.00042,
  "woodfloo",     "If has wood, plank principal floor in dwelling",  0.03547,
  "cemtfloo",                      "If has cement principal floor",  0.08999,
  "othfloor",                      "If has other type of flooring",  -0.00141,
   "h2orain",                         "If rain for drinking water",  -0.00163,
    "h2opub",                    "If uses a public faucet (piped)",  0.08025,
  "h2ocesso",         "Water from open well/hole/cesspool outside",  -0.02915,
    "latpit",                   "If uses a traditional pit toilet",  0.08954,
    "latvip",                              "If uses a VIP latrine",  0.00948,
  "parqfloo",             "If has parquet or polished wood floors",  0.07280,
  "tilefloo",            "If has tiles for main flooring material",  0.03367,
  "palmfloo",          "If has palm or bamboo for floor materials",  -0.12683,
  "carpfloo",                           "If has carpeted flooring",  0.01799,
   "h2oores",               "If has piped water outside residence",  0.01861,
   "h2bores",             "If has borehole with pump in residence",  0.01642,
  "h2oboout",     "If has borehole with pump outside of residence",  -0.01110,
  "h2oowell",                   "If has well outside of residence",  -0.00205,
  "h2otruck",                  "If gets water from a tanker truck",  -0.00265
  )

all_factor_vars_1997 <- pca_loading_dhs$code

# Step 2: Replace missing values
hv271_1997 <- hv271_1997 %>%
  mutate(across(all_of(all_factor_vars_1997),
                ~ if_else(is.na(.), mean(., na.rm = TRUE), .)))
 
# Step 3 : Compute a correlation matrix for the selected variables

# Perform PCA
#pca_result_1997 <- perform_pca(hv271_1997, all_factor_vars_1997)
pca_result_1997 <- principal(hv271_1997 %>% select(all_of(all_factor_vars_1997)), nfactors = 1, rotate = "none")


# Add factor scores to the dataset
hv271_1997 <- hv271_1997 %>%
  mutate(
    factor_score = as.vector(scale(hv271_1997 %>% 
                                     select(all_of(all_factor_vars_1997))) %*% 
                               pca_result_1997$loadings[, 1]))

# Create a tibble for DHS scores and R PCA loadings
r_pca_loadings <- tibble(
  code = rownames(pca_result_1997$loadings),
  r_pca_loading = as.vector(pca_result_1997$loadings[, 1])
)

# Step 4:  Comparison and Visualization

# Join the tibbles and calculate differences
comparison <- left_join(pca_loading_dhs, r_pca_loadings, by = "code") %>%
  mutate(difference = r_pca_loading - dhs_factor)

# Plot 1: DHS Loadings vs PCA Loadings
ggplot(comparison, aes(x = dhs_factor, y = r_pca_loading)) +
  geom_point() +
  geom_smooth(method = "lm", color = "blue", se = FALSE, linewidth = 0.2) +
  labs(
    title = "DHS Loadings vs. PCA Loadings (1997)",
    x = "DHS Factor Loadings",
    y = "Reproduced PCA Loadings"
  ) +
  theme_minimal()

# Calculate and print the correlation
correlation <- cor.test(comparison$dhs_factor, comparison$r_pca_loading, use = "complete.obs")
print(correlation)
```

[Interprétation]{.underline}: Le graphique compare les saturations officiels obtenues par DHS (axe des x) et les saturation reproduites par l'ACP (axe des y). Chaque point sur le graphique représente une variable incluse dans le calcul du wealth index. La ligne bleue, qui représente un ajustement linéaire des points, montre une forte corrélation entre les deux séries de saturations, confirmant ainsi que la reconstruction des scores reproduit les calculs officiels de DHS. Cependant, nous allons effectuer des tests de corrélations pour vérifier la qualité des reconstructions du fait qu'un point se décale à gauche de la ligne bleue.

```{r}
# Calculate and print the correlation
correlation <- cor.test(comparison$dhs_factor, comparison$r_pca_loading, use = "complete.obs")
print(correlation)
```

Le test de corrélation indique que l'ACP produit bien les pondérations utilisées par le DHS avec un coefficient égale à 0.992924. Nous allons vérifier la qualité de l'ACP.

```{r}
#Vérification de la qualité de PCA
print(pca_result_1997$values / sum(pca_result_1997$values))

#Vérification de la structure des données 
summary(hv271_1997 %>% select(all_of(all_factor_vars_1997)))
#Evaluation du nombre optimal des facteurs 
fa.parallel(hv271_1997 %>% select(all_of(all_factor_vars_1997)), fa = "pc")
```

[Interprétation]{.underline}: Le graphique montre que la matrice de corrélation contient des valeurs propres négatives ou nulles qui empêchent certains calculs d'être correctement effectués. Nous allons alors identifier les variables qui sont redondantes ou trop corrélées.

```{r}
cor_matrix <- cor(hv271_1997 %>% select(all_of(all_factor_vars_1997)), use = "pairwise.complete.obs")
eigen(cor_matrix)$values

```

Les premières composantes ont des plus grandes valeurs que les suivantes. Les valeurs deviennent plus petites après les premières composantes indiquant que ces composantes contiennent de moins en moins d'informations utiles. On retrouve des valeurs très proches de zéro avec une valeur négative dans les dernières composantes.

```{r}
screeplot(prcomp(hv271_1997 %>% select(all_of(all_factor_vars_1997)), scale = TRUE), type = "lines")

pca_result <- prcomp(hv271_1997 %>% select(all_of(all_factor_vars_1997)), scale = TRUE)
cumsum(pca_result$sdev^2) / sum(pca_result$sdev^2)
```

2.  Reproduction du wealth index hv270 de DHS 1997

### Recalcul du wealth index hv270a pour 1997 et 2008

1.  Calcul du wealth index hv270a pour 2021

```{r}
# Extraction des variables
wealth_data_2021 <- dhs_2021_hr %>%
  select(hhid, hv025, hv271, hv270) %>%
  rename(factor_score = hv271, wealth_quintile = hv270)

# Recalcul des quintiles pour 2021
wealth_data_2021 <- wealth_data_2021 %>%
  mutate(
    hv270a_2021 = ntile(factor_score, 5)  # Création de 5 groupes égaux
  )


# Séparer les quintiles pour urbain et rural

# Quintiles pour les ménages urbains
wealth_urban_2021 <- wealth_data_2021 %>%
  filter(hv025 == 1) %>%
  mutate(hv270a_urban_2021 = ntile(factor_score, 5))

# Quintiles pour les ménages ruraux
wealth_rural_2021 <- wealth_data_2021 %>%
  filter(hv025 == 2) %>%
  mutate(hv270a_rural_2021 = ntile(factor_score, 5))

# Test de corrélation
hv270a_2021_corr <- cor(wealth_data_2021$hv270a_2021, wealth_data_2021$wealth_quintile, method = "pearson", use = "complete.obs")
hv270a_2021_corr_spearman <- cor(wealth_data_2021$hv270a_2021, wealth_data_2021$wealth_quintile, method = "spearman", use = "complete.obs")

# Affichage des résultats
print(paste("Corrélation Pearson :", round(hv270a_2021_corr, 3)))
print(paste("Corrélation Spearman :", round(hv270a_2021_corr_spearman, 3)))

```

2.  Calcul du wealth index hv270a pour 2008

    [**Urban**]{.underline}

```{r}
# Filter urban households
hv271_urban_2008 <- hv271_2008 %>%
  filter(hv025 == 1)

# Calculate the quintile specific to urban households (hv270a)
hv271_urban_2008 <- hv271_urban_2008 %>%
  mutate(
    hv270a_urban_2008 = ntile(factor_score, 5)  
  )

# Check the distribution of quintiles
print(table(hv271_urban_2008$hv270a_urban_2008))
print(summary(hv271_urban_2008$hv270a_urban_2008))

# Test the correlation between hv270a_2008 and hv270 (DHS)
hv270a_urban_2008_corr <- cor(hv271_urban_2008$hv270a_urban_2008, hv271_urban_2008$hv270, method = "pearson", use = "complete.obs")
hv270abis_urban_2008_corr <- cor(hv271_urban_2008$hv270a_urban_2008, hv271_urban_2008$hv270, method = "spearman", use = "complete.obs")

# Visualization
print(hv270a_urban_2008_corr)
print(hv270abis_urban_2008_corr)
```

[**RURAL**]{.underline}

```{r}
# Filter rural households
hv271_rural_2008 <- hv271_2008 %>%
  filter(hv025 == 2)

# Calculate the quintile specific to rural households (hv270a)
hv271_rural_2008 <- hv271_rural_2008 %>%
  mutate(
    hv270a_rural_2008 = ntile(factor_score, 5)  
  )

# Check the distribution of quintiles
print(table(hv271_rural_2008$hv270a_rural_2008))
print(summary(hv271_rural_2008$hv270a_rural_2008))

# Test the correlation between hv270a_2008 and hv270 (DHS)
hv270a_rural_2008_corr <- cor(hv271_rural_2008$hv270a_rural_2008, hv271_rural_2008$hv270, method = "pearson", use = "complete.obs")
hv270abis_rural_2008_corr<- cor(hv271_rural_2008$hv270a_rural_2008, hv271_rural_2008$hv270, method = "spearman", use = "complete.obs")

# Visualization
print(hv270a_rural_2008_corr)
print(hv270abis_rural_2008_corr)

```

[**Comparaison de rural et urbain par rapport à hv270 de DHS**]{.underline}

```{r}

# Scatterplot pour l'urbain
ggplot(hv271_urban_2008, aes(x = hv270a_urban_2008, y = hv270)) +
  geom_jitter(alpha = 0.5, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  labs(title = "Corrélation entre Quintiles Urbains et Indice DHS",
       x = "Quintile Recalculé (hv270a)",
       y = "Indice DHS (hv270)") +
  theme_minimal()

# Scatterplot pour le rural
ggplot(hv271_rural_2008, aes(x = hv270a_rural_2008, y = hv270)) +
  geom_jitter(alpha = 0.5, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  labs(title = "Corrélation entre Quintiles Ruraux et Indice DHS",
       x = "Quintile Recalculé (hv270a)",
       y = "Indice DHS (hv270)") +
  theme_minimal()



```

[Interprétation:]{.underline} On peut voir sur le graphique que la tendance rouge est proche d'une droite diagonale donc la corrélation est forte entre hv270 et hv270a.

2.  Segmentation de wealth index en centiles

3.  Calcul du Z score standardisé du wealth index

4.  Ajout des variables âges et sexes du chef de ménage dans l'analyse
