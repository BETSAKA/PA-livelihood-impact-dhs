---
title: "PA-livelihood-impact-dhs"
author: "Iriana Razafimahenina"
format: 
  html:
   out-put-file: index.html
   embed-resources: true
   standalone: true
   code-fold: true
  execute:
   warning: false
   error: false
editor: visual
editor-options: 
   chunk_out_type: console
Bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

# Environnement

```{r}
library(tidyverse) #Manipulation et visualisation des données
library(haven) #Importation des données
library(writexl) #Exportation des données
library(sf) #Analyse des données spatiales
library(tmap) #Analyse cartographique
library(codebook) #Documentation et mise en forme des données 
library(gt) #Mise en forme des tableaux 
library(survey) #Analyse des données d'enquêtes
library(MatchIt) #Matching
library(ggplot2) #Figure
library(labelled) # Manipulation des labels
library(readxl) #Lecture des fichiers excels
library(progressr) # Pour avoir des barres de progression
library(tictoc) # Pour minuter le temps d'exécution
library(mapme.biodiversity)
library(future) # Pour permettre du calcul parallèle
library(lubridate) # Gestion des dates
library(terra) # Manipulation des données raster 
library(geodata)
```

# Data structuring

Nous allons chargé les données nécessaires à l'analyse.

## Socioeconomic household data

### Reproduction of wealth index

## Data on the household geophysical environment

Nous allons utiliser le package R mapme.biodiversity (<https://mapme-initiative.github.io/mapme.biodiversity/index.html>) pour charger et extraire les données sur la couverture forestière, la pente et l'altitude, la densité de population, l'accessibilité en 2000.

```{r}
# Définir le chemin absolu pour ton répertoire local
outdir <- "Statistiques/PA-livelihood-impact-dhs2/Data"

# Créer le répertoire si il n'existe pas déjà
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

# Vérifier si le répertoire a bien été créé
if (dir.exists(outdir)) {
  cat("Répertoire créé ou déjà existant : ", outdir)
} else {
  cat("Le répertoire n'a pas pu être créé.")
}
mapme_options(
  outdir = outdir,
  verbose = TRUE
              )
```

### Définition des unités d'analyse

L'unité d'analyse de cette études est le ménage. Nous allons charger nos clusters de 2008 et 2021.

```{r clusters}

# Définition du système de coordonnées et de la distance de buffer utilisé
my_crs <- 29702
buffer_dist <- 10000

# Load boundary
contour_mada <- gadm(country = "Madagascar", level = 0, path = "Data") %>%
  st_as_sf() %>%
  st_transform(my_crs)

# Visualisation de la carte avec les contours
tmap_mode("view")

contour_mada %>%
  st_transform(my_crs) %>%
  tm_shape() +
  tm_borders(col = "black")
  
# Load DHS data 
dhs_folder <- "C:/Users/irian/Documents/Statistiques/PA-livelihood-impact-dhs2/Data/DHS_data"

load_data <- function(year, type, dhs_folder) {
  year_folder <- file.path(dhs_folder, paste0("DHS_", year))
  
  # Get the .shp (GPS) and .dta (household) file paths
  if (type == "HR") {
    hr_path <- list.files(year_folder, pattern = ".*HR.*\\.dta$", full.names = TRUE, recursive = TRUE, ignore.case = TRUE)
    if (length(hr_path) == 0) stop("No HR file found for the specified year.")
    out <- read_dta(hr_path) # Lecture du fichier .dta
  } else if (type == "GPS") {
    shp_path <- list.files(year_folder, pattern = "\\.shp$", full.names = TRUE, recursive = TRUE)
    if (length(shp_path) == 0) stop("No GPS file found for the specified year.")
    out <- st_read(shp_path, quiet = TRUE) %>%
      st_transform(my_crs) # Lecture du fichier .shp
  } else {
    stop("Data type unknown, must be HR or GPS")
  }
  return(out) 
}

# Execute the function for a specific year
hr_1997 <- load_data(1997, "HR", dhs_folder)
gps_1997 <- load_data(1997, "GPS", dhs_folder)

hr_2008 <- load_data(2008, "HR", dhs_folder)
gps_2008 <- load_data(2008, "GPS", dhs_folder)

hr_2021 <- load_data(2021, "HR", dhs_folder)
gps_2021 <- load_data(2021, "GPS", dhs_folder)

# Vérification des données GPS
print(gps_1997) 
print(gps_2008)
print(gps_2021)

st_geometry(gps_1997)
st_geometry(gps_2008)
st_geometry(gps_2021)

# Vérification des données GPS
if (!"DHSCLUST" %in% colnames(gps_1997)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}

if (!"DHSCLUST" %in% colnames(gps_2008)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}

if (!"DHSCLUST" %in% colnames(gps_2021)) {
  stop("La colonne 'DHSCLUST' n'existe pas dans les données GPS.")
} else {
  message("Les clusters sont bien identifiés.")
}

# Générer et afficher les cartes pour chaque année
dhs_map <- function(gps_data, year) {
  tmap_mode("view")
  
  tm_shape(contour_mada) +
    tm_borders(col = "black") +
    tm_shape(gps_data) +
    tm_symbols(
      col = "URBAN_RURA", 
      palette = c("blue", "green"), 
      title.col = "Zone",
      size = 0.5,
      shape = 21,
      border.col = "black"
    ) +
    tm_layout(title = paste("DHS Clusters -", year))
}

# Création des cartes
dhs_map(gps_1997, 1997)
dhs_map(gps_2008, 2008)
dhs_map(gps_2021, 2021)
```

### Chargement des données et extraction des données de mapme.biodiversity

-   Couvert forestier en 2000 (Hansen et al.2013)

-   Pente et altitude (NASA SRTM)

-   Densité de population en 2000 (Worldpop)

-   Accessibilité en 2000 (JRC, Uchida et Nelson 2011)

-   Précipitations

Nous allons maintenant charger les données géophysiques des ménages à partir de mapme.biodiversity

```{r}
library(mapme.biodiversity)
library(tidyverse)
library(progressr)
library(tictoc)
library(future)
library(sf)
library(rstac)
library(terra)

# Activer la barre de progression
handlers(global = TRUE)
handlers("progress")


if (file.exists("Data/donnees_geo_menages/2008/gps_2008.rds")) {
  gps_2008 <- readRDS("Data/donnees_geo_menages/2008/gps_2008.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")
  
  # Créer un buffer autour de chaque point pour former des polygones
  gps_2008 <- st_buffer(gps_2008, dist = 10000)
  
  # Définir les ressources à télécharger 
  gps_2008 <- gps_2008 %>%
    get_resources(get_gfw_treecover())
  
  gps_2008 <- gps_2008 %>%  
    get_resources(get_gfw_lossyear())
  
  gps_2008 <- gps_2008 %>% 
    get_resources(get_nasa_srtm())
  
  gps_2008 <- gps_2008 %>% 
    get_resources(get_worldpop(years = 2000))
  
  gps_2008 <- gps_2008 %>%  
    get_resources(get_accessibility_2000())
  
  # Extraire les ressources sans changer le type de géométrie
  plan(sequential)
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_treecover_area(years = 2000:2023, min_size = 10, min_cover = 35))
  })
  toc()   # 362.75 sec
  
  # slope
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_slope(engine = "extract", stats = "mean"))
  })
  toc() # 316.09 sec
  
  # Elevation
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc() # 662.1 sec
  
  # Population density
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc() # 47.42 sec
  
  # Accessibility
  tic()
  with_progress({
    gps_2008 <- calc_indicators(
      x = gps_2008, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc() # 37.81 sec
  
  # Convertir les polygones en points en utilisant les centroids
  gps_2008 <- st_centroid(gps_2008)
  
  # Enregistrement des données sous forme de points (dans le même dataframe gps_2008)
  write_rds(gps_2008, "Data/donnees_geo_menages/2008/gps_2008.rds")
  cat("✅ Données enregistrées dans gps_2008.rds avec géométries en POINT et indicateurs ajoutés.\n")
  }
```

```{r 2021}
# Activer la barre de progression
handlers(global = TRUE)
handlers("progress")

if (file.exists("Data/donnees_geo_menages/2021/gps_2021.rds")) {
  gps_2021 <- readRDS("Data/donnees_geo_menages/2021/gps_2021.rds")
} else {
  cat("Fichier introuvable, début du traitement...\n")

  # Créer un buffer autour de chaque point pour former des polygones 
  gps_2021 <- st_buffer(gps_2021, dist = 10000)
  
  # Définir les ressources à télécharger (corrigé)
  gps_2021 <- gps_2021 %>%
    get_resources(get_gfw_treecover())
  
  gps_2021 <- gps_2021 %>%  
    get_resources(get_gfw_lossyear())
  
  gps_2021 <- gps_2021 %>% 
    get_resources(get_nasa_srtm())
  
  gps_2021 <- gps_2021 %>% 
    get_resources(get_worldpop(years = 2000))
  
  gps_2021 <- gps_2021 %>%  
    get_resources(get_accessibility_2000())
  
  # Extraire les ressources sans changer le type de géométrie
  plan(sequential)
  
  # Forest cover rate in 2000
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_treecover_area(years = 2000:2023, min_size = 10, min_cover = 35))
  })
  toc()   # 362.75 sec
  
  # slope
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_slope(engine = "extract", stats = "mean"))
  })
  toc() # 316.09 sec
  
  # Elevation
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_elevation(engine = "extract", stats = "mean"))
  })
  toc() # 662.1 sec
  
  # Population density
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_population_count(engine = "extract", stats = "mean"))
  })
  toc() # 47.42 sec
  
  # Accessibility
  tic()
  with_progress({
    gps_2021 <- calc_indicators(
      x = gps_2021, calc_traveltime_2000(engine = "extract", stats = "mean"))
  })
  toc() # 37.81 sec
  
  # Convertir les polygones en points en utilisant les centroids
  gps_2021 <- st_centroid(gps_2021)
  # Enregistrement des données sous forme de points 
  write_rds(gps_2021, "Data/donnees_geo_menages/2021/gps_2021.rds")
  cat("✅ Données enregistrées dans gps_2021.rds avec géométries en POINT et indicateurs ajoutés.\n")
  
  }
```

### Chargement et extraction des données sur les précipitations

```{r 2008}

# Vérification et chargement des données
if (file.exists("Data/donnees_geo_menages/2008/gps_2008_wc.rds")) {
  # Si les données sont déjà présentes, on les charge directement
  gps_2008 <- readRDS("Data/donnees_geo_menages/2008/gps_2008_wc.rds")
} else {
  # Plan d'exécution séquentielle
  plan(sequential)
  
  # Étape 1 : Création d'un buffer autour des points GPS
  gps_2008 <- st_transform(gps_2008, 3857)  # Transformation en projection en mètres
  gps_2008 <- st_buffer(gps_2008, dist = 10000)  # Buffer de 10 km autour des points
  gps_2008 <- st_transform(gps_2008, 4326)  # Retour en projection géographique (WGS84)

  # Vérification du type de géométrie après transformation
  if (!all(st_geometry_type(gps_2008) == "POLYGON")) {
    stop("Les géométries ne sont pas de type POLYGON après la transformation.")
  }

  # Étape 2 : Chargement des données climatiques WorldClim (Température et Précipitation)
  tic("Chargement des données climatiques")
  with_progress({
    gps_2008 <- gps_2008 %>%
      get_resources(
        get_worldclim_max_temperature(years = 2000:2018, resolution = "10m"),
        get_worldclim_min_temperature(years = 2000:2018, resolution = "10m"),
        get_worldclim_precipitation(years = 2000:2018, resolution = "10m")
      )
  })
  toc()  # Temps d'exécution pour le chargement des données

  # Étape 3 : Extraction des indicateurs climatiques pour chaque zone
  tic("Extraction des indicateurs climatiques")
  with_progress({
    gps_2008 <- gps_2008 %>%
      calc_indicators(
        calc_precipitation_wc(engine = "extract", stats = "mean"),
        calc_temperature_max_wc(engine = "extract", stats = "mean"),
        calc_temperature_min_wc(engine = "extract", stats = "mean")
      )
  })
  toc()  # Temps d'exécution pour l'extraction des données climatiques

  # Étape 4 : Retour aux points (en utilisant les centroids des polygones)
  gps_2008 <- st_centroid(gps_2008)

  # Étape 5 : Sauvegarde des données extraites dans un fichier .rds
  write_rds(x = gps_2008, file = "Data/donnees_geo_menages/2008/gps_2008_wc.rds")
}

# Vérification des avertissements éventuels
warnings()

```

```{r 2021}
# Vérification et chargement des données
if (file.exists("Data/donnees_geo_menages/2021/gps_2021_wc.rds")) {
  # Si les données sont déjà présentes, on les charge directement
  gps_2021 <- readRDS("Data/donnees_geo_menages/2021/gps_2021_wc.rds")
} else {
  # Plan d'exécution séquentielle
  plan(sequential)
  
  # Étape 1 : Création d'un buffer autour des points GPS
  gps_2021 <- st_transform(gps_2021, 3857)  # Transformation en projection en mètres
  gps_2021 <- st_buffer(gps_2021, dist = 10000)  # Buffer de 10 km autour des points
  gps_2021 <- st_transform(gps_2021, 4326)  # Retour en projection géographique (WGS84)

  # Vérification du type de géométrie après transformation
  if (!all(st_geometry_type(gps_2021) == "POLYGON")) {
    stop("Les géométries ne sont pas de type POLYGON après la transformation.")
  }

  # Étape 2 : Chargement des données climatiques WorldClim (Température et Précipitation)
  tic("Chargement des données climatiques")
  with_progress({
    gps_2021 <- gps_2021 %>%
      get_resources(
        get_worldclim_max_temperature(years = 2000:2018, resolution = "10m"),
        get_worldclim_min_temperature(years = 2000:2018, resolution = "10m"),
        get_worldclim_precipitation(years = 2000:2018, resolution = "10m")
      )
  })
  toc()  # Temps d'exécution pour le chargement des données

  # Étape 3 : Extraction des indicateurs climatiques pour chaque zone
  tic("Extraction des indicateurs climatiques")
  with_progress({
    gps_2021 <- gps_2021 %>%
      calc_indicators(
        calc_precipitation_wc(engine = "extract", stats = "mean"),
        calc_temperature_max_wc(engine = "extract", stats = "mean"),
        calc_temperature_min_wc(engine = "extract", stats = "mean")
      )
  })
  toc()  

  # Étape 4 : Retour aux points (en utilisant les centroids des polygones)
  gps_2021 <- st_centroid(gps_2021)

  # Étape 5 : Sauvegarde des données extraites dans un fichier .rds
  write_rds(x = gps_2021, file = "Data/donnees_geo_menages/2021/gps_2021_wc.rds")
} # 46330.66 sec

# Vérification des avertissements éventuels
warnings()
```

### Calcul de l'indice Standardized Precipitation Evapotranspiration Index (SPEI)

L'indice SPEI est calculé à partir d'une référence à long terme (1981-2010) pour quantifier l'excès ou le manque de pluie. Son calcul se fait à partir des données mensuelles de précipitation et de température minimum et maximum provenant de Worlclim, en utilisant une version améliorée de la méthode Hargreaves ( Modified-Hargreaves methods) définie par Droogers et Allen (2002). La variable sera calculée pour un cercle de 10 km de rayon autour de la coordonnée GPS de la grappe.

```{r}
library(SPEI)
library(gander)
library(ellmer)
library(devtools)
library (fastmap)

# Latitude calculation
if (file.exists("data/donnees_geo_menages/2021/gps_2021_wc_spei.rds")) {
  gps_2008_wc_spei <- read_rds("data/donnees_geo_menages/2021/gps_2021_wc_spei.rds")
} else {
  gps_2008_wc_spei <- gps_2008 %>% 
    mutate(
      lat = st_coordinates (st_centroid(geometry))[,2])
  
  # Extract the first cluster's climate time series
  row1 <- gps_2008_wc_spei [1,]
  
  # Extract vectors 
  tmin <- row1$temperature_min_wc[[1]]$value
  tmax <- row1$temperature_max_wc[[1]]$value
  prec <- row1$precipitation_wc[[1]]$value
  dates <- row1$temperature_min_wc[[1]]$datetime
  lat <- row1$LATNUM
  
  # Compute reference evapotranspiration (PET) using modified Hargreaves (Droogers & Allen)
  pet <- hargreaves(Tmin = tmin, Tmax = tmax, Pre = prec, lat = lat)
  
  # Compute wtaer balance
  wb <- prec - pet
  
  # Turn to time series
  wb_ts <- ts(wb, start = c(year(min(dates)), month(min(dates))), frequency = 12)
  
  # Compute SPEI (e.g 3-month scale)
  spei_obj <- spei(wb_ts, scale = 3)
  
  # Turn into tibble
  spei_tbl <- tibble(
    datetime = dates, 
    spei = as.numeric(spei_obj$fitted)
  )
  
  # SPEI sous forme de map
  gps_2008_wc_spei <- gps_2008_wc_spei %>%
    mutate(
      spei_wc = pmap(
        list(tmin = temperature_min_wc,
             tmax = temperature_max_wc,
             prec = precipitation_wc,
             lat = lat),
        function(tmin, tmax, prec, lat) {
          data_tmin <- data.frame(date = tmin$datetime, tmin = tmin$value)
          data_tmax <- data.frame(date = tmax$datetime, tmax = tmax$value)
          data_prec <- data.frame(date = prec$datetime, prec = prec$value)
          
        # Fusionner
        data_merged <- reduce(list(data_tmin, data_tmax, data_prec), merge, by = "date")

        # Supprimer les lignes avec NA
        data_clean <- na.omit(data_merged)

        # Si les données nettoyées sont insuffisantes, retourner des NA
        if (nrow(data_clean) < 12) {
          return(tibble(datetime = data_merged$date, spei = NA_real_))
        }

        # Extraire les colonnes propres
        tmin_synced <- data_clean$tmin
        tmax_synced <- data_clean$tmax
        prec_synced <- data_clean$prec
        dates_synced <- data_clean$date
        
        # calcul PET
        pet <- hargreaves(
          Tmin = tmin_synced,
          Tmax = tmax_synced,
          Pre = prec_synced,
          lat = lat
        )
        
        wb <- prec_synced - pet
        
        wb_ts <- ts(wb, start = c(year(min(dates_synced)), month(min(dates_synced))), frequency = 12)
        
        spei_obj <- spei(wb_ts, scale = 3)
        
        # Résultat
        tibble(datetime = dates_synced, spei = as.numeric(spei_obj$fitted))
        }
      )
    )
}
```

## Données sur les aires protégées

Utilisation des données de SGAP (SAPM)

```{r}
# library
library(wdpar)
library(pwr)
library(lme4)
library(units)
library(sf)

# Load SAPM data
sapm <- st_read("Data/Aires protégées/SAPM_2017_corrected/SAPM_2017_corrected.shp", quiet = TRUE) %>%
  st_transform(my_crs) %>%
  st_make_valid() %>%
  mutate(YEAR_CREAT = year(ymd(DATE_CREAT)), .after = DATE_CREAT)

# Intersection des SAPM avec la limite de Madagascar
sapm_land <- sapm %>% 
  st_intersection(contour_mada)%>%
  st_make_valid()

sapm_land_tb <- sapm_land %>%
  st_drop_geometry()

write_xlsx(sapm_land_tb, "Data/Aires protégées/output/SAPM_2017.xlsx")

sapm %>%
  DT::datatable()

# Visualisation
tmap_mode("view")
tm_shape(contour_mada) +
  tm_borders() +
tm_shape(sapm) +
  tm_polygons(col = "green", id = "FULL_NAME", popup.vars = c("Superficie (ha)" = "HECTARES")) +
  tm_scalebar(position = c("left", "bottom")) + 
  tmap_options(check_and_fix = TRUE) +
  tm_title("Aires protégées de Madagascar") +
  tm_layout(legend.outside = TRUE)
```

# Treatment and Control groups assignment

-   [Groupe de traitement]{.underline}: clusters à moins de 10 km des aires protégées créées après 2008

-   [Groupe de contrôle]{.underline}: clusters à plus de 10 km des aires protégées

-   Groupe à exclure: clusters à moins de 10 km des aire protégées créées avant 2008

## Identification des aires protégées avant et après 2008

```{r}
# Spécification des aires protégées avant 2008
sapm_land_pre2008 <- sapm_land %>%
  filter(year(DATE_CREAT) < 2008)

# Spécification des aires protégées après 2008
sapm_land_post2008 <- sapm_land %>%
  filter(year(DATE_CREAT) >= 2008)

# Créer des buffers de 10 km autour des AP
sapm_land_pre2008_buffer <- sapm_land_pre2008 %>%
  st_buffer(dist = buffer_dist) %>%
  st_make_valid() %>%
  st_union() %>%
  st_as_sf() %>%
  st_make_valid()

sapm_land_post2008_buffer <- sapm_land_post2008  %>%
  st_buffer(dist = buffer_dist) %>% 
  st_make_valid() %>%
  st_union() %>%
  st_as_sf() %>%
  st_make_valid()

tm_shape(sapm_land_pre2008) +
tm_polygons(fill = "darkgreen", 
            border.col = "black", 
            fill_alpha = 0.5) +
tm_shape(sapm_land_post2008_buffer) +
tm_borders(col = "green", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +
tm_shape(sapm_land_pre2008_buffer) +
tm_borders(col = "darkgreen", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +
tm_shape(sapm_land_post2008) +
tm_polygons(fill = "green", 
            border.col = "black", 
            fill_alpha = 0.5) +
tm_add_legend(type = "polygons", fill = c("green", "darkgreen"), labels = c("avant 2008", "après 2008")) +
  tm_title("Aires protégées du SAPM par période de création") +
  tm_layout(
    legend.outside = TRUE, 
    legend.position = c("left", "top"),
    frame = FALSE,
    legend.title.size = 1.2,
    legend.text.size = 0.8
  ) +
  tm_compass(type = "8star", position = c("right", "top")) +
  tm_scalebar(position = c("right", "bottom"))


# Definition de la fonction
create_summary_table <- function(data, pivot_year) {
  summary_table <- data %>%
    st_drop_geometry() %>%
    mutate(
      Creation_Period = case_when(
        YEAR_CREAT < pivot_year ~ paste("Avant", pivot_year),
        YEAR_CREAT >= pivot_year ~ paste("Après", pivot_year)
      ),
      Type = ifelse(str_detect(TYPE_AP, "TERRESTRE"), "Terrestre", "Non terrestre")
    ) %>%
    group_by(Creation_Period, Type) %>%
    summarise(
      Count = n(),
      Area = sum(HECTARES, na.rm = TRUE) / 100,  # Convert hectares to km²
      .groups = 'drop'
    ) %>%
    pivot_wider(
      names_from = Type,
      values_from = c(Count, Area),
      values_fill = list(Count = 0, Area = 0)
    )

  # Add row and column totals
  summary_table <- summary_table %>%
    mutate(
      Total_Count = Count_Terrestre + `Count_Non terrestre`,
      Total_Area = Area_Terrestre + `Area_Non terrestre`
    )

  # Compute the totals across all periods
  total_row <- summary_table %>%
    summarise(
      Creation_Period = "Total",
      Count_Terrestre = sum(Count_Terrestre, na.rm = TRUE),
      `Count_Non terrestre` = sum(`Count_Non terrestre`, na.rm = TRUE),
      Total_Count = sum(Total_Count, na.rm = TRUE),
      Area_Terrestre = sum(Area_Terrestre, na.rm = TRUE),
      `Area_Non terrestre` = sum(`Area_Non terrestre`, na.rm = TRUE),
      Total_Area = sum(Total_Area, na.rm = TRUE)
    )

  # Append the total row to the summary table
  summary_table <- bind_rows(summary_table, total_row)

  # Format the table with gt
  gt_table <- gt(summary_table) %>%
    tab_header(
      title = paste("Aires protégées par période de création (Année pivot = ", pivot_year, ")")
    ) %>%
    cols_label(
      Creation_Period = "Période de Création",
      Count_Terrestre = "Terrestres",
      `Count_Non terrestre` = "Non terrestres",
      Total_Count = "Total",
      Area_Terrestre = "Terrestres",
      `Area_Non terrestre` = "Non terrestres",
      Total_Area = "Total"
    ) %>%
    fmt_number(
      columns = c(Count_Terrestre, `Count_Non terrestre`, Total_Count),
      decimals = 0
    ) %>%
    fmt_number(
      columns = c(Area_Terrestre, `Area_Non terrestre`, Total_Area),
      decimals = 0  # Round areas to whole numbers
    ) %>%
    tab_spanner(
      label = "Nombre d'Aires Protégées",
      columns = c(Count_Terrestre, `Count_Non terrestre`, Total_Count)
    ) %>%
    tab_spanner(
      label = "Superficie (km²)",  # Change label to km²
      columns = c(Area_Terrestre, `Area_Non terrestre`, Total_Area)
    ) %>%
    tab_style(
      style = list(
        cell_text(weight = "bold")
      ),
      locations = cells_body(
        rows = Creation_Period == "Total"
      )
    )

  return(gt_table)
}

# Table for 2008
create_summary_table(sapm_land, 2008)

```

## Identification du groupe de traitement et du groupe de contrôle en 2008

```{r}
# Harmoniser les CRS des buffers avec les données GPS
sapm_land_pre2008_buffer <- st_transform(sapm_land_pre2008_buffer, st_crs(gps_2008))
sapm_land_post2008_buffer <- st_transform(sapm_land_post2008_buffer, st_crs(gps_2008))


# Identifier le groupe de traitement: ménages proche d'AP créées après 2008
gps_cluster_2008 <- gps_2008 %>%
  mutate(
    proche_AP_pre2008 = st_within(geometry, sapm_land_pre2008_buffer, sparse = FALSE)[, 1],
    proche_AP_post2008 = st_within(geometry, sapm_land_post2008_buffer, sparse = FALSE)[, 1],
    groupe = case_when(
      proche_AP_post2008 & !(proche_AP_pre2008) & URBAN_RURA == "R" ~ "Traitement", 
      proche_AP_pre2008 | URBAN_RURA == "U" ~ "Exclu",
      !(proche_AP_post2008) & !(proche_AP_pre2008) & URBAN_RURA == "R" ~ "Controle"
    )
  )

# Insérer un tableau qui compte les clusters en fonction de leur groupe
table(gps_cluster_2008$groupe, useNA = "always")

# identifier le groupe de controle: ménages à plus de 10 km 
gps_cluster_2008 <- gps_2008 %>%
  mutate(
    distance_pre2008 = st_distance(geometry, st_union(sapm_land_pre2008_buffer)),
    distance_post2008 = st_distance(geometry, st_union(sapm_land_post2008_buffer)),
    distance_pre2008_km = set_units(distance_pre2008, "km") %>% drop_units(),
    distance_post2008_km = set_units(distance_post2008, "km") %>% drop_units(),
    groupe = case_when(
      distance_post2008_km > 10 & distance_pre2008_km > 10 & URBAN_RURA == "R" ~ "Controle",
      distance_post2008_km <= 10 & distance_pre2008_km > 10 & URBAN_RURA == "R" ~ "Traitement", 
      distance_pre2008_km <= 10 | URBAN_RURA == "U" ~ "Exclu"
    )
  )

# Insérer un tableau qui compte les clusters en fonction de leur groupe
table(gps_cluster_2008$groupe, useNA = "always")

# Exclure les clusters à moins de 10 km d'une AP créés avant 2008
gps_cluster_2008 <- gps_2008 %>%
  mutate(
    proche_AP_pre2008 = st_within(geometry, sapm_land_pre2008_buffer, sparse = FALSE)[, 1],
    proche_AP_post2008 = st_within(geometry,sapm_land_pre2008_buffer, sparse = FALSE)[, 1]
  ) %>%
  filter(!proche_AP_pre2008 & URBAN_RURA == "R") %>%
  mutate(
    groupe = case_when(
      proche_AP_post2008 ~ "Traitement", 
      TRUE ~ "Controle"
    )
  )
    
# Insérer un tableau qui compte les clusters en fonction de leur groupe
table(gps_cluster_2008$groupe, useNA = "always")


# Créer un plot pour visualiser la carte des AP avec les clusters
tm_shape(sapm_land_post2008_buffer) +
  tm_borders(col = "green", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +  tm_shape(sapm_land_pre2008_buffer) +
  tm_borders(col = "darkgreen", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +
  tm_shape(sapm_land_post2008) +
  tm_polygons(fill = "green", fill_alpha = 0.5, border.col = "black", fill.legend = tm_legend(title = "après 2008")) +
  tm_shape(sapm_land_pre2008) +
  tm_polygons(fill = "darkgreen", fill_alpha = 0.5, border.col = "black", fill.legend = tm_legend(title = "avant 2008")) +
  tm_shape(gps_cluster_2008) +
  tm_symbols(
    col = "groupe", 
    palette = c("Traitement" = "red", "Controle" = "blue", "Exclu" = "gray"),
    fill.legend = tm_legend(title = "Groupes"),
    shape = 21,
    border.col = "black",
    size = 0.5
  ) +
  tm_add_legend(type = "polygons", fill = c("green", "darkgreen"), labels = c("après 2008", "avant 2008")) +
  tm_title("Grappes d'enquêtes DHS 2008 par rapport aux AP existantes en 2008") +
  tm_layout(
    legend.outside = TRUE, 
    legend.position = c("left", "top"),
    frame = FALSE
  ) +
  tm_compass(type = "8star", position = c("right", "top")) +
  tm_scalebar(position = c("left", "bottom"))
```

## Identification du groupe de traitement et du groupe de contrôle en 2021

```{r}
# Création des buffers pour 2021
sapm_land_2021_buffer <- sapm_land %>%
  st_buffer(buffer_dist) %>%
  st_make_valid() %>%
  st_union() %>%
  st_as_sf() %>%
  st_make_valid()%>%
  st_intersection(contour_mada)

# Identification des clusters 
gps_cluster_2021 <- gps_2021 %>%
  mutate(
    proche_AP_post2008 = st_within(geometry, sapm_land_post2008_buffer, sparse = FALSE)[, 1],
    groupe = case_when(
      proche_AP_post2008 & URBAN_RURA == "R" ~ "Traitement", 
      URBAN_RURA == "U" ~ "Exclu",
      !(proche_AP_post2008) & URBAN_RURA == "R" ~ "Controle"))

# Insérer un tableau qui compte les clusters en fonction de leur groupe
table(gps_cluster_2021$groupe, useNA = "always")

# Créer un plot pour visualiser la carte des AP avec les clusters
tm_shape(sapm_land_post2008_buffer) +
  tm_borders(col = "green", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +  tm_shape(sapm_land_pre2008_buffer) +
  tm_borders(col = "darkgreen", lwd = 2, lty = "dashed", fill.legend = tm_legend_hide()) +
  tm_shape(sapm_land_post2008) +
  tm_polygons(fill = "green", fill_alpha = 0.5, border.col = "black", fill.legend = tm_legend(title = "après 2008")) +
  tm_shape(sapm_land_pre2008) +
  tm_polygons(fill = "darkgreen", fill_alpha = 0.5, border.col = "black", fill.legend = tm_legend(title = "avant 2008")) +
  tm_shape(gps_cluster_2008) +
  tm_symbols(
    col = "groupe", 
    palette = c("Traitement" = "red", "Controle" = "blue", "Exclu" = "gray"),
    fill.legend = tm_legend(title = "Groupes"),
    shape = 21,
    border.col = "black",
    size = 0.5
  ) +
  tm_add_legend(type = "polygons", fill = c("green", "darkgreen"), labels = c("après 2008", "avant 2008")) +
  tm_title("Grappes d'enquêtes DHS 2021 par rapport aux AP existantes en 2021") +
  tm_layout(
    legend.outside = TRUE, 
    legend.position = c("left", "top"),
    frame = FALSE
  ) +
  tm_compass(type = "8star", position = c("right", "top")) +
  tm_scalebar(position = c("left", "bottom"))
```

# Sélection des ménages étudiées

-   Ménages proches des aires protégées créées à partir de 2008

-   Ménages ruraux

## Vérification des zones urbaines et rurales des clusters existants

```{r}

# Ajouter les colonnes "zone_urbaine" et "zone_rurale"
gps_cluster_2008 <- gps_cluster_2008 %>%
  mutate(
    zone_urbaine = ifelse(URBAN_RURA == "U", 1, 0),
    zone_rurale = ifelse(URBAN_RURA == "R",  1, 0)
  )

head(gps_cluster_2008)

gps_cluster_2021 <- gps_cluster_2021 %>%
  mutate(
    zone_urbaine = ifelse(URBAN_RURA == "U",  1, 0),
    zone_rurale = ifelse(URBAN_RURA == "R", 1, 0)
  )

head(gps_cluster_2021)


# Vérifier que les clusters urbains sont bien définis
urban_clusters <- gps_2008 %>%
  filter(URBAN_RURA == "U")
  

urban_clusters <- gps_2021 %>%
  filter(URBAN_RURA == "U") 

# Vérifier que les clusters ruraux sont bien définis
rural_clusters <- gps_2008 %>%
  filter(URBAN_RURA == "R")


rural_clusters <- gps_2021 %>%
  filter(URBAN_RURA == "R") 

# Afficher les résultats 
table(gps_cluster_2008$URBAN_RURA, useNA = "always")
table(gps_cluster_2021$URBAN_RURA, useNA = "always")


# Function to find GPS locations near PAs created within a specific time frame
find_nearby_gps <- function(gps_data, sapm_data, distance_km, creation_year, after = TRUE) {
  if (after) {
    selected_pas <- sapm_data %>%
      filter(YEAR_CREAT >= creation_year)
  } else {
    selected_pas <- sapm_data %>%
      filter(YEAR_CREAT < creation_year)
  }
  
  selected_pas <- selected_pas %>%
    st_make_valid()
  
  gps_data <- st_transform(gps_data, st_crs(selected_pas))
  
  buffered_pas <- st_buffer(selected_pas, dist = distance_km * 1000) %>%
    st_make_valid()
  
  merged_buffer <- st_union(buffered_pas) %>%
    st_make_valid()
  
  nearby_gps <- gps_data %>%
    mutate(nearby_pa = st_within(geometry, merged_buffer, sparse = FALSE)[, 1])
  
  return(nearby_gps)
}

# Identify clusters for treatment and exclusion groups
treatment_clusters_2021 <- find_nearby_gps(gps_2021, sapm, 10, 2008, after = TRUE)
exclusion_clusters_2021 <- find_nearby_gps(gps_2021, sapm, 10, 2008, after = FALSE)

treatment_clusters_2008 <- find_nearby_gps(gps_2008, sapm, 10, 2008, after = TRUE)
exclusion_clusters_2008 <- find_nearby_gps(gps_2008, sapm, 10, 2008, after = FALSE)

# Function to calculate clusters and households for different categories
clusters_and_households <- function(gps_data, hr_data, treatment_clusters, exclusion_clusters, year) {
  clusters_treatment <- treatment_clusters %>%
    filter(nearby_pa) %>%
    pull(DHSCLUST)
  
  clusters_exclusion <- exclusion_clusters %>%
    filter(nearby_pa) %>%
    pull(DHSCLUST)
  
  clusters_control <- gps_data %>%
    filter(!DHSCLUST %in% c(clusters_treatment, clusters_exclusion)) %>%
    pull(DHSCLUST)
  
  total_clusters <- nrow(gps_data)
  total_households <- nrow(hr_data)
  
  households_treatment <- hr_data %>%
    filter(hv001 %in% clusters_treatment) %>%
    nrow()
  
  households_exclusion <- hr_data %>%
    filter(hv001 %in% clusters_exclusion) %>%
    nrow()
  
  households_control <- hr_data %>%
    filter(hv001 %in% clusters_control) %>%
    nrow()
  
  tibble(
    année = year,
    `Grappes traitement` = length(clusters_treatment),
    `Ménages traitement` = households_treatment,
    `Grappes exclusion` = length(clusters_exclusion),
    `Ménages exclusion` = households_exclusion,
    `Grappes contrôle` = length(clusters_control),
    `Ménages contrôle` = households_control,
    `Total des grappes` = total_clusters,
    `Total des ménages` = total_households
  )
}

# Calculate results for all observations
results_all <- list(
  clusters_and_households(gps_2021, hr_2021, treatment_clusters_2021, exclusion_clusters_2021, 2021),
  clusters_and_households(gps_2008, hr_2008, treatment_clusters_2008, exclusion_clusters_2008, 2008)
) %>%
  bind_rows()

# Calculate results for rural households only
results_rural <- list(
  clusters_and_households(
    gps_2021 %>% filter(URBAN_RURA == "R"),
    hr_2021 %>% filter(hv025 == 2),
    treatment_clusters_2021 %>% filter(URBAN_RURA == "R"),
    exclusion_clusters_2021 %>% filter(URBAN_RURA == "R"),
    2021
  ),
  clusters_and_households(
    gps_2008 %>% filter(URBAN_RURA == "R"),
    hr_2008 %>% filter(hv025 == 2),
    treatment_clusters_2008 %>% filter(URBAN_RURA == "R"),
    exclusion_clusters_2008 %>% filter(URBAN_RURA == "R"),
    2008
  )
) %>%
  bind_rows()

# Add a column for categorization before selecting the columns
combined_results <- bind_rows(
  results_all %>% mutate(Type = "Toutes observations"),
  results_rural %>% mutate(Type = "Zones rurales")  # Change label to "Zones rurales"
)

# Display the results using gt with improved layout and row groups
gt_table <- gt(combined_results) %>%
  tab_header(
    title = "Nombre de grappes et de ménages d'enquêtes DHS classés selon leur proximité avec des aires protégées"
  ) %>%
  cols_label(
    année = "Année",
    `Grappes traitement` = "Traitement",
    `Grappes exclusion` = "Exclusion",
    `Grappes contrôle` = "Contrôle",
    `Total des grappes` = "Total",
    `Ménages traitement` = "Traitement",
    `Ménages exclusion` = "Exclusion",
    `Ménages contrôle` = "Contrôle",
    `Total des ménages` = "Total"
  ) %>%
  tab_spanner(
    label = "Grappes",
    columns = c(`Grappes traitement`, `Grappes exclusion`, `Grappes contrôle`, `Total des grappes`)
  ) %>%
  tab_spanner(
    label = "Ménages",
    columns = c(`Ménages traitement`, `Ménages exclusion`, `Ménages contrôle`, `Total des ménages`)
  ) %>%
  fmt_number(
    columns = c(`Grappes traitement`, `Grappes exclusion`, `Grappes contrôle`, `Total des grappes`,
                `Ménages traitement`, `Ménages exclusion`, `Ménages contrôle`, `Total des ménages`),
    decimals = 0,
    use_seps = TRUE,
    sep_mark = " ",
    dec_mark = ","
  ) %>%
  fmt_number(
    columns = "année",
    decimals = 0,
    use_seps = FALSE
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  cols_width(
    `Total des ménages` ~ px(150)
  ) %>%
  tab_options(
    table.width = pct(100)
  ) %>%
  tab_footnote(
    footnote = md("**Traitement**: Observations situées à moins de 10 km des AP créées à partir de 2008. **Exclusion**: Observations situées à moins de 10 km des AP créées avant 2008. **Contrôle**: Autres observations."),
    locations = cells_title(groups = "title")
  ) %>%
  tab_row_group(
    label = "Toutes observations",
    rows = Type == "Toutes observations"
  ) %>%
  tab_row_group(
    label = "Zones rurales",
    rows = Type == "Zones rurales"  # Ensure consistency with the new label
  ) %>%
  cols_hide(
    columns = "Type"  # Hide the Type column after using it for row grouping
  )

# Display the formatted gt table
gt_table
```

# Estimation des effets par Matching

## Matching et optimisation de l'équilibre des groupes

1.  Utilisation du Genetic matching et du Mahalanobis Distance Matching avec la fonction de GenMatch() du package R MatchIt

2.  Application du caliper à un intervalle de 0.25 écart-type de la distance de Mahalanobis

```{r}
library(MatchIt)
library(cobalt)
library(dplyr)

# Matching avec MatchIt pour 2008
set.seed(123) 
matching_2008 <- matchit(
  groupe == "Traitement" ~ treecover_area + slope + elevation + population_count + travel_time,
  data = gps_cluster_2008 %>% 
    filter(groupe != "Exclu"),
  method = "genetic", 
  distance = "mahalanobis",
  caliper = 0.25
)

# Matching avec MatchIt pour 2021
mateching_2021 <-  matchit(
  groupe == "Traitement" ~ treecover_area + slope + elevation + population_count + travel_time,
  data = gps_cluster_2021 %>% 
    filter(groupe != "Exclu"),
  method = "genetic", 
  distance = "mahalanobis",
  caliper = 0.25
)

```

## Vérification de l'équilibre des covariables :

1.  Avant matching pour déterminer les déséquilibres initiaux à partir du test de Standardized Mean Difference (SMD)

    -   Si SMD \< 0.1, il existe un équilibre satisfaisant entre les groupes pour la covariable

    -   Si SMD \> 0.1, le déséquilibre est significatif donc on augmentera l'intervalle des calipers afin d'obtenir un SMD **≤** 0.1)

2.  Après matching: Test visuel sur la qualité du matching

    Comparaison à partir du Q-Q Plot pour chaque covariable (dans le cas où le QQ plot se situe en diagonale, le quantile des 2 distributions sont similaires)

# Estimation par la Difference-in-difference

## Définition des périodes de traitement

-   Période de pré-traitement: Aires protégées crées entre 1997 et 2008

-   Période de post-traitement: Aires protégées crées entre 2008 et 2021 (71 AP créées sur 47 282 km²)

## Vérification de l'hypothèse des tendances parallèles

1.  Création d'un groupe de traitement placebo basé sur les ménages de 1997 (traitement= ménages situés à **≤** 10 km des aires protégées créées entre 2008 et 2021)

2.  Appariement du groupe de traitement placebo avec un groupe de contrôle placebo

3.  Représentation graphique de l'évolution des groupes en 1997, 2008 et 2021 pour une confirmation visuelle

4.  Effectuer un test placebo en faisant une estimation en double différence sur la période de pré-traitement (1997-2008): un effet non significatif confirmerait l'absence de tendances divergentes avant l'intervention

## Estimation du modèle DID

Estimation du modèle DID en utilisant des erreurs standards robustes aux corrélations intra-grappes pour gérer la dépendance des observations au sein des grappes:

-   calcul des résidus à partir du modèle de régression

-   Utilisation des résidus calculés pour construire une matrice variance-covariance robuste, qui va ajuster la corrélation intra-grappe

# Tests de robustesse

## Test de sensibilité aux tailles de buffer

### Test pour une distance de 5 km

-   Création d'un buffer de 5 km autour des aires protégées
-   Réassignation des traitements
-   Matching
-   Test d'équilibre
-   DID
-   Test de robustesse

### Test pour une distance de 15km

-   Création d'un buffer de 15 km autour des aires protégées Matching DID Test de robustesse
-   Réassignation des traitements
-   Matching
-   Test d'équilibre
-   DID
-   Test de robustesse

## Test pour l'hypothèse multiple

La méthode "False Directory Rate" de Benjamini-Hochberg sera appliqué aux hypothèses H2 et H3 pour corriger le problème des tests multiples.

## Analyse de sensibilité de Rosenbaum

Vérification de la robustesse des résultats issus du matching face à un éventuel biais non observé en testant différentes valeurs de Γ, afin d'évaluer dans quelle mesure la présence d'un biais caché pourraient influencer les conclusions de l'analyse

## Test des effets hétérogènes

Estimation des effets hétérogènes en introduisant des interactions entre le traitement et les différentes variables différenciatrices dans un modèle de double DID pour explorer les effets différenciés des aires protégées sur les ménages en fonction des caractéristiques socio-démographiques et environnementales

Caractéristiques socio-démographiques et environnementales:

-   Sexe et âge du chef de ménage

-   Conditions environnementales (Pluviométrie, sécheresse)

-   Type de gouvernance des aires protégées (strictes (statuts IUCN I-IV) vs multi-usages ( statuts IUCN V-VI))

-   Distance aux aires protégées (5km, 10 km, 15 km)

-   Inégalité intra-communautaire (Z-score standardisée du wealth index)

## Pseudo Panel

-   Construction de cohorte de ménage

-   Estimation d'un modèle à effet fixe pour corriger les biais liées aux variables non observés

-   Pondérer les observations en fonction de la taille des cohortes

# Appendix

## Statistical power

-   Estimation de la puissance statistique pour détecter un effet d'au moins 7.5 centiles dans l'indice de richesse entre les groupes

-   EStimation de la probabilité à un seuil de puissance fixée à 0.8 avec un seuil de signification fixée à 0.05

-   **Mobilisation des données MIS 2011, MIS 2013 et MIS 2016 si la puissance statistique est insuffisante**
